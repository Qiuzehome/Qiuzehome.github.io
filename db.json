{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.webp","path":"images/avatar.webp","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/JavaScript的执行过程.md","hash":"af7544673954e6bd7bb80e15bfc5a79a2d437874","modified":1675223519554},{"_id":"source/_posts/facebook第三方登录方案.md","hash":"869cd0ad71caa30f569f1fe5cad993b13647070f","modified":1675223868411},{"_id":"source/_posts/google新版第三方登录（javascript SDK）.md","hash":"faf1d5a4be704bf5e1b3e6cc2b2ff3e7e4016df2","modified":1675223826329},{"_id":"source/_posts/https的安全性与执行机制.md","hash":"f1bb37348b085d63f2761fa03df98b13471e86a2","modified":1675223586052},{"_id":"source/_posts/javascript中new做了什么.md","hash":"b94ced534c9b33e7c3c7bee02f631774bc63f51d","modified":1675223739548},{"_id":"source/_posts/vue3响应系统的作用与实现.md","hash":"291ff12a0fa4e68581ed18d6958f25e9757f3ea8","modified":1675231881724},{"_id":"source/_posts/浏览器渲染页面时，渲染进程做了什么.md","hash":"e5e5959ac7496278d8d8fbb6ff3d13163a9f44f5","modified":1675224007665},{"_id":"source/_posts/几个常见的事件复杂度.md","hash":"0e1478bf54eb66e481f7244542e3a1cb709e3a54","modified":1675222802281},{"_id":"source/_posts/用Webpack搭建一个React项目.md","hash":"aa92eba6157b68819475189a7ce0666cae6341d9","modified":1675222072203},{"_id":"source/_posts/用node实现cors跨域.md","hash":"e4fe477e7e505667f8b4e204921d80e0a2071f34","modified":1675223221077},{"_id":"source/_posts/禁止from disk cache.md","hash":"9393369bdee5f6a630f680255fe45709ea897f70","modified":1675231983109},{"_id":"source/_posts/简单介绍下什么是nginx？它能用来做什么？.md","hash":"142846e0319182b42a9c0c447512d2f73dca3f11","modified":1675222828150},{"_id":"source/_posts/谷歌浏览器插件开发.md","hash":"5c8d3d1a70b1dc0d308889ffe75857800149e91f","modified":1675222790522},{"_id":"source/_posts/通过javascript与node代码实现JSONP解决跨域.md","hash":"588c520f9148ecc5d9dc124def62cf897b63f618","modified":1675223256316},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1675161821683},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1675161821683},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1675161821683},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1675161821691},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1675161821691},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1675161821691},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1675161821692},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1675161821692},{"_id":"themes/next/_config.yml","hash":"7950ddf57918cb10a7c0299cb151034dd04b925b","modified":1675221931824},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1675161821693},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1675161821705},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1675161821745},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1675161821684},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1675161821685},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1675161821687},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1675161821687},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1675161821688},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1675161821689},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1675161821688},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1675161821689},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1675161821689},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1675161821690},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1675161821690},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1675161821694},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1675161821694},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1675161821695},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1675161821695},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1675161821696},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1675161821696},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1675161821697},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1675161821697},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1675161821697},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1675161821705},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1675161821706},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1675161821706},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1675161821706},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1675161821707},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1675161821707},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1675161821708},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1675161821708},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1675161821708},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1675161821709},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1675161821709},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1675161821709},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1675161821710},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1675161821710},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1675161821711},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1675161821711},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1675161821711},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1675161821712},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1675161821712},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1675161821713},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1675161821713},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1675161821713},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1675161821714},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1675161821743},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1675161821743},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1675161821743},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1675161821744},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1675161821744},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1675161821744},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1675161821756},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1675161821685},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1675161821686},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1675161821687},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1675161821686},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1675161821698},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1675161821699},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1675161821699},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1675161821700},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1675161821700},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1675161821701},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1675161821701},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1675161821702},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1675161821702},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1675161821703},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1675161821703},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1675161821704},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1675161821704},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1675161821716},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1675161821716},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1675161821720},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1675161821721},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1675161821725},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1675161821715},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1675161821714},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1675161821715},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1675161821726},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1675161821726},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1675161821727},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1675161821729},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1675161821730},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1675161821732},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1675161821736},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1675161821738},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1675161821738},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1675161821745},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1675161821752},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1675161821752},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1675161821752},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1675161821753},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1675161821753},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1675161821754},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1675161821754},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1675161821755},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1675161821756},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1675161821756},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1675161821757},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1675161821758},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1675161821759},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1675161821761},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1675161821761},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1675161821761},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1675161821762},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1675161821762},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1675161821762},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1675161821763},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1675161821791},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1675161821802},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1675161821802},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1675161821802},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1675161821803},{"_id":"themes/next/source/images/avatar.webp","hash":"165b6246e3a37b5a63fd192e675590693f6e6905","modified":1675221865651},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1675161821804},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1675161821804},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1675161821805},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1675161821805},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1675161821805},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1675161821806},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1675161821806},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1675161821806},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1675161821807},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1675161821807},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1675161821808},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1675161821808},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1675161821809},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1675161821809},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1675161821810},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1675161821811},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1675161821812},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1675161821717},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1675161821717},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1675161821718},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1675161821718},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1675161821719},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1675161821719},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1675161821720},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1675161821720},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1675161821721},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1675161821721},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1675161821722},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1675161821722},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1675161821723},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1675161821723},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1675161821724},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1675161821724},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1675161821724},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1675161821725},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1675161821727},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1675161821728},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1675161821728},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1675161821728},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1675161821729},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1675161821730},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1675161821731},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1675161821731},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1675161821732},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1675161821734},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1675161821734},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1675161821734},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1675161821735},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1675161821735},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1675161821736},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1675161821732},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1675161821733},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1675161821737},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1675161821737},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1675161821737},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1675161821739},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1675161821739},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1675161821740},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1675161821740},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1675161821740},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1675161821741},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1675161821741},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1675161821742},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1675161821742},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1675161821742},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1675161821746},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1675161821746},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1675161821748},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1675161821749},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1675161821749},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1675161821750},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1675161821750},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1675161821751},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1675161821751},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1675161821751},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1675161821800},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1675161821750},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1675161821800},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1675161821800},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1675161821801},{"_id":"themes/next/source/css/_variables/base.styl","hash":"cbe3a9de8c8124e82ece6c97fb68e01532acef79","modified":1675411464100},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1675161821810},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1675161821811},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1675161821816},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1675161821817},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1675161821764},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1675161821764},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1675161821765},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1675161821772},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1675161821778},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1675161821778},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1675161821783},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1675161821783},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1675161821784},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1675161821786},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1675161821786},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1675161821787},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1675161821787},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1675161821791},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1675161821792},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1675161821792},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1675161821793},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1675161821793},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1675161821793},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1675161821794},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1675161821794},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1675221262190},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1675161821796},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1675161821795},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1675161821796},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1675161821796},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1675161821797},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1675161821797},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1675161821798},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1675161821798},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1675161821799},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1675161821799},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1675161821813},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1675161821814},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1675161821765},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1675161821766},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1675161821766},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1675161821766},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1675161821767},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1675161821767},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1675161821768},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1675161821768},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1675161821769},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1675161821769},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"b6232829d87602e68c4299d9620c50fec5e73535","modified":1675411551732},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1675161821769},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1675161821770},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1675161821770},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1675161821770},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1675161821771},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1675161821771},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a3b9f781bec3f0502f600580e7b851ae492e1d6c","modified":1675411241850},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1675161821772},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1675161821773},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1675161821773},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1675161821774},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1675161821774},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1675161821775},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1675161821775},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1675161821776},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1675161821776},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1675161821777},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1675161821777},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1675161821777},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1675161821778},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1675161821779},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1675161821780},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1675161821780},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1675161821780},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1675161821781},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1675161821781},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1675161821782},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1675161821782},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1675161821782},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1675161821783},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1675161821784},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1675161821785},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1675161821785},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1675161821786},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1675161821788},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1675161821788},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1675161821789},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1675161821789},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1675161821790},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1675161821790},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1675161821790},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1675161821814},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1675161821815},{"_id":"public/2023/02/01/禁止from disk cache/index.html","hash":"087fdd2b2814231783edb330b9b6ca5be9130376","modified":1675236240759},{"_id":"public/archives/index.html","hash":"10b651e4cbced8969da21dede29e8049d19baba9","modified":1675236240759},{"_id":"public/archives/page/2/index.html","hash":"d551393168655b1f6c4e30ed89d1cebbfd47bc79","modified":1675236240759},{"_id":"public/archives/2023/index.html","hash":"cf4b40de8271d9f3582dc060b1d3f6c4dfec44a1","modified":1675236240759},{"_id":"public/archives/2023/page/2/index.html","hash":"aa474272ab03e50dfaa723ceefe7874237165ad6","modified":1675236240759},{"_id":"public/archives/2023/01/index.html","hash":"22902c8fbc95306a76c89cc427b1cd876d804c70","modified":1675236240759},{"_id":"public/archives/2023/02/index.html","hash":"25fc392d43007f961b187bc1fe32783e8f9b15ac","modified":1675236240759},{"_id":"public/archives/2023/02/page/2/index.html","hash":"0f272d6fcb6542b8cfe1962a0fc3b78118174a6c","modified":1675236240759},{"_id":"public/tags/JavaScript/index.html","hash":"fd5f1c258c0b5c93f2e5e688c7ad0c00e65b3640","modified":1675236240759},{"_id":"public/tags/计算机网络/index.html","hash":"f9b3bd4e2a7803d782c5614a5041732e7ae13df3","modified":1675236240759},{"_id":"public/tags/其他/index.html","hash":"62732aff2882aa660e4a57c9b0227d4a5b0c51a0","modified":1675236240759},{"_id":"public/tags/算法/index.html","hash":"fdfce9ee01e9f8aa941fd61f039416b5188b0842","modified":1675236240759},{"_id":"public/tags/工程化/index.html","hash":"3d0447f2303b75bd55a9e4317b3449bf6d1c2755","modified":1675236240759},{"_id":"public/tags/node/index.html","hash":"0d342383bd7f3baf15fa595628aaf0d7097c92b4","modified":1675236240759},{"_id":"public/2023/02/01/vue3响应系统的作用与实现/index.html","hash":"e16c65740d4eeb153f9a015608a9b8eca6964bfc","modified":1675236240759},{"_id":"public/2023/02/01/浏览器渲染页面时，渲染进程做了什么/index.html","hash":"dc5736040288635d79b1aaf2691c1d785ae3715a","modified":1675236240759},{"_id":"public/2023/02/01/facebook第三方登录方案/index.html","hash":"969a4989b69bf740148f19f6d36c8f16320e4713","modified":1675236240759},{"_id":"public/2023/02/01/google新版第三方登录（javascript SDK）/index.html","hash":"59a61fb3df00e828b302d47fd0219c331f4471e1","modified":1675236240759},{"_id":"public/2023/02/01/javascript中new做了什么/index.html","hash":"e2c70ce28b702288c3de7baf03434ee06ebee6f1","modified":1675236240759},{"_id":"public/2023/02/01/https的安全性与执行机制/index.html","hash":"e970b3cb91be40cb7cd401706ccdd06e35ca0449","modified":1675236240759},{"_id":"public/2023/02/01/用node实现cors跨域/index.html","hash":"ba79b91e31918828c72fc69637846f5803e34a63","modified":1675236240759},{"_id":"public/2023/02/01/通过javascript与node代码实现JSONP解决跨域/index.html","hash":"86f4e666ac20da97e35519fbc1ac111b39b4a11c","modified":1675236240759},{"_id":"public/2023/02/01/几个常见的事件复杂度/index.html","hash":"ca818a057a7ab93b23df60b160aced99f96c5e4b","modified":1675236240759},{"_id":"public/2023/02/01/简单介绍下什么是nginx？它能用来做什么？/index.html","hash":"04ad1b16fe5ab0c7e5f3f7e7e4b1af21a08ed0ff","modified":1675236240759},{"_id":"public/2023/02/01/谷歌浏览器插件开发/index.html","hash":"75293d84ff4409bd04ee7ef89446b31703616658","modified":1675236240759},{"_id":"public/2023/01/31/JavaScript的执行过程/index.html","hash":"8824f4ad5c0d851f25fd2cdfdf69375db02b5910","modified":1675236240759},{"_id":"public/2023/01/31/用Webpack搭建一个React项目/index.html","hash":"c1afbc0392c95e697015751f694417e801b4474f","modified":1675236240759},{"_id":"public/index.html","hash":"3a8b256358855c72eca2b5ce45690ccd52881d1a","modified":1675236240759},{"_id":"public/page/2/index.html","hash":"dd1917b7cba627b0e5bed4095287e47157119bf7","modified":1675236240759},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1675236240759},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1675236240759},{"_id":"public/images/avatar.webp","hash":"165b6246e3a37b5a63fd192e675590693f6e6905","modified":1675236240759},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1675236240759},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1675236240759},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1675236240759},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1675236240759},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1675236240759},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1675236240759},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1675236240759},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1675236240759},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1675236240759},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1675236240759},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1675236240759},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1675236240759},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1675236240759},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1675236240759},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1675236240759},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1675236240759},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1675236240759},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1675236240759},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1675236240759},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1675236240759},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1675236240759},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1675236240759},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1675236240759},{"_id":"public/css/main.css","hash":"5a21aa9efe28c0935b6bac7ea748d38c1c87181f","modified":1675236240759},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1675236240759},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1675236240759},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1675236240759},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1675159591316},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1675159591300},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1675159591300},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1675159591302},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1675159591303},{"_id":"themes/yilia/_config.yml","hash":"0d2c3ac67b32b8228c256104ccc431c918eead34","modified":1675159591303},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1675159591319},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1675159591350},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1675159591301},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1675159591302},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1675159591303},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1675159591304},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1675159591304},{"_id":"themes/yilia/.vscode/settings.json","hash":"efb112a2ac791bc66ed4e639d28485cf5ee3996c","modified":1675159613253},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1675159591305},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1675159591305},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1675159591305},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1675159591306},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1675159591317},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1675159591317},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1675159591318},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1675159591318},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1675159591318},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1675159591319},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1675159591319},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1675159591347},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1675159591320},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1675159591350},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1675159591342},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1675159591306},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1675159591307},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1675159591307},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1675159591307},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1675159591308},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1675159591308},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1675159591309},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1675159591309},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1675159591309},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1675159591310},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1675159591310},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1675159591310},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1675159591311},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1675159591311},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1675159591316},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1675159591317},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1675159591343},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1675159591343},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1675159591344},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1675159591344},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1675159591345},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1675159591345},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1675159591346},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1675159591346},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1675159591320},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1675159591346},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1675159591321},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1675159591321},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1675159591322},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1675159591322},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1675159591323},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1675159591323},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1675159591323},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1675159591324},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1675159591326},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1675159591329},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1675159591329},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1675159591330},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1675159591330},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1675159591332},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1675159591332},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1675159591332},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1675159591333},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1675159591333},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1675159591334},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1675159591334},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1675159591334},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1675159591335},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1675159591335},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1675159591336},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1675159591336},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1675159591337},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1675159591338},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1675159591338},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1675159591338},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1675159591339},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1675159591339},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1675159591339},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1675159591340},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1675159591340},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1675159591341},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1675159591341},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1675159591341},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1675159591342},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1675159591311},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1675159591312},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1675159591312},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1675159591312},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1675159591313},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1675159591313},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1675159591314},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1675159591314},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1675159591314},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1675159591315},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1675159591324},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1675159591324},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1675159591325},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1675159591326},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1675159591326},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1675159591327},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1675159591328},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1675159591328},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1675159591329},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1675159591331},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1675159591331},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1675159591331},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1675159591348},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1675159591349},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1675159591316},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1675159591302},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1675405385370},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1675405385370},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1675405385370},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1675405385370},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1675405385370},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1675405385370},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1675405385370},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1675405385370},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1675405385370},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1675405385370},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1675405385370},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1675405385370},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1675405385370}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"JavaScript的执行过程","date":"2023-01-31T09:18:13.000Z","description":"我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话...","_content":"## 1.执行上下文\n\n```javascript\nshowNum()\nconsole.log(mynum)\nvar mynum = '111'\nfunction showNum() {\n    console.log('111');\n}\n```\n\n<!--more-->\n我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话，这段代码第一行showNum还没定义，所以会报错，第二行mynum同理。然而结果是第一行输出111，第二行输出undefined，然而如果我们把声明的代码去掉的话，那它必然是报错的。\n\n由此我们可以得到几个结论\n\n- 1.在执行过程中，若用了未声明的变量，那么javascript执行会报错\n- 2.在一个变量定义之前使用它不会报错，但该值会变成undefined\n- 3.在一个函数声明之前使用它，能正常使用\n\n根据我们从上到下的执行顺序来看第一行很好理解，主要看下另外两条结论。\n\n### 变量提升\n\njavascript在执行的时候，javascript引擎会自动把变量和函数声明的部分提升到代码开头，并且会给它设置一个默认值就是undefined\n\n```javascript\nvar mynum = undefined\nconsole.log(mynum)\nmynum = '111';\n```\n\n所以我们在定义mynum的时候，并且将它输出的时候，它的代码执行顺序其实是这样的\n\n那么为什么showNum是可以输出111呢\n\n```javascript\nfn1();\nfn2();\nfunction fn1(){\n\tconsole.log('fn1')\n}\nvar fn2 = function(){\n    console.log('fn2')\n}\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/83926ae51ad344cca048f8d364684e2c.png)\n\n\nfn1是一个完整的函数声明，没涉及赋值的操作，而fn2是先声明fn2再把function赋值给它，因此fn2声明后被提升到前面时它的值是undefined，所以会报is not a function的错误\n\n```javascript\nshowNum()\nconsole.log(mynum)\nvar mynum = '111'\nfunction showNum() {\n    console.log('111');\n}\n\n\n//变量提升部分\nvar mynum = undefined\nfunction showNum(){\n    console.log('111')\n} \n//执行部分\nshowNum()\nconsole.log(mynum)\nmynum = '111'\n```\n\n实际上变量和函数声明里代码的位置是不会改变的，所谓的变量提升其实是在编译阶段被javascript引擎放到内存中，所以我们最初的那段代码经过编译后它是这样的\n\n![请添加图片描述](https://img-blog.csdnimg.cn/414c75a71655457aacdd72bcb084abd7.png)\n\n\n**执行上下文是JavaScript执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。\n\n## 2.调用栈\n\n### 函数调用\n\n```javascript\nvar a = 2\nfunction add(){\nvar b = 10\nreturn  a+b\n}\nadd()\n```\n\n当我们执行上面这段代码的时候，代码中的a，add都会被保存在全局的执行上下文中，当执行到add( )时，javascript判断这是一个函数调用，于是会做出以下操作\n\n- 从全局执行上下文中取出add函数的代码\n- 对add函数这段代码进行编译，并创建该函数的执行上下文和可执行代码\n- 执行代码，输出结果![请添加图片描述](https://img-blog.csdnimg.cn/1bd25900c02e47da90ceac48f8029118.png)\n\n\n这个时候这段代码会拥有两段执行上下文，一段是全局的，一段是add函数的，也就是说在执行javascript的时候，可能存在多个执行上下文。而javascript就是通过栈来管理这些执行上下文的\n\n### JavaScript调用栈\n\n在执行上下文创建好后，javascript会将执行上下文压入栈中，这种管理执行上下文的栈被称为执行上下文栈，也就是我们平时说的**调用栈**。\n\n观看下面这段相对复杂一点的代码的调用栈\n\n```javascript\nvar a = 1\nfunction add_1 (b,c){\n    return b+c\n}\nfunction add_2(b,c){\n    var d = 4\n    var e = add_1(b,c)\n    return a + e + d \n}\nadd_2(2,3)\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/bb5981388ee14e4b8074511ba80c8e55.png)\n\n这里解释一下为什么**add_2的执行上下文中e是undefined**。其实在将其执行上下文压入调用栈中时，一开始这些变量的值根据我们前面说到的**变量提升**，都是**undefined**，是经过执行代码之后它们的值才发生了变化，而当我们执行到**var e = add_1(b,c)**的时候，代码执行了**add_1**方法，这时候在给它赋值之前需要**先执行add_1函数，于是它还是undefined**，当add_1执行结束之后其调用栈会变成这样。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/5f996353d8ab4fcba03b0bae4392de48.png)\n\n可以看到在add_1函数执行结束之后，它的执行上下文会从调用栈中弹出，并且将值返回给e。接着add_2执行完之后它的执行上下文也会从调用栈中弹出，只剩下全局执行上下文，到这里整个执行流程就结束了。\n\n> 在平时开发过程中，我们也可以通过控制台打断点的方式或者使用console.trace()来输出当前的函数调用关系\n\n##### 栈溢出\n\n**调用栈是有大小的**，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做**栈溢出**。\n\n就像这段代码，通过递归不断地向调用栈压入fn的执行上下文，导致入栈的执行上下文超过了它的限制，就会抛出栈溢出的错误\n\n```javascript\nfunction fn(a){\n    return fn(a)\n}\nfn(a)\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/a0f4ba0fdfe94d72b96df4dab4bd4ca8.png)\n## 3.块级作用域\n\njavascript因为存在着我们之前讲到的变量提升这一特性，导致了它的一些执行方式不符合从上到下的执行顺序，所以es6中引入了块级作用域避开了这种缺陷，而在这之前javascript是只有全局作用域跟函数作用域。\n\n```javascript\n//if块\nif(1){}\n\n//while块\nwhile(1){}\n\n//函数块\nfunction foo(){\n \n//for循环块\nfor(let i = 0; i<100; i++){}\n\n//单独一个块\n{}\n```\n\n举个例子说一下没有块级作用域的缺陷\n\n```javascript\nfunction fn(){\n    for(var i =0;i<8;i++){}\n    console.log(i)\n}\nfn()\n\n```\n\n按理想状态来说。for循环中的i在这段循环结束后应该是被销毁了，然而在这段代码中它没有被销毁，所以最后输出了8\n\n再看看通过let使用块级作用域的\n\n```javascript\nfunction fn(){\n    for(let i =0;i<8;i++){}\n    console.log(i)\n}\nfn()\n\n```\n\n会发现下面输出i的时候报了not defined的错误，这种就非常**符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量**。\n\n### JavaScript是如何支持块级作用域的\n\n```javascript\nfunction fn(){\n    var a = 1\n    let b = 2\n    {\n      let b = 3\n      var c = 4\n      let d = 5\n      console.log(a)\n      console.log(b)\n    }\n    console.log(b) \n    console.log(c)\n    console.log(d)\n}   \nfn()\n\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/50cef8d8af0741918eaf5c9ee65495e0.png)\n\n当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，它们都是独立的存在。\n\n其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。\n\n当作用域块执行结束后，其内部定义的变量就会从词法环境中弹出，类似调用栈\n\n## 4.作用域链\n\n```javascript\nfunction fn1(){\n\tconsole.log(a)\n}\nfunction fn2(){\n\tvar a = 2\n\tfn1()\n}\nvar a = 1\nfn2()\n\n```\n\n这段代码如果根据先前讲到的调用栈去分析的话，可能会觉得会从上往下去取到 fn2的执行上下文中的a，所以输出2，但其实不是这样的\n\n这里的作用域链如下\n![请添加图片描述](https://img-blog.csdnimg.cn/edcea4de4b93412da8804a150943ba79.png)\nfn1，fn2的作用域链其实都是指向了全局，这是因为在JavaScript执行过程中，其作用域链是由**词法作用域**决定的。\n\n### 词法作用域\n\n**词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**\n![请添加图片描述](https://img-blog.csdnimg.cn/14c035155e1f49d18c48333c6d104ab9.png)\n\n从图中可以看出，词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包含了foo函数，因为JavaScript作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域—>bar函数作用域—>main函数作用域—>全局作用域。\n\n回去看先前的那段代码，fn1,fn2的上级作用域都是全局作用域，所以在这两个函数内用了一个它们没有定义的变量，那它们就会到全局作用域里面去找。也就是说，**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。\n\n### 闭包\n\n```javascript\nfunction fn(){\n    var name ='a'\n    var fn_name={\n        getname:function(){\n            return name\n        },\n         setname:function(new_name){\n            name = new_name\n        }\n    }\n    return fn_name\n}\nvar bar = fn()\nbar.setname('b')\nconsole.log(bar.getname())\n\n```\n\n**根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数fn中的变量name。**虽然fn执行结束了，但是getname,setname依然可以使用fn中的变量name。所以**fn执行结束后**，它的整个调用栈其实是这样的\n![请添加图片描述](https://img-blog.csdnimg.cn/b516bc03990c4f028dca58ce0f21dc87.png)\n\nfn函数执行结束后其执行上下文会从调用栈中弹出，但由于返回的setname，getname保留了对fn内部name的引用，所以这个变量依然保留在内存中。这就像生成了一个setname，getname的专属包，因为除了它们其他任何地方都无法访问到，这个包就是所谓的闭包。\n\n当我们执行bar.setName('b')的时候，javascript引擎会沿着**当前执行上下文–>fn函数闭包–>全局执行上下文**的顺序来查找变量\n\n## 5.数据是如何存储的\n\n> JavaScript的内存模型\n\n从图中可以看出， 在JavaScript的执行过程中， 主要有三种类型内存空间，分别是**代码空间、栈空间**和**堆空间**。这里的栈空间就是我们之前反复提及的调用栈，是用来存储执![请添加图片描述](https://img-blog.csdnimg.cn/3dde1f72f5954b558b18a9bfb8d5fd22.png)\n行上下文的。\n\n```javascript\nfunction fn(){\n    var a = 'a',\n        b = a,\n        c = {num:3},\n        d = c\n}\n\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/5e5fbfb6754746428ef37e6e7cdaf41d.png)\n\n**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的**。\n\nJavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的fn函数执行结束了，JavaScript引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，fn函数执行上下文栈区空间全部回收。\n\n所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。\n\n在JavaScript中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。\n\n还有一种特殊情况是**闭包，当执行到内部函数的时候，javascript引擎会对内部函数做一次词法扫描，当发现这是一个闭包的时候，会在堆空间创建一个closure的对象**（这是一个内部对象，JavaScript是无法访问的），用来保存闭包用到的变量。\n![请添加图片描述](https://img-blog.csdnimg.cn/325890b708154f1387f1aa824c9f2ef1.png)\n\n总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。\n\n## 6.垃圾回收\n\n有些数据被使用之后，可能就不再需要了，我们把这种数据称为**垃圾数据**。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要**对这些垃圾数据进行回收，以释放有限的内存空间**。\n\n### 调用栈中的数据是如何回收的\n\n```javascript\nfunction fn (){\n    var a = 1\n    var b = {num:1}\n    function fn_in{\n        var c = 3\n        var d = {num:4}\n    }\n    fn_in()\n}\nfn()\n\n```\n\n当执行到fn_in内的时候，其调用栈和对空间状态如下\n![请添加图片描述](https://img-blog.csdnimg.cn/6a2ea5b8125042e28eb56c70ff468253.png)\n\n与此同时，还有一个**记录当前执行状态的指针（称为ESP）**，指向调用栈中fn_in函数的执行上下文，表示当前正在执行fn_in函数。接着，当fn_in函数执行完成之后，函数执行流程就进入了fn函数，那这时就需要销毁fn_in函数的执行上下文了。ESP这时候就帮上忙了，JavaScript会将ESP下移到fn函数的执行上下文，**这个下移操作就是销毁fn_in函数执行上下文的过程**。\n\n### 堆中的数据是如何回收的\n\n当上面那段代码的fn函数执行结束之后，ESP应该是指向全局执行上下文的，那这样的话，fn_in函数和fn函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间。**要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了**。\n\n在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。\n\n新生区通常只支持1～8M的容量，而老生区支持的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。\n\n- **副垃圾回收器，主要负责新生代的垃圾回收。**\n- **主垃圾回收器，主要负责老生代的垃圾回收。**\n\n### 工作流程\n\n其实**不论什么类型的垃圾回收器，它们都有一套共同的执行流程**。\n\n第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。\n\n第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。\n\n第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。\n\n#### 副垃圾回收器\n\n副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。\n\n新生代中用**Scavenge算法**来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：\n<img src=\"https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png\" alt=\"img\" style=\"zoom:67%;\" />\n新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n\n在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。\n\n完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**。\n\n由于新生代中采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小**。\n\n也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。\n\n### 主垃圾回收器\n\n由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用**标记-清除（Mark-Sweep）**的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。\n\n首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。\n\n接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：\n![请添加图片描述](https://img-blog.csdnimg.cn/293992da0a1841b7adfb443d178c149a.png)\n\n上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——**标记-整理（Mark-Compact）**，这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：\n![请添加图片描述](https://img-blog.csdnimg.cn/c25c18fd2a374890a0faf4c3adda4353.png)\n\n### 全停顿\n\n由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。\n![请添加图片描述](https://img-blog.csdnimg.cn/7ca69ac17e9844bfb445d9765ddb152f.png)\n\n在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的，这将会造成页面的卡顿现象。\n\n为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所示：\n![请添加图片描述](https://img-blog.csdnimg.cn/215a1bde974d44679b7a6c118666ced7.png)使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。","source":"_posts/JavaScript的执行过程.md","raw":"---\ntitle: JavaScript的执行过程\ndate: 2023-01-31 17:18:13\ntag: JavaScript\ndescription: 我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话...\n---\n## 1.执行上下文\n\n```javascript\nshowNum()\nconsole.log(mynum)\nvar mynum = '111'\nfunction showNum() {\n    console.log('111');\n}\n```\n\n<!--more-->\n我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话，这段代码第一行showNum还没定义，所以会报错，第二行mynum同理。然而结果是第一行输出111，第二行输出undefined，然而如果我们把声明的代码去掉的话，那它必然是报错的。\n\n由此我们可以得到几个结论\n\n- 1.在执行过程中，若用了未声明的变量，那么javascript执行会报错\n- 2.在一个变量定义之前使用它不会报错，但该值会变成undefined\n- 3.在一个函数声明之前使用它，能正常使用\n\n根据我们从上到下的执行顺序来看第一行很好理解，主要看下另外两条结论。\n\n### 变量提升\n\njavascript在执行的时候，javascript引擎会自动把变量和函数声明的部分提升到代码开头，并且会给它设置一个默认值就是undefined\n\n```javascript\nvar mynum = undefined\nconsole.log(mynum)\nmynum = '111';\n```\n\n所以我们在定义mynum的时候，并且将它输出的时候，它的代码执行顺序其实是这样的\n\n那么为什么showNum是可以输出111呢\n\n```javascript\nfn1();\nfn2();\nfunction fn1(){\n\tconsole.log('fn1')\n}\nvar fn2 = function(){\n    console.log('fn2')\n}\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/83926ae51ad344cca048f8d364684e2c.png)\n\n\nfn1是一个完整的函数声明，没涉及赋值的操作，而fn2是先声明fn2再把function赋值给它，因此fn2声明后被提升到前面时它的值是undefined，所以会报is not a function的错误\n\n```javascript\nshowNum()\nconsole.log(mynum)\nvar mynum = '111'\nfunction showNum() {\n    console.log('111');\n}\n\n\n//变量提升部分\nvar mynum = undefined\nfunction showNum(){\n    console.log('111')\n} \n//执行部分\nshowNum()\nconsole.log(mynum)\nmynum = '111'\n```\n\n实际上变量和函数声明里代码的位置是不会改变的，所谓的变量提升其实是在编译阶段被javascript引擎放到内存中，所以我们最初的那段代码经过编译后它是这样的\n\n![请添加图片描述](https://img-blog.csdnimg.cn/414c75a71655457aacdd72bcb084abd7.png)\n\n\n**执行上下文是JavaScript执行一段代码时的运行环境**，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。\n\n## 2.调用栈\n\n### 函数调用\n\n```javascript\nvar a = 2\nfunction add(){\nvar b = 10\nreturn  a+b\n}\nadd()\n```\n\n当我们执行上面这段代码的时候，代码中的a，add都会被保存在全局的执行上下文中，当执行到add( )时，javascript判断这是一个函数调用，于是会做出以下操作\n\n- 从全局执行上下文中取出add函数的代码\n- 对add函数这段代码进行编译，并创建该函数的执行上下文和可执行代码\n- 执行代码，输出结果![请添加图片描述](https://img-blog.csdnimg.cn/1bd25900c02e47da90ceac48f8029118.png)\n\n\n这个时候这段代码会拥有两段执行上下文，一段是全局的，一段是add函数的，也就是说在执行javascript的时候，可能存在多个执行上下文。而javascript就是通过栈来管理这些执行上下文的\n\n### JavaScript调用栈\n\n在执行上下文创建好后，javascript会将执行上下文压入栈中，这种管理执行上下文的栈被称为执行上下文栈，也就是我们平时说的**调用栈**。\n\n观看下面这段相对复杂一点的代码的调用栈\n\n```javascript\nvar a = 1\nfunction add_1 (b,c){\n    return b+c\n}\nfunction add_2(b,c){\n    var d = 4\n    var e = add_1(b,c)\n    return a + e + d \n}\nadd_2(2,3)\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/bb5981388ee14e4b8074511ba80c8e55.png)\n\n这里解释一下为什么**add_2的执行上下文中e是undefined**。其实在将其执行上下文压入调用栈中时，一开始这些变量的值根据我们前面说到的**变量提升**，都是**undefined**，是经过执行代码之后它们的值才发生了变化，而当我们执行到**var e = add_1(b,c)**的时候，代码执行了**add_1**方法，这时候在给它赋值之前需要**先执行add_1函数，于是它还是undefined**，当add_1执行结束之后其调用栈会变成这样。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/5f996353d8ab4fcba03b0bae4392de48.png)\n\n可以看到在add_1函数执行结束之后，它的执行上下文会从调用栈中弹出，并且将值返回给e。接着add_2执行完之后它的执行上下文也会从调用栈中弹出，只剩下全局执行上下文，到这里整个执行流程就结束了。\n\n> 在平时开发过程中，我们也可以通过控制台打断点的方式或者使用console.trace()来输出当前的函数调用关系\n\n##### 栈溢出\n\n**调用栈是有大小的**，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做**栈溢出**。\n\n就像这段代码，通过递归不断地向调用栈压入fn的执行上下文，导致入栈的执行上下文超过了它的限制，就会抛出栈溢出的错误\n\n```javascript\nfunction fn(a){\n    return fn(a)\n}\nfn(a)\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/a0f4ba0fdfe94d72b96df4dab4bd4ca8.png)\n## 3.块级作用域\n\njavascript因为存在着我们之前讲到的变量提升这一特性，导致了它的一些执行方式不符合从上到下的执行顺序，所以es6中引入了块级作用域避开了这种缺陷，而在这之前javascript是只有全局作用域跟函数作用域。\n\n```javascript\n//if块\nif(1){}\n\n//while块\nwhile(1){}\n\n//函数块\nfunction foo(){\n \n//for循环块\nfor(let i = 0; i<100; i++){}\n\n//单独一个块\n{}\n```\n\n举个例子说一下没有块级作用域的缺陷\n\n```javascript\nfunction fn(){\n    for(var i =0;i<8;i++){}\n    console.log(i)\n}\nfn()\n\n```\n\n按理想状态来说。for循环中的i在这段循环结束后应该是被销毁了，然而在这段代码中它没有被销毁，所以最后输出了8\n\n再看看通过let使用块级作用域的\n\n```javascript\nfunction fn(){\n    for(let i =0;i<8;i++){}\n    console.log(i)\n}\nfn()\n\n```\n\n会发现下面输出i的时候报了not defined的错误，这种就非常**符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量**。\n\n### JavaScript是如何支持块级作用域的\n\n```javascript\nfunction fn(){\n    var a = 1\n    let b = 2\n    {\n      let b = 3\n      var c = 4\n      let d = 5\n      console.log(a)\n      console.log(b)\n    }\n    console.log(b) \n    console.log(c)\n    console.log(d)\n}   \nfn()\n\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/50cef8d8af0741918eaf5c9ee65495e0.png)\n\n当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，它们都是独立的存在。\n\n其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。\n\n当作用域块执行结束后，其内部定义的变量就会从词法环境中弹出，类似调用栈\n\n## 4.作用域链\n\n```javascript\nfunction fn1(){\n\tconsole.log(a)\n}\nfunction fn2(){\n\tvar a = 2\n\tfn1()\n}\nvar a = 1\nfn2()\n\n```\n\n这段代码如果根据先前讲到的调用栈去分析的话，可能会觉得会从上往下去取到 fn2的执行上下文中的a，所以输出2，但其实不是这样的\n\n这里的作用域链如下\n![请添加图片描述](https://img-blog.csdnimg.cn/edcea4de4b93412da8804a150943ba79.png)\nfn1，fn2的作用域链其实都是指向了全局，这是因为在JavaScript执行过程中，其作用域链是由**词法作用域**决定的。\n\n### 词法作用域\n\n**词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。**\n![请添加图片描述](https://img-blog.csdnimg.cn/14c035155e1f49d18c48333c6d104ab9.png)\n\n从图中可以看出，词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包含了foo函数，因为JavaScript作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域—>bar函数作用域—>main函数作用域—>全局作用域。\n\n回去看先前的那段代码，fn1,fn2的上级作用域都是全局作用域，所以在这两个函数内用了一个它们没有定义的变量，那它们就会到全局作用域里面去找。也就是说，**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**。\n\n### 闭包\n\n```javascript\nfunction fn(){\n    var name ='a'\n    var fn_name={\n        getname:function(){\n            return name\n        },\n         setname:function(new_name){\n            name = new_name\n        }\n    }\n    return fn_name\n}\nvar bar = fn()\nbar.setname('b')\nconsole.log(bar.getname())\n\n```\n\n**根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数fn中的变量name。**虽然fn执行结束了，但是getname,setname依然可以使用fn中的变量name。所以**fn执行结束后**，它的整个调用栈其实是这样的\n![请添加图片描述](https://img-blog.csdnimg.cn/b516bc03990c4f028dca58ce0f21dc87.png)\n\nfn函数执行结束后其执行上下文会从调用栈中弹出，但由于返回的setname，getname保留了对fn内部name的引用，所以这个变量依然保留在内存中。这就像生成了一个setname，getname的专属包，因为除了它们其他任何地方都无法访问到，这个包就是所谓的闭包。\n\n当我们执行bar.setName('b')的时候，javascript引擎会沿着**当前执行上下文–>fn函数闭包–>全局执行上下文**的顺序来查找变量\n\n## 5.数据是如何存储的\n\n> JavaScript的内存模型\n\n从图中可以看出， 在JavaScript的执行过程中， 主要有三种类型内存空间，分别是**代码空间、栈空间**和**堆空间**。这里的栈空间就是我们之前反复提及的调用栈，是用来存储执![请添加图片描述](https://img-blog.csdnimg.cn/3dde1f72f5954b558b18a9bfb8d5fd22.png)\n行上下文的。\n\n```javascript\nfunction fn(){\n    var a = 'a',\n        b = a,\n        c = {num:3},\n        d = c\n}\n\n```\n![请添加图片描述](https://img-blog.csdnimg.cn/5e5fbfb6754746428ef37e6e7cdaf41d.png)\n\n**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的**。\n\nJavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的fn函数执行结束了，JavaScript引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，fn函数执行上下文栈区空间全部回收。\n\n所以**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。\n\n在JavaScript中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。\n\n还有一种特殊情况是**闭包，当执行到内部函数的时候，javascript引擎会对内部函数做一次词法扫描，当发现这是一个闭包的时候，会在堆空间创建一个closure的对象**（这是一个内部对象，JavaScript是无法访问的），用来保存闭包用到的变量。\n![请添加图片描述](https://img-blog.csdnimg.cn/325890b708154f1387f1aa824c9f2ef1.png)\n\n总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。\n\n## 6.垃圾回收\n\n有些数据被使用之后，可能就不再需要了，我们把这种数据称为**垃圾数据**。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要**对这些垃圾数据进行回收，以释放有限的内存空间**。\n\n### 调用栈中的数据是如何回收的\n\n```javascript\nfunction fn (){\n    var a = 1\n    var b = {num:1}\n    function fn_in{\n        var c = 3\n        var d = {num:4}\n    }\n    fn_in()\n}\nfn()\n\n```\n\n当执行到fn_in内的时候，其调用栈和对空间状态如下\n![请添加图片描述](https://img-blog.csdnimg.cn/6a2ea5b8125042e28eb56c70ff468253.png)\n\n与此同时，还有一个**记录当前执行状态的指针（称为ESP）**，指向调用栈中fn_in函数的执行上下文，表示当前正在执行fn_in函数。接着，当fn_in函数执行完成之后，函数执行流程就进入了fn函数，那这时就需要销毁fn_in函数的执行上下文了。ESP这时候就帮上忙了，JavaScript会将ESP下移到fn函数的执行上下文，**这个下移操作就是销毁fn_in函数执行上下文的过程**。\n\n### 堆中的数据是如何回收的\n\n当上面那段代码的fn函数执行结束之后，ESP应该是指向全局执行上下文的，那这样的话，fn_in函数和fn函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间。**要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了**。\n\n在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。\n\n新生区通常只支持1～8M的容量，而老生区支持的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。\n\n- **副垃圾回收器，主要负责新生代的垃圾回收。**\n- **主垃圾回收器，主要负责老生代的垃圾回收。**\n\n### 工作流程\n\n其实**不论什么类型的垃圾回收器，它们都有一套共同的执行流程**。\n\n第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。\n\n第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。\n\n第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。\n\n#### 副垃圾回收器\n\n副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。\n\n新生代中用**Scavenge算法**来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：\n<img src=\"https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png\" alt=\"img\" style=\"zoom:67%;\" />\n新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n\n在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。\n\n完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**。\n\n由于新生代中采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小**。\n\n也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。\n\n### 主垃圾回收器\n\n由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用**标记-清除（Mark-Sweep）**的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。\n\n首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。\n\n接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：\n![请添加图片描述](https://img-blog.csdnimg.cn/293992da0a1841b7adfb443d178c149a.png)\n\n上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——**标记-整理（Mark-Compact）**，这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：\n![请添加图片描述](https://img-blog.csdnimg.cn/c25c18fd2a374890a0faf4c3adda4353.png)\n\n### 全停顿\n\n由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。\n![请添加图片描述](https://img-blog.csdnimg.cn/7ca69ac17e9844bfb445d9765ddb152f.png)\n\n在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的，这将会造成页面的卡顿现象。\n\n为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所示：\n![请添加图片描述](https://img-blog.csdnimg.cn/215a1bde974d44679b7a6c118666ced7.png)使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。","slug":"JavaScript的执行过程","published":1,"updated":"2023-02-01T03:51:59.554Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekgr0000ywnkfbn18myk","content":"<h2 id=\"1-执行上下文\"><a href=\"#1-执行上下文\" class=\"headerlink\" title=\"1.执行上下文\"></a>1.执行上下文</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n<p>我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话，这段代码第一行showNum还没定义，所以会报错，第二行mynum同理。然而结果是第一行输出111，第二行输出undefined，然而如果我们把声明的代码去掉的话，那它必然是报错的。</p>\n<p>由此我们可以得到几个结论</p>\n<ul>\n<li>1.在执行过程中，若用了未声明的变量，那么javascript执行会报错</li>\n<li>2.在一个变量定义之前使用它不会报错，但该值会变成undefined</li>\n<li>3.在一个函数声明之前使用它，能正常使用</li>\n</ul>\n<p>根据我们从上到下的执行顺序来看第一行很好理解，主要看下另外两条结论。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>javascript在执行的时候，javascript引擎会自动把变量和函数声明的部分提升到代码开头，并且会给它设置一个默认值就是undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\">mynum = <span class=\"string\">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以我们在定义mynum的时候，并且将它输出的时候，它的代码执行顺序其实是这样的</p>\n<p>那么为什么showNum是可以输出111呢</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"title function_\">fn2</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fn1&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fn2&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/83926ae51ad344cca048f8d364684e2c.png\" alt=\"请添加图片描述\"></p>\n<p>fn1是一个完整的函数声明，没涉及赋值的操作，而fn2是先声明fn2再把function赋值给它，因此fn2声明后被提升到前面时它的值是undefined，所以会报is not a function的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//变量提升部分</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//执行部分</span></span><br><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\">mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上变量和函数声明里代码的位置是不会改变的，所谓的变量提升其实是在编译阶段被javascript引擎放到内存中，所以我们最初的那段代码经过编译后它是这样的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/414c75a71655457aacdd72bcb084abd7.png\" alt=\"请添加图片描述\"></p>\n<p><strong>执行上下文是JavaScript执行一段代码时的运行环境</strong>，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。</p>\n<h2 id=\"2-调用栈\"><a href=\"#2-调用栈\" class=\"headerlink\" title=\"2.调用栈\"></a>2.调用栈</h2><h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">return</span>  a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">add</span>()</span><br></pre></td></tr></table></figure>\n\n<p>当我们执行上面这段代码的时候，代码中的a，add都会被保存在全局的执行上下文中，当执行到add( )时，javascript判断这是一个函数调用，于是会做出以下操作</p>\n<ul>\n<li>从全局执行上下文中取出add函数的代码</li>\n<li>对add函数这段代码进行编译，并创建该函数的执行上下文和可执行代码</li>\n<li>执行代码，输出结果<img src=\"https://img-blog.csdnimg.cn/1bd25900c02e47da90ceac48f8029118.png\" alt=\"请添加图片描述\"></li>\n</ul>\n<p>这个时候这段代码会拥有两段执行上下文，一段是全局的，一段是add函数的，也就是说在执行javascript的时候，可能存在多个执行上下文。而javascript就是通过栈来管理这些执行上下文的</p>\n<h3 id=\"JavaScript调用栈\"><a href=\"#JavaScript调用栈\" class=\"headerlink\" title=\"JavaScript调用栈\"></a>JavaScript调用栈</h3><p>在执行上下文创建好后，javascript会将执行上下文压入栈中，这种管理执行上下文的栈被称为执行上下文栈，也就是我们平时说的<strong>调用栈</strong>。</p>\n<p>观看下面这段相对复杂一点的代码的调用栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add_1</span> (b,c)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b+c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add_2</span>(<span class=\"params\">b,c</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d = <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"title function_\">add_1</span>(b,c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + e + d </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">add_2</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/bb5981388ee14e4b8074511ba80c8e55.png\" alt=\"请添加图片描述\"></p>\n<p>这里解释一下为什么<strong>add_2的执行上下文中e是undefined</strong>。其实在将其执行上下文压入调用栈中时，一开始这些变量的值根据我们前面说到的<strong>变量提升</strong>，都是<strong>undefined</strong>，是经过执行代码之后它们的值才发生了变化，而当我们执行到<strong>var e = add_1(b,c)<strong>的时候，代码执行了</strong>add_1</strong>方法，这时候在给它赋值之前需要<strong>先执行add_1函数，于是它还是undefined</strong>，当add_1执行结束之后其调用栈会变成这样。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5f996353d8ab4fcba03b0bae4392de48.png\" alt=\"请添加图片描述\"></p>\n<p>可以看到在add_1函数执行结束之后，它的执行上下文会从调用栈中弹出，并且将值返回给e。接着add_2执行完之后它的执行上下文也会从调用栈中弹出，只剩下全局执行上下文，到这里整个执行流程就结束了。</p>\n<blockquote>\n<p>在平时开发过程中，我们也可以通过控制台打断点的方式或者使用console.trace()来输出当前的函数调用关系</p>\n</blockquote>\n<h5 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h5><p><strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong>。</p>\n<p>就像这段代码，通过递归不断地向调用栈压入fn的执行上下文，导致入栈的执行上下文超过了它的限制，就会抛出栈溢出的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">a</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fn</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(a)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/a0f4ba0fdfe94d72b96df4dab4bd4ca8.png\" alt=\"请添加图片描述\"></p>\n<h2 id=\"3-块级作用域\"><a href=\"#3-块级作用域\" class=\"headerlink\" title=\"3.块级作用域\"></a>3.块级作用域</h2><p>javascript因为存在着我们之前讲到的变量提升这一特性，导致了它的一些执行方式不符合从上到下的执行顺序，所以es6中引入了块级作用域避开了这种缺陷，而在这之前javascript是只有全局作用域跟函数作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//if块</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//while块</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数块</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//for循环块</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单独一个块</span></span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>举个例子说一下没有块级作用域的缺陷</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)&#123;&#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按理想状态来说。for循环中的i在这段循环结束后应该是被销毁了，然而在这段代码中它没有被销毁，所以最后输出了8</p>\n<p>再看看通过let使用块级作用域的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)&#123;&#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>会发现下面输出i的时候报了not defined的错误，这种就非常<strong>符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量</strong>。</p>\n<h3 id=\"JavaScript是如何支持块级作用域的\"><a href=\"#JavaScript是如何支持块级作用域的\" class=\"headerlink\" title=\"JavaScript是如何支持块级作用域的\"></a>JavaScript是如何支持块级作用域的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> b = <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"number\">4</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> d = <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) </span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/50cef8d8af0741918eaf5c9ee65495e0.png\" alt=\"请添加图片描述\"></p>\n<p>当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，它们都是独立的存在。</p>\n<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p>\n<p>当作用域块执行结束后，其内部定义的变量就会从词法环境中弹出，类似调用栈</p>\n<h2 id=\"4-作用域链\"><a href=\"#4-作用域链\" class=\"headerlink\" title=\"4.作用域链\"></a>4.作用域链</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"title function_\">fn1</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"title function_\">fn2</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码如果根据先前讲到的调用栈去分析的话，可能会觉得会从上往下去取到 fn2的执行上下文中的a，所以输出2，但其实不是这样的</p>\n<p>这里的作用域链如下<br><img src=\"https://img-blog.csdnimg.cn/edcea4de4b93412da8804a150943ba79.png\" alt=\"请添加图片描述\"><br>fn1，fn2的作用域链其实都是指向了全局，这是因为在JavaScript执行过程中，其作用域链是由<strong>词法作用域</strong>决定的。</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong><br><img src=\"https://img-blog.csdnimg.cn/14c035155e1f49d18c48333c6d104ab9.png\" alt=\"请添加图片描述\"></p>\n<p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包含了foo函数，因为JavaScript作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域—&gt;bar函数作用域—&gt;main函数作用域—&gt;全局作用域。</p>\n<p>回去看先前的那段代码，fn1,fn2的上级作用域都是全局作用域，所以在这两个函数内用了一个它们没有定义的变量，那它们就会到全局作用域里面去找。也就是说，<strong>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn_name=&#123;</span><br><span class=\"line\">        <span class=\"attr\">getname</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">         <span class=\"attr\">setname</span>:<span class=\"keyword\">function</span>(<span class=\"params\">new_name</span>)&#123;</span><br><span class=\"line\">            name = new_name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn_name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">bar.<span class=\"title function_\">setname</span>(<span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar.<span class=\"title function_\">getname</span>())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数fn中的变量name。</strong>虽然fn执行结束了，但是getname,setname依然可以使用fn中的变量name。所以<strong>fn执行结束后</strong>，它的整个调用栈其实是这样的<br><img src=\"https://img-blog.csdnimg.cn/b516bc03990c4f028dca58ce0f21dc87.png\" alt=\"请添加图片描述\"></p>\n<p>fn函数执行结束后其执行上下文会从调用栈中弹出，但由于返回的setname，getname保留了对fn内部name的引用，所以这个变量依然保留在内存中。这就像生成了一个setname，getname的专属包，因为除了它们其他任何地方都无法访问到，这个包就是所谓的闭包。</p>\n<p>当我们执行bar.setName(‘b’)的时候，javascript引擎会沿着<strong>当前执行上下文–&gt;fn函数闭包–&gt;全局执行上下文</strong>的顺序来查找变量</p>\n<h2 id=\"5-数据是如何存储的\"><a href=\"#5-数据是如何存储的\" class=\"headerlink\" title=\"5.数据是如何存储的\"></a>5.数据是如何存储的</h2><blockquote>\n<p>JavaScript的内存模型</p>\n</blockquote>\n<p>从图中可以看出， 在JavaScript的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。这里的栈空间就是我们之前反复提及的调用栈，是用来存储执<img src=\"https://img-blog.csdnimg.cn/3dde1f72f5954b558b18a9bfb8d5fd22.png\" alt=\"请添加图片描述\"><br>行上下文的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">        b = a,</span><br><span class=\"line\">        c = &#123;<span class=\"attr\">num</span>:<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">        d = c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/5e5fbfb6754746428ef37e6e7cdaf41d.png\" alt=\"请添加图片描述\"></p>\n<p><strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的</strong>。</p>\n<p>JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的fn函数执行结束了，JavaScript引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，fn函数执行上下文栈区空间全部回收。</p>\n<p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>在JavaScript中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p>\n<p>还有一种特殊情况是<strong>闭包，当执行到内部函数的时候，javascript引擎会对内部函数做一次词法扫描，当发现这是一个闭包的时候，会在堆空间创建一个closure的对象</strong>（这是一个内部对象，JavaScript是无法访问的），用来保存闭包用到的变量。<br><img src=\"https://img-blog.csdnimg.cn/325890b708154f1387f1aa824c9f2ef1.png\" alt=\"请添加图片描述\"></p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id=\"6-垃圾回收\"><a href=\"#6-垃圾回收\" class=\"headerlink\" title=\"6.垃圾回收\"></a>6.垃圾回收</h2><p>有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p>\n<h3 id=\"调用栈中的数据是如何回收的\"><a href=\"#调用栈中的数据是如何回收的\" class=\"headerlink\" title=\"调用栈中的数据是如何回收的\"></a>调用栈中的数据是如何回收的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span> ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;<span class=\"attr\">num</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> fn_in&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> d = &#123;<span class=\"attr\">num</span>:<span class=\"number\">4</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">fn_in</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当执行到fn_in内的时候，其调用栈和对空间状态如下<br><img src=\"https://img-blog.csdnimg.cn/6a2ea5b8125042e28eb56c70ff468253.png\" alt=\"请添加图片描述\"></p>\n<p>与此同时，还有一个<strong>记录当前执行状态的指针（称为ESP）</strong>，指向调用栈中fn_in函数的执行上下文，表示当前正在执行fn_in函数。接着，当fn_in函数执行完成之后，函数执行流程就进入了fn函数，那这时就需要销毁fn_in函数的执行上下文了。ESP这时候就帮上忙了，JavaScript会将ESP下移到fn函数的执行上下文，<strong>这个下移操作就是销毁fn_in函数执行上下文的过程</strong>。</p>\n<h3 id=\"堆中的数据是如何回收的\"><a href=\"#堆中的数据是如何回收的\" class=\"headerlink\" title=\"堆中的数据是如何回收的\"></a>堆中的数据是如何回收的</h3><p>当上面那段代码的fn函数执行结束之后，ESP应该是指向全局执行上下文的，那这样的话，fn_in函数和fn函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间。<strong>要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了</strong>。</p>\n<p>在V8中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>\n<p>新生区通常只支持1～8M的容量，而老生区支持的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>\n<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p>其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<h4 id=\"副垃圾回收器\"><a href=\"#副垃圾回收器\" class=\"headerlink\" title=\"副垃圾回收器\"></a>副垃圾回收器</h4><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用<strong>Scavenge算法</strong>来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：<br><img src=\"https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png\" alt=\"img\" style=\"zoom:67%;\" /><br>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>\n<p>由于新生代中采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h3 id=\"主垃圾回收器\"><a href=\"#主垃圾回收器\" class=\"headerlink\" title=\"主垃圾回收器\"></a>主垃圾回收器</h3><p>由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记-清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：<br><img src=\"https://img-blog.csdnimg.cn/293992da0a1841b7adfb443d178c149a.png\" alt=\"请添加图片描述\"></p>\n<p>上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记-整理（Mark-Compact）</strong>，这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：<br><img src=\"https://img-blog.csdnimg.cn/c25c18fd2a374890a0faf4c3adda4353.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"全停顿\"><a href=\"#全停顿\" class=\"headerlink\" title=\"全停顿\"></a>全停顿</h3><p>由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。<br><img src=\"https://img-blog.csdnimg.cn/7ca69ac17e9844bfb445d9765ddb152f.png\" alt=\"请添加图片描述\"></p>\n<p>在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：<br><img src=\"https://img-blog.csdnimg.cn/215a1bde974d44679b7a6c118666ced7.png\" alt=\"请添加图片描述\">使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-执行上下文\"><a href=\"#1-执行上下文\" class=\"headerlink\" title=\"1.执行上下文\"></a>1.执行上下文</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>我们都知道javascript的执行顺序是从上往下执行的，按照这个逻辑来看的话，这段代码第一行showNum还没定义，所以会报错，第二行mynum同理。然而结果是第一行输出111，第二行输出undefined，然而如果我们把声明的代码去掉的话，那它必然是报错的。</p>\n<p>由此我们可以得到几个结论</p>\n<ul>\n<li>1.在执行过程中，若用了未声明的变量，那么javascript执行会报错</li>\n<li>2.在一个变量定义之前使用它不会报错，但该值会变成undefined</li>\n<li>3.在一个函数声明之前使用它，能正常使用</li>\n</ul>\n<p>根据我们从上到下的执行顺序来看第一行很好理解，主要看下另外两条结论。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>javascript在执行的时候，javascript引擎会自动把变量和函数声明的部分提升到代码开头，并且会给它设置一个默认值就是undefined</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\">mynum = <span class=\"string\">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以我们在定义mynum的时候，并且将它输出的时候，它的代码执行顺序其实是这样的</p>\n<p>那么为什么showNum是可以输出111呢</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fn1</span>();</span><br><span class=\"line\"><span class=\"title function_\">fn2</span>();</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fn1&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;fn2&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/83926ae51ad344cca048f8d364684e2c.png\" alt=\"请添加图片描述\"></p>\n<p>fn1是一个完整的函数声明，没涉及赋值的操作，而fn2是先声明fn2再把function赋值给它，因此fn2声明后被提升到前面时它的值是undefined，所以会报is not a function的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//变量提升部分</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mynum = <span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">showNum</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;111&#x27;</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//执行部分</span></span><br><span class=\"line\"><span class=\"title function_\">showNum</span>()</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(mynum)</span><br><span class=\"line\">mynum = <span class=\"string\">&#x27;111&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上变量和函数声明里代码的位置是不会改变的，所谓的变量提升其实是在编译阶段被javascript引擎放到内存中，所以我们最初的那段代码经过编译后它是这样的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/414c75a71655457aacdd72bcb084abd7.png\" alt=\"请添加图片描述\"></p>\n<p><strong>执行上下文是JavaScript执行一段代码时的运行环境</strong>，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。</p>\n<h2 id=\"2-调用栈\"><a href=\"#2-调用栈\" class=\"headerlink\" title=\"2.调用栈\"></a>2.调用栈</h2><h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">return</span>  a+b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">add</span>()</span><br></pre></td></tr></table></figure>\n\n<p>当我们执行上面这段代码的时候，代码中的a，add都会被保存在全局的执行上下文中，当执行到add( )时，javascript判断这是一个函数调用，于是会做出以下操作</p>\n<ul>\n<li>从全局执行上下文中取出add函数的代码</li>\n<li>对add函数这段代码进行编译，并创建该函数的执行上下文和可执行代码</li>\n<li>执行代码，输出结果<img src=\"https://img-blog.csdnimg.cn/1bd25900c02e47da90ceac48f8029118.png\" alt=\"请添加图片描述\"></li>\n</ul>\n<p>这个时候这段代码会拥有两段执行上下文，一段是全局的，一段是add函数的，也就是说在执行javascript的时候，可能存在多个执行上下文。而javascript就是通过栈来管理这些执行上下文的</p>\n<h3 id=\"JavaScript调用栈\"><a href=\"#JavaScript调用栈\" class=\"headerlink\" title=\"JavaScript调用栈\"></a>JavaScript调用栈</h3><p>在执行上下文创建好后，javascript会将执行上下文压入栈中，这种管理执行上下文的栈被称为执行上下文栈，也就是我们平时说的<strong>调用栈</strong>。</p>\n<p>观看下面这段相对复杂一点的代码的调用栈</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add_1</span> (b,c)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b+c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add_2</span>(<span class=\"params\">b,c</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> d = <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"title function_\">add_1</span>(b,c)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + e + d </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">add_2</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/bb5981388ee14e4b8074511ba80c8e55.png\" alt=\"请添加图片描述\"></p>\n<p>这里解释一下为什么<strong>add_2的执行上下文中e是undefined</strong>。其实在将其执行上下文压入调用栈中时，一开始这些变量的值根据我们前面说到的<strong>变量提升</strong>，都是<strong>undefined</strong>，是经过执行代码之后它们的值才发生了变化，而当我们执行到<strong>var e = add_1(b,c)<strong>的时候，代码执行了</strong>add_1</strong>方法，这时候在给它赋值之前需要<strong>先执行add_1函数，于是它还是undefined</strong>，当add_1执行结束之后其调用栈会变成这样。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5f996353d8ab4fcba03b0bae4392de48.png\" alt=\"请添加图片描述\"></p>\n<p>可以看到在add_1函数执行结束之后，它的执行上下文会从调用栈中弹出，并且将值返回给e。接着add_2执行完之后它的执行上下文也会从调用栈中弹出，只剩下全局执行上下文，到这里整个执行流程就结束了。</p>\n<blockquote>\n<p>在平时开发过程中，我们也可以通过控制台打断点的方式或者使用console.trace()来输出当前的函数调用关系</p>\n</blockquote>\n<h5 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h5><p><strong>调用栈是有大小的</strong>，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong>。</p>\n<p>就像这段代码，通过递归不断地向调用栈压入fn的执行上下文，导致入栈的执行上下文超过了它的限制，就会抛出栈溢出的错误</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\">a</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title function_\">fn</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>(a)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/a0f4ba0fdfe94d72b96df4dab4bd4ca8.png\" alt=\"请添加图片描述\"></p>\n<h2 id=\"3-块级作用域\"><a href=\"#3-块级作用域\" class=\"headerlink\" title=\"3.块级作用域\"></a>3.块级作用域</h2><p>javascript因为存在着我们之前讲到的变量提升这一特性，导致了它的一些执行方式不符合从上到下的执行顺序，所以es6中引入了块级作用域避开了这种缺陷，而在这之前javascript是只有全局作用域跟函数作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//if块</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//while块</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数块</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//for循环块</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;<span class=\"number\">100</span>; i++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//单独一个块</span></span><br><span class=\"line\">&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>举个例子说一下没有块级作用域的缺陷</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i =<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)&#123;&#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按理想状态来说。for循环中的i在这段循环结束后应该是被销毁了，然而在这段代码中它没有被销毁，所以最后输出了8</p>\n<p>再看看通过let使用块级作用域的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)&#123;&#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>会发现下面输出i的时候报了not defined的错误，这种就非常<strong>符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量</strong>。</p>\n<h3 id=\"JavaScript是如何支持块级作用域的\"><a href=\"#JavaScript是如何支持块级作用域的\" class=\"headerlink\" title=\"JavaScript是如何支持块级作用域的\"></a>JavaScript是如何支持块级作用域的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = <span class=\"number\">2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> b = <span class=\"number\">3</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> c = <span class=\"number\">4</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> d = <span class=\"number\">5</span></span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b) </span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(c)</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(d)</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/50cef8d8af0741918eaf5c9ee65495e0.png\" alt=\"请添加图片描述\"></p>\n<p>当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，它们都是独立的存在。</p>\n<p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let或者const声明的变量。</p>\n<p>当作用域块执行结束后，其内部定义的变量就会从词法环境中弹出，类似调用栈</p>\n<h2 id=\"4-作用域链\"><a href=\"#4-作用域链\" class=\"headerlink\" title=\"4.作用域链\"></a>4.作用域链</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"title function_\">fn1</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"title function_\">fn2</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这段代码如果根据先前讲到的调用栈去分析的话，可能会觉得会从上往下去取到 fn2的执行上下文中的a，所以输出2，但其实不是这样的</p>\n<p>这里的作用域链如下<br><img src=\"https://img-blog.csdnimg.cn/edcea4de4b93412da8804a150943ba79.png\" alt=\"请添加图片描述\"><br>fn1，fn2的作用域链其实都是指向了全局，这是因为在JavaScript执行过程中，其作用域链是由<strong>词法作用域</strong>决定的。</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><p><strong>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</strong><br><img src=\"https://img-blog.csdnimg.cn/14c035155e1f49d18c48333c6d104ab9.png\" alt=\"请添加图片描述\"></p>\n<p>从图中可以看出，词法作用域就是根据代码的位置来决定的，其中main函数包含了bar函数，bar函数中包含了foo函数，因为JavaScript作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域—&gt;bar函数作用域—&gt;main函数作用域—&gt;全局作用域。</p>\n<p>回去看先前的那段代码，fn1,fn2的上级作用域都是全局作用域，所以在这两个函数内用了一个它们没有定义的变量，那它们就会到全局作用域里面去找。也就是说，<strong>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系</strong>。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name =<span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> fn_name=&#123;</span><br><span class=\"line\">        <span class=\"attr\">getname</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> name</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">         <span class=\"attr\">setname</span>:<span class=\"keyword\">function</span>(<span class=\"params\">new_name</span>)&#123;</span><br><span class=\"line\">            name = new_name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn_name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">bar.<span class=\"title function_\">setname</span>(<span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar.<span class=\"title function_\">getname</span>())</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数fn中的变量name。</strong>虽然fn执行结束了，但是getname,setname依然可以使用fn中的变量name。所以<strong>fn执行结束后</strong>，它的整个调用栈其实是这样的<br><img src=\"https://img-blog.csdnimg.cn/b516bc03990c4f028dca58ce0f21dc87.png\" alt=\"请添加图片描述\"></p>\n<p>fn函数执行结束后其执行上下文会从调用栈中弹出，但由于返回的setname，getname保留了对fn内部name的引用，所以这个变量依然保留在内存中。这就像生成了一个setname，getname的专属包，因为除了它们其他任何地方都无法访问到，这个包就是所谓的闭包。</p>\n<p>当我们执行bar.setName(‘b’)的时候，javascript引擎会沿着<strong>当前执行上下文–&gt;fn函数闭包–&gt;全局执行上下文</strong>的顺序来查找变量</p>\n<h2 id=\"5-数据是如何存储的\"><a href=\"#5-数据是如何存储的\" class=\"headerlink\" title=\"5.数据是如何存储的\"></a>5.数据是如何存储的</h2><blockquote>\n<p>JavaScript的内存模型</p>\n</blockquote>\n<p>从图中可以看出， 在JavaScript的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。这里的栈空间就是我们之前反复提及的调用栈，是用来存储执<img src=\"https://img-blog.csdnimg.cn/3dde1f72f5954b558b18a9bfb8d5fd22.png\" alt=\"请添加图片描述\"><br>行上下文的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&#x27;a&#x27;</span>,</span><br><span class=\"line\">        b = a,</span><br><span class=\"line\">        c = &#123;<span class=\"attr\">num</span>:<span class=\"number\">3</span>&#125;,</span><br><span class=\"line\">        d = c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/5e5fbfb6754746428ef37e6e7cdaf41d.png\" alt=\"请添加图片描述\"></p>\n<p><strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的</strong>。</p>\n<p>JavaScript引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的fn函数执行结束了，JavaScript引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，fn函数执行上下文栈区空间全部回收。</p>\n<p>所以<strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p>\n<p>在JavaScript中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。</p>\n<p>还有一种特殊情况是<strong>闭包，当执行到内部函数的时候，javascript引擎会对内部函数做一次词法扫描，当发现这是一个闭包的时候，会在堆空间创建一个closure的对象</strong>（这是一个内部对象，JavaScript是无法访问的），用来保存闭包用到的变量。<br><img src=\"https://img-blog.csdnimg.cn/325890b708154f1387f1aa824c9f2ef1.png\" alt=\"请添加图片描述\"></p>\n<p>总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。</p>\n<h2 id=\"6-垃圾回收\"><a href=\"#6-垃圾回收\" class=\"headerlink\" title=\"6.垃圾回收\"></a>6.垃圾回收</h2><p>有些数据被使用之后，可能就不再需要了，我们把这种数据称为<strong>垃圾数据</strong>。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要<strong>对这些垃圾数据进行回收，以释放有限的内存空间</strong>。</p>\n<h3 id=\"调用栈中的数据是如何回收的\"><a href=\"#调用栈中的数据是如何回收的\" class=\"headerlink\" title=\"调用栈中的数据是如何回收的\"></a>调用栈中的数据是如何回收的</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span> ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;<span class=\"attr\">num</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> fn_in&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> c = <span class=\"number\">3</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> d = &#123;<span class=\"attr\">num</span>:<span class=\"number\">4</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"title function_\">fn_in</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fn</span>()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当执行到fn_in内的时候，其调用栈和对空间状态如下<br><img src=\"https://img-blog.csdnimg.cn/6a2ea5b8125042e28eb56c70ff468253.png\" alt=\"请添加图片描述\"></p>\n<p>与此同时，还有一个<strong>记录当前执行状态的指针（称为ESP）</strong>，指向调用栈中fn_in函数的执行上下文，表示当前正在执行fn_in函数。接着，当fn_in函数执行完成之后，函数执行流程就进入了fn函数，那这时就需要销毁fn_in函数的执行上下文了。ESP这时候就帮上忙了，JavaScript会将ESP下移到fn函数的执行上下文，<strong>这个下移操作就是销毁fn_in函数执行上下文的过程</strong>。</p>\n<h3 id=\"堆中的数据是如何回收的\"><a href=\"#堆中的数据是如何回收的\" class=\"headerlink\" title=\"堆中的数据是如何回收的\"></a>堆中的数据是如何回收的</h3><p>当上面那段代码的fn函数执行结束之后，ESP应该是指向全局执行上下文的，那这样的话，fn_in函数和fn函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间。<strong>要回收堆中的垃圾数据，就需要用到JavaScript中的垃圾回收器了</strong>。</p>\n<p>在V8中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。</p>\n<p>新生区通常只支持1～8M的容量，而老生区支持的容量就大很多了。对于这两块区域，V8分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>\n<ul>\n<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>\n<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>\n</ul>\n<h3 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h3><p>其实<strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p>\n<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>\n<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>\n<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。</p>\n<h4 id=\"副垃圾回收器\"><a href=\"#副垃圾回收器\" class=\"headerlink\" title=\"副垃圾回收器\"></a>副垃圾回收器</h4><p>副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>\n<p>新生代中用<strong>Scavenge算法</strong>来处理。所谓Scavenge算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：<br><img src=\"https://static001.geekbang.org/resource/image/4f/af/4f9310c7da631fa5a57f871099bfbeaf.png\" alt=\"img\" style=\"zoom:67%;\" /><br>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>\n<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>\n<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>\n<p>由于新生代中采用的Scavenge算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p>\n<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>\n<h3 id=\"主垃圾回收器\"><a href=\"#主垃圾回收器\" class=\"headerlink\" title=\"主垃圾回收器\"></a>主垃圾回收器</h3><p>由于老生区的对象比较大，若要在老生区中使用Scavenge算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<strong>标记-清除（Mark-Sweep）</strong>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。</p>\n<p>首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>\n<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：<br><img src=\"https://img-blog.csdnimg.cn/293992da0a1841b7adfb443d178c149a.png\" alt=\"请添加图片描述\"></p>\n<p>上面的标记过程和清除过程就是标记-清除算法，不过对一块内存多次执行标记-清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记-整理（Mark-Compact）</strong>，这个标记过程仍然与标记-清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：<br><img src=\"https://img-blog.csdnimg.cn/c25c18fd2a374890a0faf4c3adda4353.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"全停顿\"><a href=\"#全停顿\" class=\"headerlink\" title=\"全停顿\"></a>全停顿</h3><p>由于JavaScript是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。<br><img src=\"https://img-blog.csdnimg.cn/7ca69ac17e9844bfb445d9765ddb152f.png\" alt=\"请添加图片描述\"></p>\n<p>在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了200毫秒，在这200毫秒内，主线程是不能做其他事情的，这将会造成页面的卡顿现象。</p>\n<p>为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：<br><img src=\"https://img-blog.csdnimg.cn/215a1bde974d44679b7a6c118666ced7.png\" alt=\"请添加图片描述\">使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的JavaScript任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</p>"},{"title":"facebook第三方登录方案（javascript SDK）","date":"2023-02-01T03:57:26.000Z","description":"facebook第三方登录方案","_content":"# 创建应用\n- 1.登录[facebook开发者平台](https://developers.facebook.com/apps/?show_reminder=true)\n- 2.创建应用，填写相关信息->选择facebook登录->选择web->将网站加入白名单\n **客户端id**可创建后点击应用进去查看\n# 开发流程\n### 方案1\n在创建应用时，到添加白名单的时候这里会有一份流程可以按着它的流程来添加代码开发，这里就不多介绍\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ld0LN921-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&sign=9864c875004006a760cea2cc7cdade97)\\]](https://img-blog.csdnimg.cn/66a696a9a47f41689b1481d3f7c17189.png)\n\n### 方案2\n由于某些问题，步骤4中的添加按钮无法使用sdk提供的<<fb></fb>组件，这里提供另一种方法(可能是服务端加载顺序问题导致，暂时没去处理，先采用了别的方法进行开发)\n- 1.引入sdk\n```html\n//src中的zh_TW是语言版本，可替换成其他如zh_CN\n<script src=\"https://connect.facebook.net/zh_TW/sdk.js\" async defer crossorigin=\"anonymous\"></script>\n```\n- 2.初始化sdk\n```javascript\nFB.init({\n\tappId: FB_ID,//客户端id\n\tcookie: true,\n\txfbml: true,\n\tversion: 'v14.0'\n});\n```\n- 3.登录\n自定义dom调用该方法即可\n```javascript\n  FB.login(\n        function (response) {\n\t\t//获取登录状态，token,id\n            if (response.status === 'connected') {\n\t\t\t//请求api的/me接口获取用户更多信息，fields传入想获取的信息\n                FB.api('/me?fields=id,name,email', function (fb_user) {\n                    console.log(fb_user)//获取用户信息\n                });\n            } else {\n                Toast('登錄失敗，請重新登錄');\n            }\n        },\n        {scope: 'email'}//读取权限\n    );\n```\n# 踩坑\n- 1.需兼容sdk加载失败情况（翻墙网络不稳定等）\n- 2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名\n- 3.fb强制采用https，本地开发不方便调试\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S5DeXrPI-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&sign=2facf4a586daba7e9d30fa8ceecfb7b4)\\]](https://img-blog.csdnimg.cn/6070bd6f688945e9bb7a9cfdf71e6fdb.png)\n\n#相关文档\n- 开发文档：https://developers.facebook.com/docs/facebook-login/web","source":"_posts/facebook第三方登录方案.md","raw":"---\ntitle: facebook第三方登录方案（javascript SDK）\ndate: 2023-02-01 11:57:26\ntags: JavaScript\ndescription: facebook第三方登录方案\n---\n# 创建应用\n- 1.登录[facebook开发者平台](https://developers.facebook.com/apps/?show_reminder=true)\n- 2.创建应用，填写相关信息->选择facebook登录->选择web->将网站加入白名单\n **客户端id**可创建后点击应用进去查看\n# 开发流程\n### 方案1\n在创建应用时，到添加白名单的时候这里会有一份流程可以按着它的流程来添加代码开发，这里就不多介绍\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ld0LN921-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&sign=9864c875004006a760cea2cc7cdade97)\\]](https://img-blog.csdnimg.cn/66a696a9a47f41689b1481d3f7c17189.png)\n\n### 方案2\n由于某些问题，步骤4中的添加按钮无法使用sdk提供的<<fb></fb>组件，这里提供另一种方法(可能是服务端加载顺序问题导致，暂时没去处理，先采用了别的方法进行开发)\n- 1.引入sdk\n```html\n//src中的zh_TW是语言版本，可替换成其他如zh_CN\n<script src=\"https://connect.facebook.net/zh_TW/sdk.js\" async defer crossorigin=\"anonymous\"></script>\n```\n- 2.初始化sdk\n```javascript\nFB.init({\n\tappId: FB_ID,//客户端id\n\tcookie: true,\n\txfbml: true,\n\tversion: 'v14.0'\n});\n```\n- 3.登录\n自定义dom调用该方法即可\n```javascript\n  FB.login(\n        function (response) {\n\t\t//获取登录状态，token,id\n            if (response.status === 'connected') {\n\t\t\t//请求api的/me接口获取用户更多信息，fields传入想获取的信息\n                FB.api('/me?fields=id,name,email', function (fb_user) {\n                    console.log(fb_user)//获取用户信息\n                });\n            } else {\n                Toast('登錄失敗，請重新登錄');\n            }\n        },\n        {scope: 'email'}//读取权限\n    );\n```\n# 踩坑\n- 1.需兼容sdk加载失败情况（翻墙网络不稳定等）\n- 2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名\n- 3.fb强制采用https，本地开发不方便调试\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S5DeXrPI-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&sign=2facf4a586daba7e9d30fa8ceecfb7b4)\\]](https://img-blog.csdnimg.cn/6070bd6f688945e9bb7a9cfdf71e6fdb.png)\n\n#相关文档\n- 开发文档：https://developers.facebook.com/docs/facebook-login/web","slug":"facebook第三方登录方案","published":1,"updated":"2023-02-01T03:57:48.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekgx0001ywnkhy93c591","content":"<h1 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h1><ul>\n<li>1.登录<a href=\"https://developers.facebook.com/apps/?show_reminder=true\">facebook开发者平台</a></li>\n<li>2.创建应用，填写相关信息-&gt;选择facebook登录-&gt;选择web-&gt;将网站加入白名单</li>\n</ul>\n<p> <strong>客户端id</strong>可创建后点击应用进去查看</p>\n<h1 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h1><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>在创建应用时，到添加白名单的时候这里会有一份流程可以按着它的流程来添加代码开发，这里就不多介绍</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66a696a9a47f41689b1481d3f7c17189.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ld0LN921-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&amp;sign=9864c875004006a760cea2cc7cdade97)]\"></p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>由于某些问题，步骤4中的添加按钮无法使用sdk提供的&lt;<fb></fb>组件，这里提供另一种方法(可能是服务端加载顺序问题导致，暂时没去处理，先采用了别的方法进行开发)</p>\n<ul>\n<li>1.引入sdk<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//src中的zh_TW是语言版本，可替换成其他如zh_CN</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://connect.facebook.net/zh_TW/sdk.js&quot;</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span> <span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>2.初始化sdk<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FB</span>.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">appId</span>: <span class=\"variable constant_\">FB_ID</span>,<span class=\"comment\">//客户端id</span></span><br><span class=\"line\">\t<span class=\"attr\">cookie</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"attr\">xfbml</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"attr\">version</span>: <span class=\"string\">&#x27;v14.0&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>3.登录<br>自定义dom调用该方法即可<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FB</span>.<span class=\"title function_\">login</span>(</span><br><span class=\"line\">      <span class=\"keyword\">function</span> (<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//获取登录状态，token,id</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"string\">&#x27;connected&#x27;</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//请求api的/me接口获取用户更多信息，fields传入想获取的信息</span></span><br><span class=\"line\">              <span class=\"variable constant_\">FB</span>.<span class=\"title function_\">api</span>(<span class=\"string\">&#x27;/me?fields=id,name,email&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">fb_user</span>) &#123;</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fb_user)<span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"title class_\">Toast</span>(<span class=\"string\">&#x27;登錄失敗，請重新登錄&#x27;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;email&#x27;</span>&#125;<span class=\"comment\">//读取权限</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h1></li>\n<li>1.需兼容sdk加载失败情况（翻墙网络不稳定等）</li>\n<li>2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名</li>\n<li>3.fb强制采用https，本地开发不方便调试<br><img src=\"https://img-blog.csdnimg.cn/6070bd6f688945e9bb7a9cfdf71e6fdb.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S5DeXrPI-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&amp;sign=2facf4a586daba7e9d30fa8ceecfb7b4)]\"></li>\n</ul>\n<p>#相关文档</p>\n<ul>\n<li>开发文档：<a href=\"https://developers.facebook.com/docs/facebook-login/web\">https://developers.facebook.com/docs/facebook-login/web</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h1><ul>\n<li>1.登录<a href=\"https://developers.facebook.com/apps/?show_reminder=true\">facebook开发者平台</a></li>\n<li>2.创建应用，填写相关信息-&gt;选择facebook登录-&gt;选择web-&gt;将网站加入白名单</li>\n</ul>\n<p> <strong>客户端id</strong>可创建后点击应用进去查看</p>\n<h1 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h1><h3 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a>方案1</h3><p>在创建应用时，到添加白名单的时候这里会有一份流程可以按着它的流程来添加代码开发，这里就不多介绍</p>\n<p><img src=\"https://img-blog.csdnimg.cn/66a696a9a47f41689b1481d3f7c17189.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ld0LN921-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&amp;sign=9864c875004006a760cea2cc7cdade97)]\"></p>\n<h3 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a>方案2</h3><p>由于某些问题，步骤4中的添加按钮无法使用sdk提供的&lt;<fb></fb>组件，这里提供另一种方法(可能是服务端加载顺序问题导致，暂时没去处理，先采用了别的方法进行开发)</p>\n<ul>\n<li>1.引入sdk<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//src中的zh_TW是语言版本，可替换成其他如zh_CN</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://connect.facebook.net/zh_TW/sdk.js&quot;</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span> <span class=\"attr\">crossorigin</span>=<span class=\"string\">&quot;anonymous&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>2.初始化sdk<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FB</span>.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">\t<span class=\"attr\">appId</span>: <span class=\"variable constant_\">FB_ID</span>,<span class=\"comment\">//客户端id</span></span><br><span class=\"line\">\t<span class=\"attr\">cookie</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"attr\">xfbml</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t<span class=\"attr\">version</span>: <span class=\"string\">&#x27;v14.0&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>3.登录<br>自定义dom调用该方法即可<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FB</span>.<span class=\"title function_\">login</span>(</span><br><span class=\"line\">      <span class=\"keyword\">function</span> (<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">//获取登录状态，token,id</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"string\">&#x27;connected&#x27;</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//请求api的/me接口获取用户更多信息，fields传入想获取的信息</span></span><br><span class=\"line\">              <span class=\"variable constant_\">FB</span>.<span class=\"title function_\">api</span>(<span class=\"string\">&#x27;/me?fields=id,name,email&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">fb_user</span>) &#123;</span><br><span class=\"line\">                  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fb_user)<span class=\"comment\">//获取用户信息</span></span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"title class_\">Toast</span>(<span class=\"string\">&#x27;登錄失敗，請重新登錄&#x27;</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;<span class=\"attr\">scope</span>: <span class=\"string\">&#x27;email&#x27;</span>&#125;<span class=\"comment\">//读取权限</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n<h1 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h1></li>\n<li>1.需兼容sdk加载失败情况（翻墙网络不稳定等）</li>\n<li>2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名</li>\n<li>3.fb强制采用https，本地开发不方便调试<br><img src=\"https://img-blog.csdnimg.cn/6070bd6f688945e9bb7a9cfdf71e6fdb.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-S5DeXrPI-1659717799116)(http://doc.linghit.io/server/index.php?s=/api/attachment/visitFile&amp;sign=2facf4a586daba7e9d30fa8ceecfb7b4)]\"></li>\n</ul>\n<p>#相关文档</p>\n<ul>\n<li>开发文档：<a href=\"https://developers.facebook.com/docs/facebook-login/web\">https://developers.facebook.com/docs/facebook-login/web</a></li>\n</ul>\n"},{"title":"google新版第三方登录（javascript SDK）","date":"2023-02-01T03:55:59.000Z","description":"google新版第三方登录","_content":"\n# 注册流程\n- 1.登录谷歌[开发者平台](https://console.cloud.google.com/home/recommendations)，点击左上角打开选择项目弹窗选择项目，若没有项目则新建项目\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9c8141a6d75c40cc83b76d6d9203be2f.png)\n\n\n- 2.创建完项目后，若是新账号需要先填写OAuth consent screen相关信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99ccb7262c26431c99766baea62fa70e.png)\n\n- 3.创建凭证\n创建凭证 Credentials —> Create OAuth client ID —> Web application\n然后填写h5应用的相关信息和谷歌登录授权的白名单域名和授权的页面路由。创建成功后会拿到谷歌给的Client ID。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2c601f745abc4b99afa99142835d5928.png)\n\n\n# 开发流程\n- 1.引入sdk\n```html\n<script src=\"https://accounts.google.com/gsi/client\" async defer></script>\n```\n- 2.自定义按钮\n```html\n<div id=\"buttonDiv\"></div>\n```\n- 3.初始化\n```javascript\n/*\nfn :function 登录回调函数\n*/\nconst google_init=(fn)=>{\n google.accounts.id.initialize({\n        client_id: GOOGLE_ID,//客户端ID(创建应用第三步中获得的id)\n        callback: fn\n    });\n    google.accounts.id.renderButton(\n        document.getElementById('buttonDiv'),//自定义按钮\n        {theme: 'outline', size: 'large', logo_alignment: 'center'} // customization attributes\n    );\n}\n```\n- 4.登录\n登录回调拿到响应数据中的credential进行解析可以获取到账户更多信息\n```javascript\nconst google_load = (response) => {\n\tconsole.log(response)\n    const responsePayload = decode_jwt(response.credential);\n\tconsole.log(responsePayload)\n};\n//解析token\nconst decode_jwt = (token) => {\n    var base64Url = token.split('.')[1];\n    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    var jsonPayload = decodeURIComponent(\n        window\n            .atob(base64)\n            .split('')\n            .map(function (c) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            })\n            .join('')\n    );\n    return JSON.parse(jsonPayload);\n};\ngoogle_init(google_load)\n```\n# 踩坑\n- 1.需兼容sdk加载失败情况（翻墙网络不稳定等）\n- 2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名\n#相关文档\n- 开发文档：https://developers.google.com/identity/gsi/web ","source":"_posts/google新版第三方登录（javascript SDK）.md","raw":"---\ntitle: google新版第三方登录（javascript SDK）\ndate: 2023-02-01 11:55:59\ntags: JavaScript\ndescription: google新版第三方登录\n---\n\n# 注册流程\n- 1.登录谷歌[开发者平台](https://console.cloud.google.com/home/recommendations)，点击左上角打开选择项目弹窗选择项目，若没有项目则新建项目\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9c8141a6d75c40cc83b76d6d9203be2f.png)\n\n\n- 2.创建完项目后，若是新账号需要先填写OAuth consent screen相关信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99ccb7262c26431c99766baea62fa70e.png)\n\n- 3.创建凭证\n创建凭证 Credentials —> Create OAuth client ID —> Web application\n然后填写h5应用的相关信息和谷歌登录授权的白名单域名和授权的页面路由。创建成功后会拿到谷歌给的Client ID。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2c601f745abc4b99afa99142835d5928.png)\n\n\n# 开发流程\n- 1.引入sdk\n```html\n<script src=\"https://accounts.google.com/gsi/client\" async defer></script>\n```\n- 2.自定义按钮\n```html\n<div id=\"buttonDiv\"></div>\n```\n- 3.初始化\n```javascript\n/*\nfn :function 登录回调函数\n*/\nconst google_init=(fn)=>{\n google.accounts.id.initialize({\n        client_id: GOOGLE_ID,//客户端ID(创建应用第三步中获得的id)\n        callback: fn\n    });\n    google.accounts.id.renderButton(\n        document.getElementById('buttonDiv'),//自定义按钮\n        {theme: 'outline', size: 'large', logo_alignment: 'center'} // customization attributes\n    );\n}\n```\n- 4.登录\n登录回调拿到响应数据中的credential进行解析可以获取到账户更多信息\n```javascript\nconst google_load = (response) => {\n\tconsole.log(response)\n    const responsePayload = decode_jwt(response.credential);\n\tconsole.log(responsePayload)\n};\n//解析token\nconst decode_jwt = (token) => {\n    var base64Url = token.split('.')[1];\n    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    var jsonPayload = decodeURIComponent(\n        window\n            .atob(base64)\n            .split('')\n            .map(function (c) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            })\n            .join('')\n    );\n    return JSON.parse(jsonPayload);\n};\ngoogle_init(google_load)\n```\n# 踩坑\n- 1.需兼容sdk加载失败情况（翻墙网络不稳定等）\n- 2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名\n#相关文档\n- 开发文档：https://developers.google.com/identity/gsi/web ","slug":"google新版第三方登录（javascript SDK）","published":1,"updated":"2023-02-01T03:57:06.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh10003ywnkald350vy","content":"<h1 id=\"注册流程\"><a href=\"#注册流程\" class=\"headerlink\" title=\"注册流程\"></a>注册流程</h1><ul>\n<li>1.登录谷歌<a href=\"https://console.cloud.google.com/home/recommendations\">开发者平台</a>，点击左上角打开选择项目弹窗选择项目，若没有项目则新建项目<br><img src=\"https://img-blog.csdnimg.cn/9c8141a6d75c40cc83b76d6d9203be2f.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<ul>\n<li><p>2.创建完项目后，若是新账号需要先填写OAuth consent screen相关信息<br><img src=\"https://img-blog.csdnimg.cn/99ccb7262c26431c99766baea62fa70e.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>3.创建凭证<br>创建凭证 Credentials —&gt; Create OAuth client ID —&gt; Web application<br>然后填写h5应用的相关信息和谷歌登录授权的白名单域名和授权的页面路由。创建成功后会拿到谷歌给的Client ID。<br><img src=\"https://img-blog.csdnimg.cn/2c601f745abc4b99afa99142835d5928.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h1 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h1><ul>\n<li>1.引入sdk<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://accounts.google.com/gsi/client&quot;</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>2.自定义按钮<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;buttonDiv&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>3.初始化<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn :function 登录回调函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">google_init</span>=(<span class=\"params\">fn</span>)=&gt;&#123;</span><br><span class=\"line\"> google.<span class=\"property\">accounts</span>.<span class=\"property\">id</span>.<span class=\"title function_\">initialize</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">client_id</span>: <span class=\"variable constant_\">GOOGLE_ID</span>,<span class=\"comment\">//客户端ID(创建应用第三步中获得的id)</span></span><br><span class=\"line\">        <span class=\"attr\">callback</span>: fn</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    google.<span class=\"property\">accounts</span>.<span class=\"property\">id</span>.<span class=\"title function_\">renderButton</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;buttonDiv&#x27;</span>),<span class=\"comment\">//自定义按钮</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">theme</span>: <span class=\"string\">&#x27;outline&#x27;</span>, <span class=\"attr\">size</span>: <span class=\"string\">&#x27;large&#x27;</span>, <span class=\"attr\">logo_alignment</span>: <span class=\"string\">&#x27;center&#x27;</span>&#125; <span class=\"comment\">// customization attributes</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>4.登录<br>登录回调拿到响应数据中的credential进行解析可以获取到账户更多信息<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">google_load</span> = (<span class=\"params\">response</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> responsePayload = <span class=\"title function_\">decode_jwt</span>(response.<span class=\"property\">credential</span>);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responsePayload)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//解析token</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">decode_jwt</span> = (<span class=\"params\">token</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base64Url = token.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base64 = base64Url.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/-/g</span>, <span class=\"string\">&#x27;+&#x27;</span>).<span class=\"title function_\">replace</span>(<span class=\"regexp\">/_/g</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonPayload = <span class=\"built_in\">decodeURIComponent</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">window</span></span><br><span class=\"line\">            .<span class=\"title function_\">atob</span>(base64)</span><br><span class=\"line\">            .<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            .<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span> (<span class=\"params\">c</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%&#x27;</span> + (<span class=\"string\">&#x27;00&#x27;</span> + c.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>)).<span class=\"title function_\">slice</span>(-<span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(jsonPayload);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title function_\">google_init</span>(google_load)</span><br></pre></td></tr></table></figure>\n<h1 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h1></li>\n<li>1.需兼容sdk加载失败情况（翻墙网络不稳定等）</li>\n<li>2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名<br>#相关文档</li>\n<li>开发文档：<a href=\"https://developers.google.com/identity/gsi/web\">https://developers.google.com/identity/gsi/web</a> </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注册流程\"><a href=\"#注册流程\" class=\"headerlink\" title=\"注册流程\"></a>注册流程</h1><ul>\n<li>1.登录谷歌<a href=\"https://console.cloud.google.com/home/recommendations\">开发者平台</a>，点击左上角打开选择项目弹窗选择项目，若没有项目则新建项目<br><img src=\"https://img-blog.csdnimg.cn/9c8141a6d75c40cc83b76d6d9203be2f.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<ul>\n<li><p>2.创建完项目后，若是新账号需要先填写OAuth consent screen相关信息<br><img src=\"https://img-blog.csdnimg.cn/99ccb7262c26431c99766baea62fa70e.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>3.创建凭证<br>创建凭证 Credentials —&gt; Create OAuth client ID —&gt; Web application<br>然后填写h5应用的相关信息和谷歌登录授权的白名单域名和授权的页面路由。创建成功后会拿到谷歌给的Client ID。<br><img src=\"https://img-blog.csdnimg.cn/2c601f745abc4b99afa99142835d5928.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h1 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h1><ul>\n<li>1.引入sdk<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://accounts.google.com/gsi/client&quot;</span> <span class=\"attr\">async</span> <span class=\"attr\">defer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>2.自定义按钮<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;buttonDiv&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>3.初始化<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">fn :function 登录回调函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">google_init</span>=(<span class=\"params\">fn</span>)=&gt;&#123;</span><br><span class=\"line\"> google.<span class=\"property\">accounts</span>.<span class=\"property\">id</span>.<span class=\"title function_\">initialize</span>(&#123;</span><br><span class=\"line\">        <span class=\"attr\">client_id</span>: <span class=\"variable constant_\">GOOGLE_ID</span>,<span class=\"comment\">//客户端ID(创建应用第三步中获得的id)</span></span><br><span class=\"line\">        <span class=\"attr\">callback</span>: fn</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    google.<span class=\"property\">accounts</span>.<span class=\"property\">id</span>.<span class=\"title function_\">renderButton</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;buttonDiv&#x27;</span>),<span class=\"comment\">//自定义按钮</span></span><br><span class=\"line\">        &#123;<span class=\"attr\">theme</span>: <span class=\"string\">&#x27;outline&#x27;</span>, <span class=\"attr\">size</span>: <span class=\"string\">&#x27;large&#x27;</span>, <span class=\"attr\">logo_alignment</span>: <span class=\"string\">&#x27;center&#x27;</span>&#125; <span class=\"comment\">// customization attributes</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>4.登录<br>登录回调拿到响应数据中的credential进行解析可以获取到账户更多信息<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">google_load</span> = (<span class=\"params\">response</span>) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> responsePayload = <span class=\"title function_\">decode_jwt</span>(response.<span class=\"property\">credential</span>);</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(responsePayload)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//解析token</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">decode_jwt</span> = (<span class=\"params\">token</span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base64Url = token.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;.&#x27;</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> base64 = base64Url.<span class=\"title function_\">replace</span>(<span class=\"regexp\">/-/g</span>, <span class=\"string\">&#x27;+&#x27;</span>).<span class=\"title function_\">replace</span>(<span class=\"regexp\">/_/g</span>, <span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonPayload = <span class=\"built_in\">decodeURIComponent</span>(</span><br><span class=\"line\">        <span class=\"variable language_\">window</span></span><br><span class=\"line\">            .<span class=\"title function_\">atob</span>(base64)</span><br><span class=\"line\">            .<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">            .<span class=\"title function_\">map</span>(<span class=\"keyword\">function</span> (<span class=\"params\">c</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%&#x27;</span> + (<span class=\"string\">&#x27;00&#x27;</span> + c.<span class=\"title function_\">charCodeAt</span>(<span class=\"number\">0</span>).<span class=\"title function_\">toString</span>(<span class=\"number\">16</span>)).<span class=\"title function_\">slice</span>(-<span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(jsonPayload);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title function_\">google_init</span>(google_load)</span><br></pre></td></tr></table></figure>\n<h1 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h1></li>\n<li>1.需兼容sdk加载失败情况（翻墙网络不稳定等）</li>\n<li>2.sdk加载的方案添加或更换域名需手动在开发者平台增加域名<br>#相关文档</li>\n<li>开发文档：<a href=\"https://developers.google.com/identity/gsi/web\">https://developers.google.com/identity/gsi/web</a> </li>\n</ul>\n"},{"title":"https的安全性与执行机制","date":"2023-02-01T03:52:13.000Z","description":"https是如何保障数据传输的安全性......","_content":"# HTTP的安全性问题\n我们都知道前后端的通信是通过http协议去进行的，但是http的安全性却得不到保障。比如\n - **前后端通信过程使用明文，内容可能会被窃听**\n - **不验证对方身份，无法保证信息能准确发送给目标**\n - **通信内容可能被篡改**\n针对这些问题可由以下方法应对\n## 1.通过加密防止被窃听\n#### (1)通信加密\nHTTP中没有加密机制，但可以通过SSL(安全套接层)或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。\n通过使用SSL建立安全通信线路之后，就可以通过这条安全通道进行HTTP通信了，这种HTTP与SSL的组合使用就是HTTPS，所以**HTTPS不是一种新的协议，它使用的协议依然是HTTP**。\n#### (2)内容加密\n另一种防止被窃听的方法是对通信内容进行加密，客户端需要先对需要发送的内容进行加密后再发送，那么服务端想要拿到正确的通信内容的话那么服务端跟客户端**都需要具备一样的加密解密机制**。\n## 2.验证通信对方身份\n在HTTP中，只要服务端收到请求，都会返回一个响应，因此无法确认通信的对方的话会存在以下隐患。\n - 客户端无法确定请求是否正确的发送到服务器\n - 服务器无法确定响应是否正确返回到正确的客户端\n - 对于一些毫无意义的请求也会接收，存在安全性问题，如DOS攻击\n HTTP无法确定通信对方，但是使用SSL的话则可以做到这一点，SSL不仅提供加密处理，还提供了一种称为证书的东西，可用于确定对方。\n 证书是由第三方发布的，可用于证明客户端，服务器是真实存在的，所以可以通过证书确认通信的对方是我们信息发送的目标。\n## 3.防止通信内容被第三方篡改\nHTTP无法确认发出的请求/响应和收到的请求/响应前后是相同的。攻击者能够篡改请求和响应，让通信双方看上去通信过程仍是正常的。\n# 加密+认证+信息完整性 = HTTPS\n通常HTTP是直接与TCP通信，使用了SSL时则变成先与SSL通信，再由SSL与TCP通信。采用了这层SSL，HTTP就有了加密，证书，保证信息完整性等功能\n### 1.HTTPS是如何交换密钥的\n加密和解密都需要用到密钥，没密钥就无法加密解密，反过来任何人持有密钥都能加密解密，如果密钥被攻击者拿到了，那它就失去了意义。那么客户端怎么告诉服务端用什么密钥去解密，又避免被攻击者获取到就成了主要问题。\n#### 共享密钥加密\n共享密钥加密是指**加密和解密都是用一个密钥**进行处理，这种方式又叫做对称加密。用这种方法加密的好处是**效率比较高**，无需多余的处理。但它却有着通信过程中，**存在密钥被攻击者获取的风险**。\n#### 公开密钥加密\n公开密钥加密使用一对非对称的密钥，一把私有密钥，一把公开密钥。\n私有密钥不能让其他人知道，公开密钥所有人都能知道。\n使用这种方式加密，发送密文的一方**用对方的公开密钥进行加密，对方收到被加密的信息后，再用自己私有的密钥进行解密**。通过这种方式，不需要发送用来解密的私有密钥，也不用担心密钥被攻击者获取。但它也存在一个缺点就是处理速度比较慢。\n#### HTTPS采用混合加密机制\nHTTPS为了提高效率，并且保证安全性将以上两种加密方法混合起来使用。先通过公开加密的方式获取到共享密钥加密所需要密钥之后，使用共享密钥加密的方式处理后续通信。\n1. 客户端向服务端发送报文开始SSL通信。报文包括客户端支持的SSL版本，加密组件列表。\n2. 服务端可进行SSL通信时，会返回一段报文。包含指定SSL版本与加密组件。这个加密组件是从客户端发送过来的加密组件列表中筛选出来的\n3. 之后服务端再发送一段报文，包含公开密钥证书，确保客户端能够识别其正确性\n4. 最后服务端再发送一段报文通知客户端SSL通信结束\n5. 第一次SSL通信结束后，客户端以Client Key Exchange报文作为回应。包含通信加密中使用的一种Pre-master secret的随机密码串。改密码串是已经用步骤2跟3得到的公开密钥进行加密过的。\n6. 接着客户端再发送Change Cipher Spec报文。告诉服务端后续通信会用Pre-master secret作为密钥进行加密\n7. 客户端发送Finished报文，包含连接至今全部的整体校验值。这次协商能否成功取决于服务器能否正确解密该报文\n8. 服务器像客户端一样发送Change Cipher Spec报文\n9. 服务器像客户端一样发送Finished报文\n10. 服务器客户端Finished报文交换完毕后，SSL就算建立成功。后续通信即使用HTTP即可\n11. 应用层协议通信，即HTTP\n\n**至此就是一个HTTPS的工作流程。**\n ","source":"_posts/https的安全性与执行机制.md","raw":"---\ntitle: https的安全性与执行机制\ndate: 2023-02-01 11:52:13\ntags: 计算机网络\ndescription: https是如何保障数据传输的安全性......\n---\n# HTTP的安全性问题\n我们都知道前后端的通信是通过http协议去进行的，但是http的安全性却得不到保障。比如\n - **前后端通信过程使用明文，内容可能会被窃听**\n - **不验证对方身份，无法保证信息能准确发送给目标**\n - **通信内容可能被篡改**\n针对这些问题可由以下方法应对\n## 1.通过加密防止被窃听\n#### (1)通信加密\nHTTP中没有加密机制，但可以通过SSL(安全套接层)或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。\n通过使用SSL建立安全通信线路之后，就可以通过这条安全通道进行HTTP通信了，这种HTTP与SSL的组合使用就是HTTPS，所以**HTTPS不是一种新的协议，它使用的协议依然是HTTP**。\n#### (2)内容加密\n另一种防止被窃听的方法是对通信内容进行加密，客户端需要先对需要发送的内容进行加密后再发送，那么服务端想要拿到正确的通信内容的话那么服务端跟客户端**都需要具备一样的加密解密机制**。\n## 2.验证通信对方身份\n在HTTP中，只要服务端收到请求，都会返回一个响应，因此无法确认通信的对方的话会存在以下隐患。\n - 客户端无法确定请求是否正确的发送到服务器\n - 服务器无法确定响应是否正确返回到正确的客户端\n - 对于一些毫无意义的请求也会接收，存在安全性问题，如DOS攻击\n HTTP无法确定通信对方，但是使用SSL的话则可以做到这一点，SSL不仅提供加密处理，还提供了一种称为证书的东西，可用于确定对方。\n 证书是由第三方发布的，可用于证明客户端，服务器是真实存在的，所以可以通过证书确认通信的对方是我们信息发送的目标。\n## 3.防止通信内容被第三方篡改\nHTTP无法确认发出的请求/响应和收到的请求/响应前后是相同的。攻击者能够篡改请求和响应，让通信双方看上去通信过程仍是正常的。\n# 加密+认证+信息完整性 = HTTPS\n通常HTTP是直接与TCP通信，使用了SSL时则变成先与SSL通信，再由SSL与TCP通信。采用了这层SSL，HTTP就有了加密，证书，保证信息完整性等功能\n### 1.HTTPS是如何交换密钥的\n加密和解密都需要用到密钥，没密钥就无法加密解密，反过来任何人持有密钥都能加密解密，如果密钥被攻击者拿到了，那它就失去了意义。那么客户端怎么告诉服务端用什么密钥去解密，又避免被攻击者获取到就成了主要问题。\n#### 共享密钥加密\n共享密钥加密是指**加密和解密都是用一个密钥**进行处理，这种方式又叫做对称加密。用这种方法加密的好处是**效率比较高**，无需多余的处理。但它却有着通信过程中，**存在密钥被攻击者获取的风险**。\n#### 公开密钥加密\n公开密钥加密使用一对非对称的密钥，一把私有密钥，一把公开密钥。\n私有密钥不能让其他人知道，公开密钥所有人都能知道。\n使用这种方式加密，发送密文的一方**用对方的公开密钥进行加密，对方收到被加密的信息后，再用自己私有的密钥进行解密**。通过这种方式，不需要发送用来解密的私有密钥，也不用担心密钥被攻击者获取。但它也存在一个缺点就是处理速度比较慢。\n#### HTTPS采用混合加密机制\nHTTPS为了提高效率，并且保证安全性将以上两种加密方法混合起来使用。先通过公开加密的方式获取到共享密钥加密所需要密钥之后，使用共享密钥加密的方式处理后续通信。\n1. 客户端向服务端发送报文开始SSL通信。报文包括客户端支持的SSL版本，加密组件列表。\n2. 服务端可进行SSL通信时，会返回一段报文。包含指定SSL版本与加密组件。这个加密组件是从客户端发送过来的加密组件列表中筛选出来的\n3. 之后服务端再发送一段报文，包含公开密钥证书，确保客户端能够识别其正确性\n4. 最后服务端再发送一段报文通知客户端SSL通信结束\n5. 第一次SSL通信结束后，客户端以Client Key Exchange报文作为回应。包含通信加密中使用的一种Pre-master secret的随机密码串。改密码串是已经用步骤2跟3得到的公开密钥进行加密过的。\n6. 接着客户端再发送Change Cipher Spec报文。告诉服务端后续通信会用Pre-master secret作为密钥进行加密\n7. 客户端发送Finished报文，包含连接至今全部的整体校验值。这次协商能否成功取决于服务器能否正确解密该报文\n8. 服务器像客户端一样发送Change Cipher Spec报文\n9. 服务器像客户端一样发送Finished报文\n10. 服务器客户端Finished报文交换完毕后，SSL就算建立成功。后续通信即使用HTTP即可\n11. 应用层协议通信，即HTTP\n\n**至此就是一个HTTPS的工作流程。**\n ","slug":"https的安全性与执行机制","published":1,"updated":"2023-02-01T03:53:06.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh20004ywnkffnj7j6u","content":"<h1 id=\"HTTP的安全性问题\"><a href=\"#HTTP的安全性问题\" class=\"headerlink\" title=\"HTTP的安全性问题\"></a>HTTP的安全性问题</h1><p>我们都知道前后端的通信是通过http协议去进行的，但是http的安全性却得不到保障。比如</p>\n<ul>\n<li><strong>前后端通信过程使用明文，内容可能会被窃听</strong></li>\n<li><strong>不验证对方身份，无法保证信息能准确发送给目标</strong></li>\n<li><strong>通信内容可能被篡改</strong><br>针对这些问题可由以下方法应对<h2 id=\"1-通过加密防止被窃听\"><a href=\"#1-通过加密防止被窃听\" class=\"headerlink\" title=\"1.通过加密防止被窃听\"></a>1.通过加密防止被窃听</h2><h4 id=\"1-通信加密\"><a href=\"#1-通信加密\" class=\"headerlink\" title=\"(1)通信加密\"></a>(1)通信加密</h4>HTTP中没有加密机制，但可以通过SSL(安全套接层)或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。<br>通过使用SSL建立安全通信线路之后，就可以通过这条安全通道进行HTTP通信了，这种HTTP与SSL的组合使用就是HTTPS，所以<strong>HTTPS不是一种新的协议，它使用的协议依然是HTTP</strong>。<h4 id=\"2-内容加密\"><a href=\"#2-内容加密\" class=\"headerlink\" title=\"(2)内容加密\"></a>(2)内容加密</h4>另一种防止被窃听的方法是对通信内容进行加密，客户端需要先对需要发送的内容进行加密后再发送，那么服务端想要拿到正确的通信内容的话那么服务端跟客户端<strong>都需要具备一样的加密解密机制</strong>。<h2 id=\"2-验证通信对方身份\"><a href=\"#2-验证通信对方身份\" class=\"headerlink\" title=\"2.验证通信对方身份\"></a>2.验证通信对方身份</h2>在HTTP中，只要服务端收到请求，都会返回一个响应，因此无法确认通信的对方的话会存在以下隐患。</li>\n<li>客户端无法确定请求是否正确的发送到服务器</li>\n<li>服务器无法确定响应是否正确返回到正确的客户端</li>\n<li>对于一些毫无意义的请求也会接收，存在安全性问题，如DOS攻击<br>HTTP无法确定通信对方，但是使用SSL的话则可以做到这一点，SSL不仅提供加密处理，还提供了一种称为证书的东西，可用于确定对方。<br>证书是由第三方发布的，可用于证明客户端，服务器是真实存在的，所以可以通过证书确认通信的对方是我们信息发送的目标。<h2 id=\"3-防止通信内容被第三方篡改\"><a href=\"#3-防止通信内容被第三方篡改\" class=\"headerlink\" title=\"3.防止通信内容被第三方篡改\"></a>3.防止通信内容被第三方篡改</h2>HTTP无法确认发出的请求/响应和收到的请求/响应前后是相同的。攻击者能够篡改请求和响应，让通信双方看上去通信过程仍是正常的。<h1 id=\"加密-认证-信息完整性-HTTPS\"><a href=\"#加密-认证-信息完整性-HTTPS\" class=\"headerlink\" title=\"加密+认证+信息完整性 = HTTPS\"></a>加密+认证+信息完整性 = HTTPS</h1>通常HTTP是直接与TCP通信，使用了SSL时则变成先与SSL通信，再由SSL与TCP通信。采用了这层SSL，HTTP就有了加密，证书，保证信息完整性等功能<h3 id=\"1-HTTPS是如何交换密钥的\"><a href=\"#1-HTTPS是如何交换密钥的\" class=\"headerlink\" title=\"1.HTTPS是如何交换密钥的\"></a>1.HTTPS是如何交换密钥的</h3>加密和解密都需要用到密钥，没密钥就无法加密解密，反过来任何人持有密钥都能加密解密，如果密钥被攻击者拿到了，那它就失去了意义。那么客户端怎么告诉服务端用什么密钥去解密，又避免被攻击者获取到就成了主要问题。<h4 id=\"共享密钥加密\"><a href=\"#共享密钥加密\" class=\"headerlink\" title=\"共享密钥加密\"></a>共享密钥加密</h4>共享密钥加密是指<strong>加密和解密都是用一个密钥</strong>进行处理，这种方式又叫做对称加密。用这种方法加密的好处是<strong>效率比较高</strong>，无需多余的处理。但它却有着通信过程中，<strong>存在密钥被攻击者获取的风险</strong>。<h4 id=\"公开密钥加密\"><a href=\"#公开密钥加密\" class=\"headerlink\" title=\"公开密钥加密\"></a>公开密钥加密</h4>公开密钥加密使用一对非对称的密钥，一把私有密钥，一把公开密钥。<br>私有密钥不能让其他人知道，公开密钥所有人都能知道。<br>使用这种方式加密，发送密文的一方<strong>用对方的公开密钥进行加密，对方收到被加密的信息后，再用自己私有的密钥进行解密</strong>。通过这种方式，不需要发送用来解密的私有密钥，也不用担心密钥被攻击者获取。但它也存在一个缺点就是处理速度比较慢。<h4 id=\"HTTPS采用混合加密机制\"><a href=\"#HTTPS采用混合加密机制\" class=\"headerlink\" title=\"HTTPS采用混合加密机制\"></a>HTTPS采用混合加密机制</h4>HTTPS为了提高效率，并且保证安全性将以上两种加密方法混合起来使用。先通过公开加密的方式获取到共享密钥加密所需要密钥之后，使用共享密钥加密的方式处理后续通信。</li>\n</ul>\n<ol>\n<li>客户端向服务端发送报文开始SSL通信。报文包括客户端支持的SSL版本，加密组件列表。</li>\n<li>服务端可进行SSL通信时，会返回一段报文。包含指定SSL版本与加密组件。这个加密组件是从客户端发送过来的加密组件列表中筛选出来的</li>\n<li>之后服务端再发送一段报文，包含公开密钥证书，确保客户端能够识别其正确性</li>\n<li>最后服务端再发送一段报文通知客户端SSL通信结束</li>\n<li>第一次SSL通信结束后，客户端以Client Key Exchange报文作为回应。包含通信加密中使用的一种Pre-master secret的随机密码串。改密码串是已经用步骤2跟3得到的公开密钥进行加密过的。</li>\n<li>接着客户端再发送Change Cipher Spec报文。告诉服务端后续通信会用Pre-master secret作为密钥进行加密</li>\n<li>客户端发送Finished报文，包含连接至今全部的整体校验值。这次协商能否成功取决于服务器能否正确解密该报文</li>\n<li>服务器像客户端一样发送Change Cipher Spec报文</li>\n<li>服务器像客户端一样发送Finished报文</li>\n<li>服务器客户端Finished报文交换完毕后，SSL就算建立成功。后续通信即使用HTTP即可</li>\n<li>应用层协议通信，即HTTP</li>\n</ol>\n<p><strong>至此就是一个HTTPS的工作流程。</strong>\n </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HTTP的安全性问题\"><a href=\"#HTTP的安全性问题\" class=\"headerlink\" title=\"HTTP的安全性问题\"></a>HTTP的安全性问题</h1><p>我们都知道前后端的通信是通过http协议去进行的，但是http的安全性却得不到保障。比如</p>\n<ul>\n<li><strong>前后端通信过程使用明文，内容可能会被窃听</strong></li>\n<li><strong>不验证对方身份，无法保证信息能准确发送给目标</strong></li>\n<li><strong>通信内容可能被篡改</strong><br>针对这些问题可由以下方法应对<h2 id=\"1-通过加密防止被窃听\"><a href=\"#1-通过加密防止被窃听\" class=\"headerlink\" title=\"1.通过加密防止被窃听\"></a>1.通过加密防止被窃听</h2><h4 id=\"1-通信加密\"><a href=\"#1-通信加密\" class=\"headerlink\" title=\"(1)通信加密\"></a>(1)通信加密</h4>HTTP中没有加密机制，但可以通过SSL(安全套接层)或TLS(安全传输层协议)的组合使用，加密HTTP的通信内容。<br>通过使用SSL建立安全通信线路之后，就可以通过这条安全通道进行HTTP通信了，这种HTTP与SSL的组合使用就是HTTPS，所以<strong>HTTPS不是一种新的协议，它使用的协议依然是HTTP</strong>。<h4 id=\"2-内容加密\"><a href=\"#2-内容加密\" class=\"headerlink\" title=\"(2)内容加密\"></a>(2)内容加密</h4>另一种防止被窃听的方法是对通信内容进行加密，客户端需要先对需要发送的内容进行加密后再发送，那么服务端想要拿到正确的通信内容的话那么服务端跟客户端<strong>都需要具备一样的加密解密机制</strong>。<h2 id=\"2-验证通信对方身份\"><a href=\"#2-验证通信对方身份\" class=\"headerlink\" title=\"2.验证通信对方身份\"></a>2.验证通信对方身份</h2>在HTTP中，只要服务端收到请求，都会返回一个响应，因此无法确认通信的对方的话会存在以下隐患。</li>\n<li>客户端无法确定请求是否正确的发送到服务器</li>\n<li>服务器无法确定响应是否正确返回到正确的客户端</li>\n<li>对于一些毫无意义的请求也会接收，存在安全性问题，如DOS攻击<br>HTTP无法确定通信对方，但是使用SSL的话则可以做到这一点，SSL不仅提供加密处理，还提供了一种称为证书的东西，可用于确定对方。<br>证书是由第三方发布的，可用于证明客户端，服务器是真实存在的，所以可以通过证书确认通信的对方是我们信息发送的目标。<h2 id=\"3-防止通信内容被第三方篡改\"><a href=\"#3-防止通信内容被第三方篡改\" class=\"headerlink\" title=\"3.防止通信内容被第三方篡改\"></a>3.防止通信内容被第三方篡改</h2>HTTP无法确认发出的请求/响应和收到的请求/响应前后是相同的。攻击者能够篡改请求和响应，让通信双方看上去通信过程仍是正常的。<h1 id=\"加密-认证-信息完整性-HTTPS\"><a href=\"#加密-认证-信息完整性-HTTPS\" class=\"headerlink\" title=\"加密+认证+信息完整性 = HTTPS\"></a>加密+认证+信息完整性 = HTTPS</h1>通常HTTP是直接与TCP通信，使用了SSL时则变成先与SSL通信，再由SSL与TCP通信。采用了这层SSL，HTTP就有了加密，证书，保证信息完整性等功能<h3 id=\"1-HTTPS是如何交换密钥的\"><a href=\"#1-HTTPS是如何交换密钥的\" class=\"headerlink\" title=\"1.HTTPS是如何交换密钥的\"></a>1.HTTPS是如何交换密钥的</h3>加密和解密都需要用到密钥，没密钥就无法加密解密，反过来任何人持有密钥都能加密解密，如果密钥被攻击者拿到了，那它就失去了意义。那么客户端怎么告诉服务端用什么密钥去解密，又避免被攻击者获取到就成了主要问题。<h4 id=\"共享密钥加密\"><a href=\"#共享密钥加密\" class=\"headerlink\" title=\"共享密钥加密\"></a>共享密钥加密</h4>共享密钥加密是指<strong>加密和解密都是用一个密钥</strong>进行处理，这种方式又叫做对称加密。用这种方法加密的好处是<strong>效率比较高</strong>，无需多余的处理。但它却有着通信过程中，<strong>存在密钥被攻击者获取的风险</strong>。<h4 id=\"公开密钥加密\"><a href=\"#公开密钥加密\" class=\"headerlink\" title=\"公开密钥加密\"></a>公开密钥加密</h4>公开密钥加密使用一对非对称的密钥，一把私有密钥，一把公开密钥。<br>私有密钥不能让其他人知道，公开密钥所有人都能知道。<br>使用这种方式加密，发送密文的一方<strong>用对方的公开密钥进行加密，对方收到被加密的信息后，再用自己私有的密钥进行解密</strong>。通过这种方式，不需要发送用来解密的私有密钥，也不用担心密钥被攻击者获取。但它也存在一个缺点就是处理速度比较慢。<h4 id=\"HTTPS采用混合加密机制\"><a href=\"#HTTPS采用混合加密机制\" class=\"headerlink\" title=\"HTTPS采用混合加密机制\"></a>HTTPS采用混合加密机制</h4>HTTPS为了提高效率，并且保证安全性将以上两种加密方法混合起来使用。先通过公开加密的方式获取到共享密钥加密所需要密钥之后，使用共享密钥加密的方式处理后续通信。</li>\n</ul>\n<ol>\n<li>客户端向服务端发送报文开始SSL通信。报文包括客户端支持的SSL版本，加密组件列表。</li>\n<li>服务端可进行SSL通信时，会返回一段报文。包含指定SSL版本与加密组件。这个加密组件是从客户端发送过来的加密组件列表中筛选出来的</li>\n<li>之后服务端再发送一段报文，包含公开密钥证书，确保客户端能够识别其正确性</li>\n<li>最后服务端再发送一段报文通知客户端SSL通信结束</li>\n<li>第一次SSL通信结束后，客户端以Client Key Exchange报文作为回应。包含通信加密中使用的一种Pre-master secret的随机密码串。改密码串是已经用步骤2跟3得到的公开密钥进行加密过的。</li>\n<li>接着客户端再发送Change Cipher Spec报文。告诉服务端后续通信会用Pre-master secret作为密钥进行加密</li>\n<li>客户端发送Finished报文，包含连接至今全部的整体校验值。这次协商能否成功取决于服务器能否正确解密该报文</li>\n<li>服务器像客户端一样发送Change Cipher Spec报文</li>\n<li>服务器像客户端一样发送Finished报文</li>\n<li>服务器客户端Finished报文交换完毕后，SSL就算建立成功。后续通信即使用HTTP即可</li>\n<li>应用层协议通信，即HTTP</li>\n</ol>\n<p><strong>至此就是一个HTTPS的工作流程。</strong>\n </p>\n"},{"title":"vue3响应系统的作用与实现","date":"2023-02-01T06:10:39.000Z","description":"响应式是vue的一个重要组成部分，它实现了数据与视图的绑定......","_content":"\n响应式是vue的一个重要组成部分，它实现了数据与视图的绑定。接下我们就从相应数据跟副作用函数开始一步步了解vue的响应系统的设计与实现\n## 副作用函数\n副作用函数是指会产生副作用的函数\n````\nfunction effect(){\n     document.body.innerText = \"hellow\";\n}\n````\n当effect执行时，会改变body的内容，但除了effect，其他函数也可以访问到body的文本内容，所以effect函数会影响到其他函数读取body的内容，即说effect是一个副作用函数。\n````\nlet a = 1\nfunction effect(){\n    var a = 2\n}\n````\n副作用函数非常常见，像这种effect改变了其他函数也可以访问到的全局变量，影响了其他函数对它的读取，这也是一种副作用函数。可以理解为**某个函数改变了其他函数对某个内容的访问结果，即这个函数是副作用函数**\n\n## 响应式数据\n````\nconst obj = {text:'hellow'}\nfunction effect (){\n     document.body.innerText = obj.text;\n}\n````\n当effect函数执行时，会改变body的文本内容。如果obj的值变化的时候都能触发effect，从而改变body的文本内容达到改变视图的效果，那我们则称obj是一个响应数据。\n改变obj的时候，我们会触发到它的**set**操作，而读取的时候会触发到**get**操作。\n\n如果我们可以拦截这两步操作，在读取obj.text的时候把副作用函数effect存储到一个桶里，在修改obj.text的时候再把这个副作用函数拿出来执行，便可以达到每当修改obj.text的时候都能改变视图的效果了。\n\n在vue2中，vue采用了[Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)实现了响应系统，但**Object.defineProperty只能监听指定key的value的变化，所以需要遍历整个对象从而监听所有key**。vue3使用了[Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)代替了defineProperty解决了这一痛点。\n这里我们用proxy来实现\n````\n  //用于存储副作用函数的桶\n  const bucket = new Set();\n  //原始数据\n  const data = { text: \"hellow\" };\n  //对原始数据的代理\n  const obj = new Proxy(data, {\n    get(target, key) {\n      //将副作用函数丢进bucket\n      if (effect) {\n        bucket.add(effect);\n      }\n      //返回读取的值\n      return target[key];\n    },\n    set(target, key, newVal) {\n      //设置新属性值\n      target[key] = newVal;\n      //把副作用函数从桶取出并执行\n      bucket.forEach((fn) => fn());\n      //设置成功\n      return true;\n    },\n  });\n````\n这时候执行effect之后，再改变obj.text的值的时候，会发数据响应视图，视图改变了。成功实现了一个响应数据。\n## 注册副作用函数 \n在上面代码中，我们使用effect作为副作用函数，但实际中副作用函数不一定这么命名，甚至可能是一个匿名函数，所以我们需要一个注册副作用函数的流程\n````\n  //用一个全局变量存储被注册的副作用函数\n  let activeEffect;\n  //用于注册副作用函数\n  function effect(fn) {\n    activeEffect = fn;\n    fn();\n  }\n  \n  const obj = new Proxy(data, {\n    get(target, key) {\n      //将副作用函数丢进bucket\n      if (activeEffect) {\n        bucket.add(activeEffect);\n      }\n      //返回读取的值\n      return target[key];\n    },\n    set(target, key, newVal) {\n      //设置新属性值\n      target[key] = newVal;\n      //把副作用函数从桶取出并执行\n      bucket.forEach((fn) => fn());\n      //设置成功\n      return true;\n    },\n  });\n  \n  effect(() => {\n    document.body.innerText = obj.text;\n  });\n\n  \n````\n 这里我们定义了一个activeEffect，它的作用是用来存储被注册的副作用函数，再将effect修改为一个用来注册副作用函数的工具，这样一来无论副作用函数是什么都可以通过注册副作用函数注册后由activeEffect来表示。\n当执行effect时，会把匿名函数赋值给activeEffect，接着执行传入的fn函数，会触发obj.text的get，从而将副作用函数放到桶中.\n## 完善存放副作用函数的桶的数据结构\n以上步骤一直围绕着obj.text做操作，我们的副作用函数是与之绑定的，**如果我们设置了一个原先不存在的属性的话，由于它与副作用函数是没联系的，所以理论上不应该触发这个副作用函数，但实际上当我们对obj设置一个新属性的时候它触发了这个与它没联系的副作用函数**。\n````\n  effect(() => {\n    console.log('effect')\n    document.body.innerText = obj.text;\n  });\n  \n  obj.a = 1\n````\n触发obj.a = 1的时候可以看到副作用函数被触发了，这是不合理的。导致该问题的原因就是我们没有在副作用函数中明确副作用函数与被操作的字段建立联系。这会导致无论当前读取的是哪个属性，都会把副作用函数丢到桶里，设置的时候也是如此，无论是设置哪个属性都会把桶里的副作用函数拿出来执行。所以对这个桶的结构我们需要重新设计下。先看下执行副作用函数的时候其内部的关系。\n````\nfunction effect(){\n    document.body.innerText = obj.text\n}\n````\n在这段代码中有三个角色\n- 代理对象obj\n- 字段名text\n- 副作用函数effect\n\n把target看成一个代理对象，key是被操作的字段，effectfn是副作用函数，那么它们的关系如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/6444860aedc048829280a5353b78b14a.jpeg)\n\n\n如果是有两个副作用函数作用于一个字段\n````\n  effect(function effect1() {\n    obj.text;\n  });\n\n  effect(function effect2() {\n    obj.text;\n  });\n````\n那么关系如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/2fa829f9a8ac47578f809fa9de9583f2.jpeg)\n\n\n如果一个副作用函数中读取了多个属性\n\n````\neffect(function effect(){\n    obj.text1\n    obj.text2\n})\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/73a73d0dfb584e3e847d8217fc0dc7c6.jpeg)\n\n\n如果在不同副作用函数读取不同属性的话\n````\n  effect(function effect1() {\n    obj.text1;\n  });\n\n  effect(function effect2() {\n    obj.text2;\n  });\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/b1da665fd27f4044b85145d552623a19.jpeg)\n\n\n按这个关系来看，便可以解决了我们先前改变任何属性都会触发副作用函数的问题。例如这里我们读取或者设置了text1，只会触发effect1，而不会导致effect2执行。接着就来实现这个桶。\n\n首先我们使用weakMap代替先前的set作为桶的数据结构。因为需要一个key与effectFn的映射关系。\n这里说一下WeakMap跟Map的区别\n````\n  const map = new Map();\n  const weakmap = new WeakMap();\n  (function () {\n    const foo = { foo: 1 };\n    const bar = { bar: 1 };\n    map.set(foo, 1);\n    weakmap.set(bar, 2);\n  })();\n````\n我们创建了map，weakmap两个实例，在立即执行函数内部定义了foo，bar两个对象并且将这两个对象作为map，weakmap的key。函数执行结束后foo还作为key被map引用，因此它没有被垃圾回收器移除，还可以通过map.keys打印出来。而weakmap是弱引用，它不影响垃圾回收器的运作，所以执行完后bar会被垃圾回收器回收，我们也无法通过weakmap获取到bar。\n所以使用weakmap常用于存储那些只有当key引用对象存在时才有价值的信息，如果使用map的话，绑定的数据不再被引用了，也不会被回收，最终可能会造成**内存泄漏**。\n\n````\n  const bucket = new WeakMap();\n  const obj = new Proxy(data, {\n    get(target, key) {\n      track(target, key);\n      return target[key];\n    },\n    set(target, key, newVal) {\n      target[key] = newVal;\n      trigger(target, key);\n    },\n  });\n\n function track(target, key) {\n    //如果没有副作用函数直接return\n    if (!activeEffect) {\n      return;\n    }\n    //根据target从桶中取出desMap\n    let depsMap = bucket.get(target);\n    //如果desMap不存在那么创建一个Map并与target关联\n    if (!depsMap) {\n      depsMap = new Map();\n      bucket.set(target, depsMap);\n    }\n    //再根据key从desMap中取得deps，它里面存储着所有与当前key关联的副作用函数 effects\n    let deps = depsMap.get(key);\n    //如果deps不存在，同样创建一个Set并与key关联\n    if (!deps) {\n      deps = new Set();\n      depsMap.set(key, deps);\n    }\n    //最后将当前激活的副作用函数添加到桶里\n    deps.add(activeEffect);\n  }\n\n  function trigger(target, key) {\n    //根据target从桶中取出depsMap\n    const depsMap = bucket.get(target);\n    if (!depsMap) {\n      return;\n    }\n    //根据key取得所有副作用函数effects\n    const effects = depsMap.get(key);\n    //执行副作用函数\n    effects && effects.forEach((fn) => fn());\n  }\n````\n\n这段代码可以看出它的桶设计如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/186661b1f6164154801f6386257e0a4e.jpeg)\n\n## 分支切换跟cleanup\n````\n  effect(function effectFn(){\n    document.body.innerText = obj.ok ? obj.text : \"not\";\n  });\n````\n如果我们注册了这么一个副作用函数，当obj.ok为true时，会读取obj.text的值，所以这时候副作用函数会触发ok，text两个属性的读取操作，effectFn会与text,ok建立联系\n![请添加图片描述](https://img-blog.csdnimg.cn/6b41a7de060d4a82ae4d9b260cab39ff.jpeg)\n\n但当ok的值为false的时候，不会去读取obj.text，所以这个时候effectFn不应该被text的set收集，但在我们刚刚实现的响应系统里面，obj.ok变成false之后，effectFn还是在text的set里面。\n![请添加图片描述](https://img-blog.csdnimg.cn/fb7aa0c63e6c49949f5e2014c0abf669.jpeg)\n\n这种遗留的副作用函数会导致没必要的更新，obj.ok为false，无论text再怎么修改界面都是显示not，但text修改的时候却会触发effecnFn，这是多余的。为了解决这个问题，我们尝试副作用每次执行的时候把相关联的副作用函数从集合中删除。然后当副作用函数执行的时候，会重新建立联系，但新的联系中不会再包含遗留的没必要的集合。\n要将一个副作用函数从所有与之有关联的集合中移除，就需要明确哪些集合中有它，因此我们需要重新设计下副作用函数注册器。\n````\n  function effect(fn) {\n    const effectFn = () => {\n        //当effectFn执行时，将其设置为当前激活的副作用函数\n      activeEffect = effectFn;\n      fn();\n    };\n    //activeEffect.deps用来存储所有与该副作用函数有关联的集合\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n然后再在track函数中，将集合push到effectFn.deps\n````\n  function track(target, key) {\n    if (!activeEffect) {\n      return;\n    }\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n      depsMap = new Map();\n      bucket.set(target, depsMap);\n    }\n    let deps = depsMap.get(key);\n    if (!deps) {\n      deps = new Set();\n      depsMap.set(key, deps);\n    }\n    deps.add(activeEffect);\n    //deps就是一个与当前副作用函数关联的集合，把它push到activeEffect.deps中\n    activeEffect.deps.push(deps);\n  }\n\n````\n有了副作用函数的集合对象，我们就可以在触发副作用函数的时候把该副作用函数从集合中移除了。下面通过实现一个cleanup函数来处理。\n````\n  function cleanup(effectFn) {\n    for (let i = 0; i < effectFn.deps.length; i++) {\n      //将effectFn从集合中删除\n      const deps = effectFn.deps[i];\n      deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n  }\n  function effect(fn) {\n    const effectFn = () => {\n      cleanup(effectFn);\n      activeEffect = effectFn;\n      fn();\n    };\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n这个时候运行代码会发现，副作用函数无限循环执行，这是因为trigger中我们遍历effects集合时，会调用cleanup清除，实际就是从effects中将当前正在调用的副作用函数清除，但副作用函数执行会让导致又被重新收集到集合中。\n解决的方法也很简单，构造另一个Set集合遍历它即可。\n````\n  function trigger(target, key) {\n    const depsMap = bucket.get(target);\n    if (!depsMap) {\n      return;\n    }\n    const effects = depsMap.get(key);\n    //new一个新的集合\n    const effectsToRun = new Set(effects);\n    effectsToRun && effectsToRun.forEach((fn) => fn());\n  }\n````\n再执行就没有上面循环的问题了。\n## 嵌套的effect与effect栈\n````\neffect(function effect1(){\n   function effect2(){\n       ...\n   }\n})\n````\n这段代码中effect1嵌套了effect2，effect1，effect1的执行会导致effect2的执行。在vue中这种现象是很常见的，例如组件嵌套。\n````\nconst Bar = ()=>{    \n    render(){}\n}\nconst Foo = ()=>{\n  render(){\n      return <Bar/>\n  }\n}\n````\n此时就发生了嵌套，相当于\n````\neffect(()=>{\n    Foo.render()\n    effect(()=>{\n        Bar.render()\n    })\n})\n````\n我们可以通过以下代码测试我们至今完成的响应系统是不是支持嵌套的\n````\n  let t1,t2\n  effect(() => {\n    console.log(\"eff1\");\n    effect(() => {\n      console.log(\"eff2\");\n      t2 = obj.ok;\n    });\n    t1 = obj.text;\n  });\n````\n这种情况下我们希望修改obj.text的时候会打印eff1，接着再触发内部的副作用函数打印eff2。当实际上打印出来的是eff2。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/afe73fa9f2014467adc764289c146717.jpeg)\n\n可以看到，当前text的集合中没有副作用函数。\n\n这是因为我们通过activeEffect存储当前的副作用函数，**这只能存储一个副作用函数，当发生嵌套副作用函数的时候，后面的副作用函数会把先前的副作用函数覆盖掉。** 导致在注册完副作用函数后，text的集合其实是内部的副作用函数，所以在对其进行修改后，set操作中执行的副作用函数不会对text做get操作，cleanup之后不会重新add副作用函数到集合中，所以它的集合是空的。\n\n为了解决这个问题我们创建一个副作用函数栈effectStack，在副作用函数执行时，把当前的副作用函数压入栈中，并且始终让activeEffect指向顶部的副作用函数。\n````\n  const effectStack = [];\n    function effect(fn) {\n    const effectFn = () => {\n      cleanup(effectFn);\n      activeEffect = effectFn;\n      //在调用副作用函数之前将其压入栈中\n      effectStack.push(effectFn);\n      fn();\n      //当前副作用函数执行完成后，将其弹出栈，并让activeEffect还原到之前的值\n      effectStack.pop();\n      activeEffect = effectStack[effectStack.length - 1];\n    };\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/b90d82c6ca0d4dc18701954f77536322.jpeg)\n\n\n修改obj.text的时候，触发外部副作用函数，将其压入栈底，再执行内部副作用函数压入到栈顶，执行后再将其弹出。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/1c0ea4985e974565a1da31ab1cee4567.jpeg)\n\n\n这样一来，响应式数据的属性就只会收集与其绑定的副作用函数。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/99a539f9ad5c4211a9929f98e913aeab.jpeg)\n","source":"_posts/vue3响应系统的作用与实现.md","raw":"---\ntitle: vue3响应系统的作用与实现\ndate: 2023-02-01 14:10:39\ntags: JavaScript\ndescription: 响应式是vue的一个重要组成部分，它实现了数据与视图的绑定......\n---\n\n响应式是vue的一个重要组成部分，它实现了数据与视图的绑定。接下我们就从相应数据跟副作用函数开始一步步了解vue的响应系统的设计与实现\n## 副作用函数\n副作用函数是指会产生副作用的函数\n````\nfunction effect(){\n     document.body.innerText = \"hellow\";\n}\n````\n当effect执行时，会改变body的内容，但除了effect，其他函数也可以访问到body的文本内容，所以effect函数会影响到其他函数读取body的内容，即说effect是一个副作用函数。\n````\nlet a = 1\nfunction effect(){\n    var a = 2\n}\n````\n副作用函数非常常见，像这种effect改变了其他函数也可以访问到的全局变量，影响了其他函数对它的读取，这也是一种副作用函数。可以理解为**某个函数改变了其他函数对某个内容的访问结果，即这个函数是副作用函数**\n\n## 响应式数据\n````\nconst obj = {text:'hellow'}\nfunction effect (){\n     document.body.innerText = obj.text;\n}\n````\n当effect函数执行时，会改变body的文本内容。如果obj的值变化的时候都能触发effect，从而改变body的文本内容达到改变视图的效果，那我们则称obj是一个响应数据。\n改变obj的时候，我们会触发到它的**set**操作，而读取的时候会触发到**get**操作。\n\n如果我们可以拦截这两步操作，在读取obj.text的时候把副作用函数effect存储到一个桶里，在修改obj.text的时候再把这个副作用函数拿出来执行，便可以达到每当修改obj.text的时候都能改变视图的效果了。\n\n在vue2中，vue采用了[Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)实现了响应系统，但**Object.defineProperty只能监听指定key的value的变化，所以需要遍历整个对象从而监听所有key**。vue3使用了[Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)代替了defineProperty解决了这一痛点。\n这里我们用proxy来实现\n````\n  //用于存储副作用函数的桶\n  const bucket = new Set();\n  //原始数据\n  const data = { text: \"hellow\" };\n  //对原始数据的代理\n  const obj = new Proxy(data, {\n    get(target, key) {\n      //将副作用函数丢进bucket\n      if (effect) {\n        bucket.add(effect);\n      }\n      //返回读取的值\n      return target[key];\n    },\n    set(target, key, newVal) {\n      //设置新属性值\n      target[key] = newVal;\n      //把副作用函数从桶取出并执行\n      bucket.forEach((fn) => fn());\n      //设置成功\n      return true;\n    },\n  });\n````\n这时候执行effect之后，再改变obj.text的值的时候，会发数据响应视图，视图改变了。成功实现了一个响应数据。\n## 注册副作用函数 \n在上面代码中，我们使用effect作为副作用函数，但实际中副作用函数不一定这么命名，甚至可能是一个匿名函数，所以我们需要一个注册副作用函数的流程\n````\n  //用一个全局变量存储被注册的副作用函数\n  let activeEffect;\n  //用于注册副作用函数\n  function effect(fn) {\n    activeEffect = fn;\n    fn();\n  }\n  \n  const obj = new Proxy(data, {\n    get(target, key) {\n      //将副作用函数丢进bucket\n      if (activeEffect) {\n        bucket.add(activeEffect);\n      }\n      //返回读取的值\n      return target[key];\n    },\n    set(target, key, newVal) {\n      //设置新属性值\n      target[key] = newVal;\n      //把副作用函数从桶取出并执行\n      bucket.forEach((fn) => fn());\n      //设置成功\n      return true;\n    },\n  });\n  \n  effect(() => {\n    document.body.innerText = obj.text;\n  });\n\n  \n````\n 这里我们定义了一个activeEffect，它的作用是用来存储被注册的副作用函数，再将effect修改为一个用来注册副作用函数的工具，这样一来无论副作用函数是什么都可以通过注册副作用函数注册后由activeEffect来表示。\n当执行effect时，会把匿名函数赋值给activeEffect，接着执行传入的fn函数，会触发obj.text的get，从而将副作用函数放到桶中.\n## 完善存放副作用函数的桶的数据结构\n以上步骤一直围绕着obj.text做操作，我们的副作用函数是与之绑定的，**如果我们设置了一个原先不存在的属性的话，由于它与副作用函数是没联系的，所以理论上不应该触发这个副作用函数，但实际上当我们对obj设置一个新属性的时候它触发了这个与它没联系的副作用函数**。\n````\n  effect(() => {\n    console.log('effect')\n    document.body.innerText = obj.text;\n  });\n  \n  obj.a = 1\n````\n触发obj.a = 1的时候可以看到副作用函数被触发了，这是不合理的。导致该问题的原因就是我们没有在副作用函数中明确副作用函数与被操作的字段建立联系。这会导致无论当前读取的是哪个属性，都会把副作用函数丢到桶里，设置的时候也是如此，无论是设置哪个属性都会把桶里的副作用函数拿出来执行。所以对这个桶的结构我们需要重新设计下。先看下执行副作用函数的时候其内部的关系。\n````\nfunction effect(){\n    document.body.innerText = obj.text\n}\n````\n在这段代码中有三个角色\n- 代理对象obj\n- 字段名text\n- 副作用函数effect\n\n把target看成一个代理对象，key是被操作的字段，effectfn是副作用函数，那么它们的关系如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/6444860aedc048829280a5353b78b14a.jpeg)\n\n\n如果是有两个副作用函数作用于一个字段\n````\n  effect(function effect1() {\n    obj.text;\n  });\n\n  effect(function effect2() {\n    obj.text;\n  });\n````\n那么关系如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/2fa829f9a8ac47578f809fa9de9583f2.jpeg)\n\n\n如果一个副作用函数中读取了多个属性\n\n````\neffect(function effect(){\n    obj.text1\n    obj.text2\n})\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/73a73d0dfb584e3e847d8217fc0dc7c6.jpeg)\n\n\n如果在不同副作用函数读取不同属性的话\n````\n  effect(function effect1() {\n    obj.text1;\n  });\n\n  effect(function effect2() {\n    obj.text2;\n  });\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/b1da665fd27f4044b85145d552623a19.jpeg)\n\n\n按这个关系来看，便可以解决了我们先前改变任何属性都会触发副作用函数的问题。例如这里我们读取或者设置了text1，只会触发effect1，而不会导致effect2执行。接着就来实现这个桶。\n\n首先我们使用weakMap代替先前的set作为桶的数据结构。因为需要一个key与effectFn的映射关系。\n这里说一下WeakMap跟Map的区别\n````\n  const map = new Map();\n  const weakmap = new WeakMap();\n  (function () {\n    const foo = { foo: 1 };\n    const bar = { bar: 1 };\n    map.set(foo, 1);\n    weakmap.set(bar, 2);\n  })();\n````\n我们创建了map，weakmap两个实例，在立即执行函数内部定义了foo，bar两个对象并且将这两个对象作为map，weakmap的key。函数执行结束后foo还作为key被map引用，因此它没有被垃圾回收器移除，还可以通过map.keys打印出来。而weakmap是弱引用，它不影响垃圾回收器的运作，所以执行完后bar会被垃圾回收器回收，我们也无法通过weakmap获取到bar。\n所以使用weakmap常用于存储那些只有当key引用对象存在时才有价值的信息，如果使用map的话，绑定的数据不再被引用了，也不会被回收，最终可能会造成**内存泄漏**。\n\n````\n  const bucket = new WeakMap();\n  const obj = new Proxy(data, {\n    get(target, key) {\n      track(target, key);\n      return target[key];\n    },\n    set(target, key, newVal) {\n      target[key] = newVal;\n      trigger(target, key);\n    },\n  });\n\n function track(target, key) {\n    //如果没有副作用函数直接return\n    if (!activeEffect) {\n      return;\n    }\n    //根据target从桶中取出desMap\n    let depsMap = bucket.get(target);\n    //如果desMap不存在那么创建一个Map并与target关联\n    if (!depsMap) {\n      depsMap = new Map();\n      bucket.set(target, depsMap);\n    }\n    //再根据key从desMap中取得deps，它里面存储着所有与当前key关联的副作用函数 effects\n    let deps = depsMap.get(key);\n    //如果deps不存在，同样创建一个Set并与key关联\n    if (!deps) {\n      deps = new Set();\n      depsMap.set(key, deps);\n    }\n    //最后将当前激活的副作用函数添加到桶里\n    deps.add(activeEffect);\n  }\n\n  function trigger(target, key) {\n    //根据target从桶中取出depsMap\n    const depsMap = bucket.get(target);\n    if (!depsMap) {\n      return;\n    }\n    //根据key取得所有副作用函数effects\n    const effects = depsMap.get(key);\n    //执行副作用函数\n    effects && effects.forEach((fn) => fn());\n  }\n````\n\n这段代码可以看出它的桶设计如下\n\n![请添加图片描述](https://img-blog.csdnimg.cn/186661b1f6164154801f6386257e0a4e.jpeg)\n\n## 分支切换跟cleanup\n````\n  effect(function effectFn(){\n    document.body.innerText = obj.ok ? obj.text : \"not\";\n  });\n````\n如果我们注册了这么一个副作用函数，当obj.ok为true时，会读取obj.text的值，所以这时候副作用函数会触发ok，text两个属性的读取操作，effectFn会与text,ok建立联系\n![请添加图片描述](https://img-blog.csdnimg.cn/6b41a7de060d4a82ae4d9b260cab39ff.jpeg)\n\n但当ok的值为false的时候，不会去读取obj.text，所以这个时候effectFn不应该被text的set收集，但在我们刚刚实现的响应系统里面，obj.ok变成false之后，effectFn还是在text的set里面。\n![请添加图片描述](https://img-blog.csdnimg.cn/fb7aa0c63e6c49949f5e2014c0abf669.jpeg)\n\n这种遗留的副作用函数会导致没必要的更新，obj.ok为false，无论text再怎么修改界面都是显示not，但text修改的时候却会触发effecnFn，这是多余的。为了解决这个问题，我们尝试副作用每次执行的时候把相关联的副作用函数从集合中删除。然后当副作用函数执行的时候，会重新建立联系，但新的联系中不会再包含遗留的没必要的集合。\n要将一个副作用函数从所有与之有关联的集合中移除，就需要明确哪些集合中有它，因此我们需要重新设计下副作用函数注册器。\n````\n  function effect(fn) {\n    const effectFn = () => {\n        //当effectFn执行时，将其设置为当前激活的副作用函数\n      activeEffect = effectFn;\n      fn();\n    };\n    //activeEffect.deps用来存储所有与该副作用函数有关联的集合\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n然后再在track函数中，将集合push到effectFn.deps\n````\n  function track(target, key) {\n    if (!activeEffect) {\n      return;\n    }\n    let depsMap = bucket.get(target);\n    if (!depsMap) {\n      depsMap = new Map();\n      bucket.set(target, depsMap);\n    }\n    let deps = depsMap.get(key);\n    if (!deps) {\n      deps = new Set();\n      depsMap.set(key, deps);\n    }\n    deps.add(activeEffect);\n    //deps就是一个与当前副作用函数关联的集合，把它push到activeEffect.deps中\n    activeEffect.deps.push(deps);\n  }\n\n````\n有了副作用函数的集合对象，我们就可以在触发副作用函数的时候把该副作用函数从集合中移除了。下面通过实现一个cleanup函数来处理。\n````\n  function cleanup(effectFn) {\n    for (let i = 0; i < effectFn.deps.length; i++) {\n      //将effectFn从集合中删除\n      const deps = effectFn.deps[i];\n      deps.delete(effectFn);\n    }\n    effectFn.deps.length = 0;\n  }\n  function effect(fn) {\n    const effectFn = () => {\n      cleanup(effectFn);\n      activeEffect = effectFn;\n      fn();\n    };\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n这个时候运行代码会发现，副作用函数无限循环执行，这是因为trigger中我们遍历effects集合时，会调用cleanup清除，实际就是从effects中将当前正在调用的副作用函数清除，但副作用函数执行会让导致又被重新收集到集合中。\n解决的方法也很简单，构造另一个Set集合遍历它即可。\n````\n  function trigger(target, key) {\n    const depsMap = bucket.get(target);\n    if (!depsMap) {\n      return;\n    }\n    const effects = depsMap.get(key);\n    //new一个新的集合\n    const effectsToRun = new Set(effects);\n    effectsToRun && effectsToRun.forEach((fn) => fn());\n  }\n````\n再执行就没有上面循环的问题了。\n## 嵌套的effect与effect栈\n````\neffect(function effect1(){\n   function effect2(){\n       ...\n   }\n})\n````\n这段代码中effect1嵌套了effect2，effect1，effect1的执行会导致effect2的执行。在vue中这种现象是很常见的，例如组件嵌套。\n````\nconst Bar = ()=>{    \n    render(){}\n}\nconst Foo = ()=>{\n  render(){\n      return <Bar/>\n  }\n}\n````\n此时就发生了嵌套，相当于\n````\neffect(()=>{\n    Foo.render()\n    effect(()=>{\n        Bar.render()\n    })\n})\n````\n我们可以通过以下代码测试我们至今完成的响应系统是不是支持嵌套的\n````\n  let t1,t2\n  effect(() => {\n    console.log(\"eff1\");\n    effect(() => {\n      console.log(\"eff2\");\n      t2 = obj.ok;\n    });\n    t1 = obj.text;\n  });\n````\n这种情况下我们希望修改obj.text的时候会打印eff1，接着再触发内部的副作用函数打印eff2。当实际上打印出来的是eff2。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/afe73fa9f2014467adc764289c146717.jpeg)\n\n可以看到，当前text的集合中没有副作用函数。\n\n这是因为我们通过activeEffect存储当前的副作用函数，**这只能存储一个副作用函数，当发生嵌套副作用函数的时候，后面的副作用函数会把先前的副作用函数覆盖掉。** 导致在注册完副作用函数后，text的集合其实是内部的副作用函数，所以在对其进行修改后，set操作中执行的副作用函数不会对text做get操作，cleanup之后不会重新add副作用函数到集合中，所以它的集合是空的。\n\n为了解决这个问题我们创建一个副作用函数栈effectStack，在副作用函数执行时，把当前的副作用函数压入栈中，并且始终让activeEffect指向顶部的副作用函数。\n````\n  const effectStack = [];\n    function effect(fn) {\n    const effectFn = () => {\n      cleanup(effectFn);\n      activeEffect = effectFn;\n      //在调用副作用函数之前将其压入栈中\n      effectStack.push(effectFn);\n      fn();\n      //当前副作用函数执行完成后，将其弹出栈，并让activeEffect还原到之前的值\n      effectStack.pop();\n      activeEffect = effectStack[effectStack.length - 1];\n    };\n    effectFn.deps = [];\n    effectFn();\n  }\n````\n\n![请添加图片描述](https://img-blog.csdnimg.cn/b90d82c6ca0d4dc18701954f77536322.jpeg)\n\n\n修改obj.text的时候，触发外部副作用函数，将其压入栈底，再执行内部副作用函数压入到栈顶，执行后再将其弹出。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/1c0ea4985e974565a1da31ab1cee4567.jpeg)\n\n\n这样一来，响应式数据的属性就只会收集与其绑定的副作用函数。\n\n![请添加图片描述](https://img-blog.csdnimg.cn/99a539f9ad5c4211a9929f98e913aeab.jpeg)\n","slug":"vue3响应系统的作用与实现","published":1,"updated":"2023-02-01T06:11:21.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh30005ywnkg0hgf2zf","content":"<p>响应式是vue的一个重要组成部分，它实现了数据与视图的绑定。接下我们就从相应数据跟副作用函数开始一步步了解vue的响应系统的设计与实现</p>\n<h2 id=\"副作用函数\"><a href=\"#副作用函数\" class=\"headerlink\" title=\"副作用函数\"></a>副作用函数</h2><p>副作用函数是指会产生副作用的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">     document.body.innerText = &quot;hellow&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当effect执行时，会改变body的内容，但除了effect，其他函数也可以访问到body的文本内容，所以effect函数会影响到其他函数读取body的内容，即说effect是一个副作用函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1</span><br><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">    var a = 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>副作用函数非常常见，像这种effect改变了其他函数也可以访问到的全局变量，影响了其他函数对它的读取，这也是一种副作用函数。可以理解为<strong>某个函数改变了其他函数对某个内容的访问结果，即这个函数是副作用函数</strong></p>\n<h2 id=\"响应式数据\"><a href=\"#响应式数据\" class=\"headerlink\" title=\"响应式数据\"></a>响应式数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;text:&#x27;hellow&#x27;&#125;</span><br><span class=\"line\">function effect ()&#123;</span><br><span class=\"line\">     document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当effect函数执行时，会改变body的文本内容。如果obj的值变化的时候都能触发effect，从而改变body的文本内容达到改变视图的效果，那我们则称obj是一个响应数据。<br>改变obj的时候，我们会触发到它的<strong>set</strong>操作，而读取的时候会触发到<strong>get</strong>操作。</p>\n<p>如果我们可以拦截这两步操作，在读取obj.text的时候把副作用函数effect存储到一个桶里，在修改obj.text的时候再把这个副作用函数拿出来执行，便可以达到每当修改obj.text的时候都能改变视图的效果了。</p>\n<p>在vue2中，vue采用了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty</a>实现了响应系统，但<strong>Object.defineProperty只能监听指定key的value的变化，所以需要遍历整个对象从而监听所有key</strong>。vue3使用了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>代替了defineProperty解决了这一痛点。<br>这里我们用proxy来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用于存储副作用函数的桶</span><br><span class=\"line\">const bucket = new Set();</span><br><span class=\"line\">//原始数据</span><br><span class=\"line\">const data = &#123; text: &quot;hellow&quot; &#125;;</span><br><span class=\"line\">//对原始数据的代理</span><br><span class=\"line\">const obj = new Proxy(data, &#123;</span><br><span class=\"line\">  get(target, key) &#123;</span><br><span class=\"line\">    //将副作用函数丢进bucket</span><br><span class=\"line\">    if (effect) &#123;</span><br><span class=\"line\">      bucket.add(effect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回读取的值</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, key, newVal) &#123;</span><br><span class=\"line\">    //设置新属性值</span><br><span class=\"line\">    target[key] = newVal;</span><br><span class=\"line\">    //把副作用函数从桶取出并执行</span><br><span class=\"line\">    bucket.forEach((fn) =&gt; fn());</span><br><span class=\"line\">    //设置成功</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这时候执行effect之后，再改变obj.text的值的时候，会发数据响应视图，视图改变了。成功实现了一个响应数据。</p>\n<h2 id=\"注册副作用函数\"><a href=\"#注册副作用函数\" class=\"headerlink\" title=\"注册副作用函数\"></a>注册副作用函数</h2><p>在上面代码中，我们使用effect作为副作用函数，但实际中副作用函数不一定这么命名，甚至可能是一个匿名函数，所以我们需要一个注册副作用函数的流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用一个全局变量存储被注册的副作用函数</span><br><span class=\"line\">let activeEffect;</span><br><span class=\"line\">//用于注册副作用函数</span><br><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  activeEffect = fn;</span><br><span class=\"line\">  fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = new Proxy(data, &#123;</span><br><span class=\"line\">  get(target, key) &#123;</span><br><span class=\"line\">    //将副作用函数丢进bucket</span><br><span class=\"line\">    if (activeEffect) &#123;</span><br><span class=\"line\">      bucket.add(activeEffect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回读取的值</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, key, newVal) &#123;</span><br><span class=\"line\">    //设置新属性值</span><br><span class=\"line\">    target[key] = newVal;</span><br><span class=\"line\">    //把副作用函数从桶取出并执行</span><br><span class=\"line\">    bucket.forEach((fn) =&gt; fn());</span><br><span class=\"line\">    //设置成功</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> 这里我们定义了一个activeEffect，它的作用是用来存储被注册的副作用函数，再将effect修改为一个用来注册副作用函数的工具，这样一来无论副作用函数是什么都可以通过注册副作用函数注册后由activeEffect来表示。<br>当执行effect时，会把匿名函数赋值给activeEffect，接着执行传入的fn函数，会触发obj.text的get，从而将副作用函数放到桶中.</p>\n<h2 id=\"完善存放副作用函数的桶的数据结构\"><a href=\"#完善存放副作用函数的桶的数据结构\" class=\"headerlink\" title=\"完善存放副作用函数的桶的数据结构\"></a>完善存放副作用函数的桶的数据结构</h2><p>以上步骤一直围绕着obj.text做操作，我们的副作用函数是与之绑定的，<strong>如果我们设置了一个原先不存在的属性的话，由于它与副作用函数是没联系的，所以理论上不应该触发这个副作用函数，但实际上当我们对obj设置一个新属性的时候它触发了这个与它没联系的副作用函数</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;effect&#x27;)</span><br><span class=\"line\">  document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = 1</span><br></pre></td></tr></table></figure>\n<p>触发obj.a = 1的时候可以看到副作用函数被触发了，这是不合理的。导致该问题的原因就是我们没有在副作用函数中明确副作用函数与被操作的字段建立联系。这会导致无论当前读取的是哪个属性，都会把副作用函数丢到桶里，设置的时候也是如此，无论是设置哪个属性都会把桶里的副作用函数拿出来执行。所以对这个桶的结构我们需要重新设计下。先看下执行副作用函数的时候其内部的关系。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">    document.body.innerText = obj.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中有三个角色</p>\n<ul>\n<li>代理对象obj</li>\n<li>字段名text</li>\n<li>副作用函数effect</li>\n</ul>\n<p>把target看成一个代理对象，key是被操作的字段，effectfn是副作用函数，那么它们的关系如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6444860aedc048829280a5353b78b14a.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果是有两个副作用函数作用于一个字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1() &#123;</span><br><span class=\"line\">  obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(function effect2() &#123;</span><br><span class=\"line\">  obj.text;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>那么关系如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2fa829f9a8ac47578f809fa9de9583f2.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果一个副作用函数中读取了多个属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect()&#123;</span><br><span class=\"line\">    obj.text1</span><br><span class=\"line\">    obj.text2</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/73a73d0dfb584e3e847d8217fc0dc7c6.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果在不同副作用函数读取不同属性的话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1() &#123;</span><br><span class=\"line\">  obj.text1;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(function effect2() &#123;</span><br><span class=\"line\">  obj.text2;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b1da665fd27f4044b85145d552623a19.jpeg\" alt=\"请添加图片描述\"></p>\n<p>按这个关系来看，便可以解决了我们先前改变任何属性都会触发副作用函数的问题。例如这里我们读取或者设置了text1，只会触发effect1，而不会导致effect2执行。接着就来实现这个桶。</p>\n<p>首先我们使用weakMap代替先前的set作为桶的数据结构。因为需要一个key与effectFn的映射关系。<br>这里说一下WeakMap跟Map的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\">const weakmap = new WeakMap();</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  const foo = &#123; foo: 1 &#125;;</span><br><span class=\"line\">  const bar = &#123; bar: 1 &#125;;</span><br><span class=\"line\">  map.set(foo, 1);</span><br><span class=\"line\">  weakmap.set(bar, 2);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>我们创建了map，weakmap两个实例，在立即执行函数内部定义了foo，bar两个对象并且将这两个对象作为map，weakmap的key。函数执行结束后foo还作为key被map引用，因此它没有被垃圾回收器移除，还可以通过map.keys打印出来。而weakmap是弱引用，它不影响垃圾回收器的运作，所以执行完后bar会被垃圾回收器回收，我们也无法通过weakmap获取到bar。<br>所以使用weakmap常用于存储那些只有当key引用对象存在时才有价值的信息，如果使用map的话，绑定的数据不再被引用了，也不会被回收，最终可能会造成<strong>内存泄漏</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const bucket = new WeakMap();</span><br><span class=\"line\"> const obj = new Proxy(data, &#123;</span><br><span class=\"line\">   get(target, key) &#123;</span><br><span class=\"line\">     track(target, key);</span><br><span class=\"line\">     return target[key];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   set(target, key, newVal) &#123;</span><br><span class=\"line\">     target[key] = newVal;</span><br><span class=\"line\">     trigger(target, key);</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function track(target, key) &#123;</span><br><span class=\"line\">   //如果没有副作用函数直接return</span><br><span class=\"line\">   if (!activeEffect) &#123;</span><br><span class=\"line\">     return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //根据target从桶中取出desMap</span><br><span class=\"line\">   let depsMap = bucket.get(target);</span><br><span class=\"line\">   //如果desMap不存在那么创建一个Map并与target关联</span><br><span class=\"line\">   if (!depsMap) &#123;</span><br><span class=\"line\">     depsMap = new Map();</span><br><span class=\"line\">     bucket.set(target, depsMap);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //再根据key从desMap中取得deps，它里面存储着所有与当前key关联的副作用函数 effects</span><br><span class=\"line\">   let deps = depsMap.get(key);</span><br><span class=\"line\">   //如果deps不存在，同样创建一个Set并与key关联</span><br><span class=\"line\">   if (!deps) &#123;</span><br><span class=\"line\">     deps = new Set();</span><br><span class=\"line\">     depsMap.set(key, deps);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //最后将当前激活的副作用函数添加到桶里</span><br><span class=\"line\">   deps.add(activeEffect);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> function trigger(target, key) &#123;</span><br><span class=\"line\">   //根据target从桶中取出depsMap</span><br><span class=\"line\">   const depsMap = bucket.get(target);</span><br><span class=\"line\">   if (!depsMap) &#123;</span><br><span class=\"line\">     return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //根据key取得所有副作用函数effects</span><br><span class=\"line\">   const effects = depsMap.get(key);</span><br><span class=\"line\">   //执行副作用函数</span><br><span class=\"line\">   effects &amp;&amp; effects.forEach((fn) =&gt; fn());</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码可以看出它的桶设计如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/186661b1f6164154801f6386257e0a4e.jpeg\" alt=\"请添加图片描述\"></p>\n<h2 id=\"分支切换跟cleanup\"><a href=\"#分支切换跟cleanup\" class=\"headerlink\" title=\"分支切换跟cleanup\"></a>分支切换跟cleanup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effectFn()&#123;</span><br><span class=\"line\">  document.body.innerText = obj.ok ? obj.text : &quot;not&quot;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果我们注册了这么一个副作用函数，当obj.ok为true时，会读取obj.text的值，所以这时候副作用函数会触发ok，text两个属性的读取操作，effectFn会与text,ok建立联系<br><img src=\"https://img-blog.csdnimg.cn/6b41a7de060d4a82ae4d9b260cab39ff.jpeg\" alt=\"请添加图片描述\"></p>\n<p>但当ok的值为false的时候，不会去读取obj.text，所以这个时候effectFn不应该被text的set收集，但在我们刚刚实现的响应系统里面，obj.ok变成false之后，effectFn还是在text的set里面。<br><img src=\"https://img-blog.csdnimg.cn/fb7aa0c63e6c49949f5e2014c0abf669.jpeg\" alt=\"请添加图片描述\"></p>\n<p>这种遗留的副作用函数会导致没必要的更新，obj.ok为false，无论text再怎么修改界面都是显示not，但text修改的时候却会触发effecnFn，这是多余的。为了解决这个问题，我们尝试副作用每次执行的时候把相关联的副作用函数从集合中删除。然后当副作用函数执行的时候，会重新建立联系，但新的联系中不会再包含遗留的没必要的集合。<br>要将一个副作用函数从所有与之有关联的集合中移除，就需要明确哪些集合中有它，因此我们需要重新设计下副作用函数注册器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">      //当effectFn执行时，将其设置为当前激活的副作用函数</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  //activeEffect.deps用来存储所有与该副作用函数有关联的集合</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再在track函数中，将集合push到effectFn.deps</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function track(target, key) &#123;</span><br><span class=\"line\">  if (!activeEffect) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let depsMap = bucket.get(target);</span><br><span class=\"line\">  if (!depsMap) &#123;</span><br><span class=\"line\">    depsMap = new Map();</span><br><span class=\"line\">    bucket.set(target, depsMap);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let deps = depsMap.get(key);</span><br><span class=\"line\">  if (!deps) &#123;</span><br><span class=\"line\">    deps = new Set();</span><br><span class=\"line\">    depsMap.set(key, deps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deps.add(activeEffect);</span><br><span class=\"line\">  //deps就是一个与当前副作用函数关联的集合，把它push到activeEffect.deps中</span><br><span class=\"line\">  activeEffect.deps.push(deps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>有了副作用函数的集合对象，我们就可以在触发副作用函数的时候把该副作用函数从集合中移除了。下面通过实现一个cleanup函数来处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function cleanup(effectFn) &#123;</span><br><span class=\"line\">  for (let i = 0; i &lt; effectFn.deps.length; i++) &#123;</span><br><span class=\"line\">    //将effectFn从集合中删除</span><br><span class=\"line\">    const deps = effectFn.deps[i];</span><br><span class=\"line\">    deps.delete(effectFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  effectFn.deps.length = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">    cleanup(effectFn);</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候运行代码会发现，副作用函数无限循环执行，这是因为trigger中我们遍历effects集合时，会调用cleanup清除，实际就是从effects中将当前正在调用的副作用函数清除，但副作用函数执行会让导致又被重新收集到集合中。<br>解决的方法也很简单，构造另一个Set集合遍历它即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function trigger(target, key) &#123;</span><br><span class=\"line\">  const depsMap = bucket.get(target);</span><br><span class=\"line\">  if (!depsMap) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const effects = depsMap.get(key);</span><br><span class=\"line\">  //new一个新的集合</span><br><span class=\"line\">  const effectsToRun = new Set(effects);</span><br><span class=\"line\">  effectsToRun &amp;&amp; effectsToRun.forEach((fn) =&gt; fn());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再执行就没有上面循环的问题了。</p>\n<h2 id=\"嵌套的effect与effect栈\"><a href=\"#嵌套的effect与effect栈\" class=\"headerlink\" title=\"嵌套的effect与effect栈\"></a>嵌套的effect与effect栈</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1()&#123;</span><br><span class=\"line\">   function effect2()&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这段代码中effect1嵌套了effect2，effect1，effect1的执行会导致effect2的执行。在vue中这种现象是很常见的，例如组件嵌套。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Bar = ()=&gt;&#123;    </span><br><span class=\"line\">    render()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Foo = ()=&gt;&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">      return &lt;Bar/&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时就发生了嵌套，相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(()=&gt;&#123;</span><br><span class=\"line\">    Foo.render()</span><br><span class=\"line\">    effect(()=&gt;&#123;</span><br><span class=\"line\">        Bar.render()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们可以通过以下代码测试我们至今完成的响应系统是不是支持嵌套的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let t1,t2</span><br><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;eff1&quot;);</span><br><span class=\"line\">  effect(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;eff2&quot;);</span><br><span class=\"line\">    t2 = obj.ok;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  t1 = obj.text;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种情况下我们希望修改obj.text的时候会打印eff1，接着再触发内部的副作用函数打印eff2。当实际上打印出来的是eff2。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/afe73fa9f2014467adc764289c146717.jpeg\" alt=\"请添加图片描述\"></p>\n<p>可以看到，当前text的集合中没有副作用函数。</p>\n<p>这是因为我们通过activeEffect存储当前的副作用函数，<strong>这只能存储一个副作用函数，当发生嵌套副作用函数的时候，后面的副作用函数会把先前的副作用函数覆盖掉。</strong> 导致在注册完副作用函数后，text的集合其实是内部的副作用函数，所以在对其进行修改后，set操作中执行的副作用函数不会对text做get操作，cleanup之后不会重新add副作用函数到集合中，所以它的集合是空的。</p>\n<p>为了解决这个问题我们创建一个副作用函数栈effectStack，在副作用函数执行时，把当前的副作用函数压入栈中，并且始终让activeEffect指向顶部的副作用函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const effectStack = [];</span><br><span class=\"line\">  function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">    cleanup(effectFn);</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    //在调用副作用函数之前将其压入栈中</span><br><span class=\"line\">    effectStack.push(effectFn);</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    //当前副作用函数执行完成后，将其弹出栈，并让activeEffect还原到之前的值</span><br><span class=\"line\">    effectStack.pop();</span><br><span class=\"line\">    activeEffect = effectStack[effectStack.length - 1];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b90d82c6ca0d4dc18701954f77536322.jpeg\" alt=\"请添加图片描述\"></p>\n<p>修改obj.text的时候，触发外部副作用函数，将其压入栈底，再执行内部副作用函数压入到栈顶，执行后再将其弹出。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1c0ea4985e974565a1da31ab1cee4567.jpeg\" alt=\"请添加图片描述\"></p>\n<p>这样一来，响应式数据的属性就只会收集与其绑定的副作用函数。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/99a539f9ad5c4211a9929f98e913aeab.jpeg\" alt=\"请添加图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>响应式是vue的一个重要组成部分，它实现了数据与视图的绑定。接下我们就从相应数据跟副作用函数开始一步步了解vue的响应系统的设计与实现</p>\n<h2 id=\"副作用函数\"><a href=\"#副作用函数\" class=\"headerlink\" title=\"副作用函数\"></a>副作用函数</h2><p>副作用函数是指会产生副作用的函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">     document.body.innerText = &quot;hellow&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当effect执行时，会改变body的内容，但除了effect，其他函数也可以访问到body的文本内容，所以effect函数会影响到其他函数读取body的内容，即说effect是一个副作用函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1</span><br><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">    var a = 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>副作用函数非常常见，像这种effect改变了其他函数也可以访问到的全局变量，影响了其他函数对它的读取，这也是一种副作用函数。可以理解为<strong>某个函数改变了其他函数对某个内容的访问结果，即这个函数是副作用函数</strong></p>\n<h2 id=\"响应式数据\"><a href=\"#响应式数据\" class=\"headerlink\" title=\"响应式数据\"></a>响应式数据</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123;text:&#x27;hellow&#x27;&#125;</span><br><span class=\"line\">function effect ()&#123;</span><br><span class=\"line\">     document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当effect函数执行时，会改变body的文本内容。如果obj的值变化的时候都能触发effect，从而改变body的文本内容达到改变视图的效果，那我们则称obj是一个响应数据。<br>改变obj的时候，我们会触发到它的<strong>set</strong>操作，而读取的时候会触发到<strong>get</strong>操作。</p>\n<p>如果我们可以拦截这两步操作，在读取obj.text的时候把副作用函数effect存储到一个桶里，在修改obj.text的时候再把这个副作用函数拿出来执行，便可以达到每当修改obj.text的时候都能改变视图的效果了。</p>\n<p>在vue2中，vue采用了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">Object.defineProperty</a>实现了响应系统，但<strong>Object.defineProperty只能监听指定key的value的变化，所以需要遍历整个对象从而监听所有key</strong>。vue3使用了<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">Proxy</a>代替了defineProperty解决了这一痛点。<br>这里我们用proxy来实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用于存储副作用函数的桶</span><br><span class=\"line\">const bucket = new Set();</span><br><span class=\"line\">//原始数据</span><br><span class=\"line\">const data = &#123; text: &quot;hellow&quot; &#125;;</span><br><span class=\"line\">//对原始数据的代理</span><br><span class=\"line\">const obj = new Proxy(data, &#123;</span><br><span class=\"line\">  get(target, key) &#123;</span><br><span class=\"line\">    //将副作用函数丢进bucket</span><br><span class=\"line\">    if (effect) &#123;</span><br><span class=\"line\">      bucket.add(effect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回读取的值</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, key, newVal) &#123;</span><br><span class=\"line\">    //设置新属性值</span><br><span class=\"line\">    target[key] = newVal;</span><br><span class=\"line\">    //把副作用函数从桶取出并执行</span><br><span class=\"line\">    bucket.forEach((fn) =&gt; fn());</span><br><span class=\"line\">    //设置成功</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这时候执行effect之后，再改变obj.text的值的时候，会发数据响应视图，视图改变了。成功实现了一个响应数据。</p>\n<h2 id=\"注册副作用函数\"><a href=\"#注册副作用函数\" class=\"headerlink\" title=\"注册副作用函数\"></a>注册副作用函数</h2><p>在上面代码中，我们使用effect作为副作用函数，但实际中副作用函数不一定这么命名，甚至可能是一个匿名函数，所以我们需要一个注册副作用函数的流程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用一个全局变量存储被注册的副作用函数</span><br><span class=\"line\">let activeEffect;</span><br><span class=\"line\">//用于注册副作用函数</span><br><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  activeEffect = fn;</span><br><span class=\"line\">  fn();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const obj = new Proxy(data, &#123;</span><br><span class=\"line\">  get(target, key) &#123;</span><br><span class=\"line\">    //将副作用函数丢进bucket</span><br><span class=\"line\">    if (activeEffect) &#123;</span><br><span class=\"line\">      bucket.add(activeEffect);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //返回读取的值</span><br><span class=\"line\">    return target[key];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set(target, key, newVal) &#123;</span><br><span class=\"line\">    //设置新属性值</span><br><span class=\"line\">    target[key] = newVal;</span><br><span class=\"line\">    //把副作用函数从桶取出并执行</span><br><span class=\"line\">    bucket.forEach((fn) =&gt; fn());</span><br><span class=\"line\">    //设置成功</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p> 这里我们定义了一个activeEffect，它的作用是用来存储被注册的副作用函数，再将effect修改为一个用来注册副作用函数的工具，这样一来无论副作用函数是什么都可以通过注册副作用函数注册后由activeEffect来表示。<br>当执行effect时，会把匿名函数赋值给activeEffect，接着执行传入的fn函数，会触发obj.text的get，从而将副作用函数放到桶中.</p>\n<h2 id=\"完善存放副作用函数的桶的数据结构\"><a href=\"#完善存放副作用函数的桶的数据结构\" class=\"headerlink\" title=\"完善存放副作用函数的桶的数据结构\"></a>完善存放副作用函数的桶的数据结构</h2><p>以上步骤一直围绕着obj.text做操作，我们的副作用函数是与之绑定的，<strong>如果我们设置了一个原先不存在的属性的话，由于它与副作用函数是没联系的，所以理论上不应该触发这个副作用函数，但实际上当我们对obj设置一个新属性的时候它触发了这个与它没联系的副作用函数</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&#x27;effect&#x27;)</span><br><span class=\"line\">  document.body.innerText = obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.a = 1</span><br></pre></td></tr></table></figure>\n<p>触发obj.a = 1的时候可以看到副作用函数被触发了，这是不合理的。导致该问题的原因就是我们没有在副作用函数中明确副作用函数与被操作的字段建立联系。这会导致无论当前读取的是哪个属性，都会把副作用函数丢到桶里，设置的时候也是如此，无论是设置哪个属性都会把桶里的副作用函数拿出来执行。所以对这个桶的结构我们需要重新设计下。先看下执行副作用函数的时候其内部的关系。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect()&#123;</span><br><span class=\"line\">    document.body.innerText = obj.text</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中有三个角色</p>\n<ul>\n<li>代理对象obj</li>\n<li>字段名text</li>\n<li>副作用函数effect</li>\n</ul>\n<p>把target看成一个代理对象，key是被操作的字段，effectfn是副作用函数，那么它们的关系如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6444860aedc048829280a5353b78b14a.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果是有两个副作用函数作用于一个字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1() &#123;</span><br><span class=\"line\">  obj.text;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(function effect2() &#123;</span><br><span class=\"line\">  obj.text;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>那么关系如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2fa829f9a8ac47578f809fa9de9583f2.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果一个副作用函数中读取了多个属性</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect()&#123;</span><br><span class=\"line\">    obj.text1</span><br><span class=\"line\">    obj.text2</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/73a73d0dfb584e3e847d8217fc0dc7c6.jpeg\" alt=\"请添加图片描述\"></p>\n<p>如果在不同副作用函数读取不同属性的话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1() &#123;</span><br><span class=\"line\">  obj.text1;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">effect(function effect2() &#123;</span><br><span class=\"line\">  obj.text2;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b1da665fd27f4044b85145d552623a19.jpeg\" alt=\"请添加图片描述\"></p>\n<p>按这个关系来看，便可以解决了我们先前改变任何属性都会触发副作用函数的问题。例如这里我们读取或者设置了text1，只会触发effect1，而不会导致effect2执行。接着就来实现这个桶。</p>\n<p>首先我们使用weakMap代替先前的set作为桶的数据结构。因为需要一个key与effectFn的映射关系。<br>这里说一下WeakMap跟Map的区别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\">const weakmap = new WeakMap();</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  const foo = &#123; foo: 1 &#125;;</span><br><span class=\"line\">  const bar = &#123; bar: 1 &#125;;</span><br><span class=\"line\">  map.set(foo, 1);</span><br><span class=\"line\">  weakmap.set(bar, 2);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>我们创建了map，weakmap两个实例，在立即执行函数内部定义了foo，bar两个对象并且将这两个对象作为map，weakmap的key。函数执行结束后foo还作为key被map引用，因此它没有被垃圾回收器移除，还可以通过map.keys打印出来。而weakmap是弱引用，它不影响垃圾回收器的运作，所以执行完后bar会被垃圾回收器回收，我们也无法通过weakmap获取到bar。<br>所以使用weakmap常用于存储那些只有当key引用对象存在时才有价值的信息，如果使用map的话，绑定的数据不再被引用了，也不会被回收，最终可能会造成<strong>内存泄漏</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const bucket = new WeakMap();</span><br><span class=\"line\"> const obj = new Proxy(data, &#123;</span><br><span class=\"line\">   get(target, key) &#123;</span><br><span class=\"line\">     track(target, key);</span><br><span class=\"line\">     return target[key];</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   set(target, key, newVal) &#123;</span><br><span class=\"line\">     target[key] = newVal;</span><br><span class=\"line\">     trigger(target, key);</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function track(target, key) &#123;</span><br><span class=\"line\">   //如果没有副作用函数直接return</span><br><span class=\"line\">   if (!activeEffect) &#123;</span><br><span class=\"line\">     return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //根据target从桶中取出desMap</span><br><span class=\"line\">   let depsMap = bucket.get(target);</span><br><span class=\"line\">   //如果desMap不存在那么创建一个Map并与target关联</span><br><span class=\"line\">   if (!depsMap) &#123;</span><br><span class=\"line\">     depsMap = new Map();</span><br><span class=\"line\">     bucket.set(target, depsMap);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //再根据key从desMap中取得deps，它里面存储着所有与当前key关联的副作用函数 effects</span><br><span class=\"line\">   let deps = depsMap.get(key);</span><br><span class=\"line\">   //如果deps不存在，同样创建一个Set并与key关联</span><br><span class=\"line\">   if (!deps) &#123;</span><br><span class=\"line\">     deps = new Set();</span><br><span class=\"line\">     depsMap.set(key, deps);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //最后将当前激活的副作用函数添加到桶里</span><br><span class=\"line\">   deps.add(activeEffect);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> function trigger(target, key) &#123;</span><br><span class=\"line\">   //根据target从桶中取出depsMap</span><br><span class=\"line\">   const depsMap = bucket.get(target);</span><br><span class=\"line\">   if (!depsMap) &#123;</span><br><span class=\"line\">     return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   //根据key取得所有副作用函数effects</span><br><span class=\"line\">   const effects = depsMap.get(key);</span><br><span class=\"line\">   //执行副作用函数</span><br><span class=\"line\">   effects &amp;&amp; effects.forEach((fn) =&gt; fn());</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码可以看出它的桶设计如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/186661b1f6164154801f6386257e0a4e.jpeg\" alt=\"请添加图片描述\"></p>\n<h2 id=\"分支切换跟cleanup\"><a href=\"#分支切换跟cleanup\" class=\"headerlink\" title=\"分支切换跟cleanup\"></a>分支切换跟cleanup</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effectFn()&#123;</span><br><span class=\"line\">  document.body.innerText = obj.ok ? obj.text : &quot;not&quot;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果我们注册了这么一个副作用函数，当obj.ok为true时，会读取obj.text的值，所以这时候副作用函数会触发ok，text两个属性的读取操作，effectFn会与text,ok建立联系<br><img src=\"https://img-blog.csdnimg.cn/6b41a7de060d4a82ae4d9b260cab39ff.jpeg\" alt=\"请添加图片描述\"></p>\n<p>但当ok的值为false的时候，不会去读取obj.text，所以这个时候effectFn不应该被text的set收集，但在我们刚刚实现的响应系统里面，obj.ok变成false之后，effectFn还是在text的set里面。<br><img src=\"https://img-blog.csdnimg.cn/fb7aa0c63e6c49949f5e2014c0abf669.jpeg\" alt=\"请添加图片描述\"></p>\n<p>这种遗留的副作用函数会导致没必要的更新，obj.ok为false，无论text再怎么修改界面都是显示not，但text修改的时候却会触发effecnFn，这是多余的。为了解决这个问题，我们尝试副作用每次执行的时候把相关联的副作用函数从集合中删除。然后当副作用函数执行的时候，会重新建立联系，但新的联系中不会再包含遗留的没必要的集合。<br>要将一个副作用函数从所有与之有关联的集合中移除，就需要明确哪些集合中有它，因此我们需要重新设计下副作用函数注册器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">      //当effectFn执行时，将其设置为当前激活的副作用函数</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  //activeEffect.deps用来存储所有与该副作用函数有关联的集合</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再在track函数中，将集合push到effectFn.deps</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function track(target, key) &#123;</span><br><span class=\"line\">  if (!activeEffect) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let depsMap = bucket.get(target);</span><br><span class=\"line\">  if (!depsMap) &#123;</span><br><span class=\"line\">    depsMap = new Map();</span><br><span class=\"line\">    bucket.set(target, depsMap);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let deps = depsMap.get(key);</span><br><span class=\"line\">  if (!deps) &#123;</span><br><span class=\"line\">    deps = new Set();</span><br><span class=\"line\">    depsMap.set(key, deps);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  deps.add(activeEffect);</span><br><span class=\"line\">  //deps就是一个与当前副作用函数关联的集合，把它push到activeEffect.deps中</span><br><span class=\"line\">  activeEffect.deps.push(deps);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>有了副作用函数的集合对象，我们就可以在触发副作用函数的时候把该副作用函数从集合中移除了。下面通过实现一个cleanup函数来处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function cleanup(effectFn) &#123;</span><br><span class=\"line\">  for (let i = 0; i &lt; effectFn.deps.length; i++) &#123;</span><br><span class=\"line\">    //将effectFn从集合中删除</span><br><span class=\"line\">    const deps = effectFn.deps[i];</span><br><span class=\"line\">    deps.delete(effectFn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  effectFn.deps.length = 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">    cleanup(effectFn);</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个时候运行代码会发现，副作用函数无限循环执行，这是因为trigger中我们遍历effects集合时，会调用cleanup清除，实际就是从effects中将当前正在调用的副作用函数清除，但副作用函数执行会让导致又被重新收集到集合中。<br>解决的方法也很简单，构造另一个Set集合遍历它即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function trigger(target, key) &#123;</span><br><span class=\"line\">  const depsMap = bucket.get(target);</span><br><span class=\"line\">  if (!depsMap) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const effects = depsMap.get(key);</span><br><span class=\"line\">  //new一个新的集合</span><br><span class=\"line\">  const effectsToRun = new Set(effects);</span><br><span class=\"line\">  effectsToRun &amp;&amp; effectsToRun.forEach((fn) =&gt; fn());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再执行就没有上面循环的问题了。</p>\n<h2 id=\"嵌套的effect与effect栈\"><a href=\"#嵌套的effect与effect栈\" class=\"headerlink\" title=\"嵌套的effect与effect栈\"></a>嵌套的effect与effect栈</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(function effect1()&#123;</span><br><span class=\"line\">   function effect2()&#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这段代码中effect1嵌套了effect2，effect1，effect1的执行会导致effect2的执行。在vue中这种现象是很常见的，例如组件嵌套。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Bar = ()=&gt;&#123;    </span><br><span class=\"line\">    render()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const Foo = ()=&gt;&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">      return &lt;Bar/&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时就发生了嵌套，相当于</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">effect(()=&gt;&#123;</span><br><span class=\"line\">    Foo.render()</span><br><span class=\"line\">    effect(()=&gt;&#123;</span><br><span class=\"line\">        Bar.render()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们可以通过以下代码测试我们至今完成的响应系统是不是支持嵌套的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let t1,t2</span><br><span class=\"line\">effect(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;eff1&quot;);</span><br><span class=\"line\">  effect(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;eff2&quot;);</span><br><span class=\"line\">    t2 = obj.ok;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  t1 = obj.text;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种情况下我们希望修改obj.text的时候会打印eff1，接着再触发内部的副作用函数打印eff2。当实际上打印出来的是eff2。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/afe73fa9f2014467adc764289c146717.jpeg\" alt=\"请添加图片描述\"></p>\n<p>可以看到，当前text的集合中没有副作用函数。</p>\n<p>这是因为我们通过activeEffect存储当前的副作用函数，<strong>这只能存储一个副作用函数，当发生嵌套副作用函数的时候，后面的副作用函数会把先前的副作用函数覆盖掉。</strong> 导致在注册完副作用函数后，text的集合其实是内部的副作用函数，所以在对其进行修改后，set操作中执行的副作用函数不会对text做get操作，cleanup之后不会重新add副作用函数到集合中，所以它的集合是空的。</p>\n<p>为了解决这个问题我们创建一个副作用函数栈effectStack，在副作用函数执行时，把当前的副作用函数压入栈中，并且始终让activeEffect指向顶部的副作用函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const effectStack = [];</span><br><span class=\"line\">  function effect(fn) &#123;</span><br><span class=\"line\">  const effectFn = () =&gt; &#123;</span><br><span class=\"line\">    cleanup(effectFn);</span><br><span class=\"line\">    activeEffect = effectFn;</span><br><span class=\"line\">    //在调用副作用函数之前将其压入栈中</span><br><span class=\"line\">    effectStack.push(effectFn);</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    //当前副作用函数执行完成后，将其弹出栈，并让activeEffect还原到之前的值</span><br><span class=\"line\">    effectStack.pop();</span><br><span class=\"line\">    activeEffect = effectStack[effectStack.length - 1];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  effectFn.deps = [];</span><br><span class=\"line\">  effectFn();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/b90d82c6ca0d4dc18701954f77536322.jpeg\" alt=\"请添加图片描述\"></p>\n<p>修改obj.text的时候，触发外部副作用函数，将其压入栈底，再执行内部副作用函数压入到栈顶，执行后再将其弹出。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1c0ea4985e974565a1da31ab1cee4567.jpeg\" alt=\"请添加图片描述\"></p>\n<p>这样一来，响应式数据的属性就只会收集与其绑定的副作用函数。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/99a539f9ad5c4211a9929f98e913aeab.jpeg\" alt=\"请添加图片描述\"></p>\n"},{"title":"浏览器渲染页面时，渲染进程做了什么","date":"2023-02-01T03:58:13.000Z","description":"浏览器通过网络进程，拿到数据给到渲染进程后......","_content":"\n浏览器通过网络进程，如果最后解析到的数据格式是**text/html**，那么浏览器则会继续进行渲染流程。\n每一个页面回对应一个渲染进程，每打开一个页面浏览器就会配套一个新的渲染进程。当渲染进程拿到浏览器进程传过来的数据后就可以开始进行渲染了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png =500x)\n这里我们把渲染进程依据时间顺序分成以下几个步骤。**构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。\n## 1.构建dom树\n浏览器无法直接理解html，所以需要将html转换成浏览器能够理解的结构，即dom树。\n## 2.计算样式\n计算样式的目的是得到dom节点中每个元素的样式，需要以下几步。\n- 将css转换成浏览器能理解的结构，styleSheets。\n- 转换样式表中的属性值，使其标准化。\n- 计算出dom节点中每个元素的样式。\n\n关于如何计算出dom节点中每个元素的样式，这涉及到**CSS的继承规则和层叠规则**了。\n首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式，就像下图中的content_views，除了本身的样式，还继承了父节点的样式。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png =500x)\n至于层叠，层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。\n我们可以在浏览器控制台element的Computed中看到对应dom最后计算得到的样式。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png =500x)\n## 3.布局阶段\n有了dom树跟对应的样式，接下来需要计算出dom树中可见元素的位置，这个动作就是布局。\n#### 创建布局树\n在页面中，不是所有dom节点都能看见的，像head，script，meta以及display:none的节点等。所以在显示之前，我们还要额外地构建一棵只**包含可见元素布局树**。\n为了构建布局树，浏览器大体上完成了下面这些工作：\n- 遍历DOM树中的所有可见节点，并把这些节点加到布局中；\n- 而不可见的节点会被布局树忽略掉；\n#### 计算布局\n在执行布局操作的时候，会把布局运算的结果重新写回布局树中。每个元素的具体位置信息。\n## 4.分层\n页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，z-index等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。**\n通过控制台的Layers，可以清晰地看到页面带分层。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png =500x)\n可见浏览器的页面实际上被分成了多个层面，最后叠加成我们最后看到的页面。\n布局树跟图层树的关系如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png =700x)\n一般情况下，不是每个节点都会包含一个图层，某个节点如果没有自己的图层那么它就会丛书父节点的图层，像上图中的span。想要**生成新图层**的话需要满足以下任意一个条件。\n- 拥有图层上下文属性（z-index，position，opacity等）\n- 需要裁剪的地方也会生成新图层\n*关于什么是裁剪，比如我们写了一个dom，给了固定宽高，里面的内容超出了它的大小，这时候它的内容就会被渲染引擎裁剪一部分显示在dom中*\n```html\n<body>\n    <div>111111111111111111</div>\n</body>\n<style>\ndiv {\n    background-color: #666666;\n    width: 50px;\n    height: 50px;\n    overflow: auto;\n}\n</style>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png =500x)\n\n## 5.绘制\n图层树构建完成后，渲染引擎会对每个图层进行绘制。渲染引擎会先把一个图层的绘制内容分成多个部分，将其组成一个绘制列表。我们可以通过控制台的Layers，选择对应的图层查看其绘制列表和过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png =700x)\n## 6.分块\n绘制列表只是用于记录绘制顺序和指令，实际上做绘制的是渲染引擎中的合成线程操作的。主线程中绘制列表准备好后会将其提交给合成线程。\n合成线程首先会将图层进行**分块**，因为**一个页面往往一个屏幕的可见区域是装不下的，浏览器没必要一次性将整个图层绘制出来，这时候就会先将其分块**。合成线程再优先对可见区域附近的图块进行绘制生成位图（*是由像素的单个点组成的图像*）。\n## 7.光栅化\n**实际生成位图的操作是由栅格化来执行的**。所谓栅格化，是指将图块转换为位图。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。\nGPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png =500x)\n## 8.合成\n一旦所有图块都栅格化完成，合成线程（渲染进程）就会生成一个DrawQuad命令告知浏览器进程，浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。至此渲染流程完毕。\n## 总结\n整个渲染流程可以概括如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png =500x)\n- 1.渲染进程将HTML转换为DOM树。\n- 2.渲染引擎将CSS转化为styleSheets，计算出DOM节点的样式。\n- 3.创建布局树，并计算元素的布局信息。\n- 4.对布局树进行分层，并生成分层树。\n- 5.为每个图层生成绘制列表，并将其提交到合成线程。\n- 6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n- 7.合成线程发送绘制图块命令DrawQuad给浏览器进程。\n- 8.浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。\n\n## 拓展\n#### 回流重绘\n回到我们老生常谈的**回流，重绘**。在了解了页面的渲染流程之后相信会对回流重绘会有更好的理解。\n当我们修改了dom的宽高导致回流，需要更新完整的渲染流水线，所以开销也是最大的。从整个流程上来看，它**不需要进行构建dom树，而是从构建styleSheets这一步修改其更改的样式后继续走完整个渲染流程**，而重绘呢。\n当我们修改了dom的颜色导致重绘，渲染流程也不需要重新构建dom树，但还是会修改styleSheets，但是由于没有**改变dom的几何属性会跳过布局阶段，再走完成功渲染流程，所以其消耗比回流小**。\n#### 合成\n除了回流重绘，还有一种操作叫做合成。它不需要绘制与合成，所以渲染引擎将跳过布局跟绘制，执行最后的合成操作即可。当我们在css中使用了transform便可以达到这种效果，直接在非主线程上执行合成动画操作。**所以相对于重绘和重排，合成能大大提升绘制效率**。","source":"_posts/浏览器渲染页面时，渲染进程做了什么.md","raw":"---\ntitle: 浏览器渲染页面时，渲染进程做了什么\ndate: 2023-02-01 11:58:13\ntags: 其他\ndescription: 浏览器通过网络进程，拿到数据给到渲染进程后......\n---\n\n浏览器通过网络进程，如果最后解析到的数据格式是**text/html**，那么浏览器则会继续进行渲染流程。\n每一个页面回对应一个渲染进程，每打开一个页面浏览器就会配套一个新的渲染进程。当渲染进程拿到浏览器进程传过来的数据后就可以开始进行渲染了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png =500x)\n这里我们把渲染进程依据时间顺序分成以下几个步骤。**构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。\n## 1.构建dom树\n浏览器无法直接理解html，所以需要将html转换成浏览器能够理解的结构，即dom树。\n## 2.计算样式\n计算样式的目的是得到dom节点中每个元素的样式，需要以下几步。\n- 将css转换成浏览器能理解的结构，styleSheets。\n- 转换样式表中的属性值，使其标准化。\n- 计算出dom节点中每个元素的样式。\n\n关于如何计算出dom节点中每个元素的样式，这涉及到**CSS的继承规则和层叠规则**了。\n首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式，就像下图中的content_views，除了本身的样式，还继承了父节点的样式。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png =500x)\n至于层叠，层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。\n我们可以在浏览器控制台element的Computed中看到对应dom最后计算得到的样式。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png =500x)\n## 3.布局阶段\n有了dom树跟对应的样式，接下来需要计算出dom树中可见元素的位置，这个动作就是布局。\n#### 创建布局树\n在页面中，不是所有dom节点都能看见的，像head，script，meta以及display:none的节点等。所以在显示之前，我们还要额外地构建一棵只**包含可见元素布局树**。\n为了构建布局树，浏览器大体上完成了下面这些工作：\n- 遍历DOM树中的所有可见节点，并把这些节点加到布局中；\n- 而不可见的节点会被布局树忽略掉；\n#### 计算布局\n在执行布局操作的时候，会把布局运算的结果重新写回布局树中。每个元素的具体位置信息。\n## 4.分层\n页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，z-index等，为了更加方便地实现这些效果，**渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。**\n通过控制台的Layers，可以清晰地看到页面带分层。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png =500x)\n可见浏览器的页面实际上被分成了多个层面，最后叠加成我们最后看到的页面。\n布局树跟图层树的关系如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png =700x)\n一般情况下，不是每个节点都会包含一个图层，某个节点如果没有自己的图层那么它就会丛书父节点的图层，像上图中的span。想要**生成新图层**的话需要满足以下任意一个条件。\n- 拥有图层上下文属性（z-index，position，opacity等）\n- 需要裁剪的地方也会生成新图层\n*关于什么是裁剪，比如我们写了一个dom，给了固定宽高，里面的内容超出了它的大小，这时候它的内容就会被渲染引擎裁剪一部分显示在dom中*\n```html\n<body>\n    <div>111111111111111111</div>\n</body>\n<style>\ndiv {\n    background-color: #666666;\n    width: 50px;\n    height: 50px;\n    overflow: auto;\n}\n</style>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png =500x)\n\n## 5.绘制\n图层树构建完成后，渲染引擎会对每个图层进行绘制。渲染引擎会先把一个图层的绘制内容分成多个部分，将其组成一个绘制列表。我们可以通过控制台的Layers，选择对应的图层查看其绘制列表和过程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png =700x)\n## 6.分块\n绘制列表只是用于记录绘制顺序和指令，实际上做绘制的是渲染引擎中的合成线程操作的。主线程中绘制列表准备好后会将其提交给合成线程。\n合成线程首先会将图层进行**分块**，因为**一个页面往往一个屏幕的可见区域是装不下的，浏览器没必要一次性将整个图层绘制出来，这时候就会先将其分块**。合成线程再优先对可见区域附近的图块进行绘制生成位图（*是由像素的单个点组成的图像*）。\n## 7.光栅化\n**实际生成位图的操作是由栅格化来执行的**。所谓栅格化，是指将图块转换为位图。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。\nGPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png =500x)\n## 8.合成\n一旦所有图块都栅格化完成，合成线程（渲染进程）就会生成一个DrawQuad命令告知浏览器进程，浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。至此渲染流程完毕。\n## 总结\n整个渲染流程可以概括如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png =500x)\n- 1.渲染进程将HTML转换为DOM树。\n- 2.渲染引擎将CSS转化为styleSheets，计算出DOM节点的样式。\n- 3.创建布局树，并计算元素的布局信息。\n- 4.对布局树进行分层，并生成分层树。\n- 5.为每个图层生成绘制列表，并将其提交到合成线程。\n- 6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n- 7.合成线程发送绘制图块命令DrawQuad给浏览器进程。\n- 8.浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。\n\n## 拓展\n#### 回流重绘\n回到我们老生常谈的**回流，重绘**。在了解了页面的渲染流程之后相信会对回流重绘会有更好的理解。\n当我们修改了dom的宽高导致回流，需要更新完整的渲染流水线，所以开销也是最大的。从整个流程上来看，它**不需要进行构建dom树，而是从构建styleSheets这一步修改其更改的样式后继续走完整个渲染流程**，而重绘呢。\n当我们修改了dom的颜色导致重绘，渲染流程也不需要重新构建dom树，但还是会修改styleSheets，但是由于没有**改变dom的几何属性会跳过布局阶段，再走完成功渲染流程，所以其消耗比回流小**。\n#### 合成\n除了回流重绘，还有一种操作叫做合成。它不需要绘制与合成，所以渲染引擎将跳过布局跟绘制，执行最后的合成操作即可。当我们在css中使用了transform便可以达到这种效果，直接在非主线程上执行合成动画操作。**所以相对于重绘和重排，合成能大大提升绘制效率**。","slug":"浏览器渲染页面时，渲染进程做了什么","published":1,"updated":"2023-02-01T04:00:07.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh50008ywnk7pwy18xm","content":"<p>浏览器通过网络进程，如果最后解析到的数据格式是<strong>text/html</strong>，那么浏览器则会继续进行渲染流程。<br>每一个页面回对应一个渲染进程，每打开一个页面浏览器就会配套一个新的渲染进程。当渲染进程拿到浏览器进程传过来的数据后就可以开始进行渲染了。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png\">https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png</a> =500x)<br>这里我们把渲染进程依据时间顺序分成以下几个步骤。<strong>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</strong>。</p>\n<h2 id=\"1-构建dom树\"><a href=\"#1-构建dom树\" class=\"headerlink\" title=\"1.构建dom树\"></a>1.构建dom树</h2><p>浏览器无法直接理解html，所以需要将html转换成浏览器能够理解的结构，即dom树。</p>\n<h2 id=\"2-计算样式\"><a href=\"#2-计算样式\" class=\"headerlink\" title=\"2.计算样式\"></a>2.计算样式</h2><p>计算样式的目的是得到dom节点中每个元素的样式，需要以下几步。</p>\n<ul>\n<li>将css转换成浏览器能理解的结构，styleSheets。</li>\n<li>转换样式表中的属性值，使其标准化。</li>\n<li>计算出dom节点中每个元素的样式。</li>\n</ul>\n<p>关于如何计算出dom节点中每个元素的样式，这涉及到<strong>CSS的继承规则和层叠规则</strong>了。<br>首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式，就像下图中的content_views，除了本身的样式，还继承了父节点的样式。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png\">https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png</a> =500x)<br>至于层叠，层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。<br>我们可以在浏览器控制台element的Computed中看到对应dom最后计算得到的样式。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png\">https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png</a> =500x)</p>\n<h2 id=\"3-布局阶段\"><a href=\"#3-布局阶段\" class=\"headerlink\" title=\"3.布局阶段\"></a>3.布局阶段</h2><p>有了dom树跟对应的样式，接下来需要计算出dom树中可见元素的位置，这个动作就是布局。</p>\n<h4 id=\"创建布局树\"><a href=\"#创建布局树\" class=\"headerlink\" title=\"创建布局树\"></a>创建布局树</h4><p>在页面中，不是所有dom节点都能看见的，像head，script，meta以及display:none的节点等。所以在显示之前，我们还要额外地构建一棵只<strong>包含可见元素布局树</strong>。<br>为了构建布局树，浏览器大体上完成了下面这些工作：</p>\n<ul>\n<li>遍历DOM树中的所有可见节点，并把这些节点加到布局中；</li>\n<li>而不可见的节点会被布局树忽略掉；<h4 id=\"计算布局\"><a href=\"#计算布局\" class=\"headerlink\" title=\"计算布局\"></a>计算布局</h4>在执行布局操作的时候，会把布局运算的结果重新写回布局树中。每个元素的具体位置信息。<h2 id=\"4-分层\"><a href=\"#4-分层\" class=\"headerlink\" title=\"4.分层\"></a>4.分层</h2>页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，z-index等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。</strong><br>通过控制台的Layers，可以清晰地看到页面带分层。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png\">https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png</a> =500x)<br>可见浏览器的页面实际上被分成了多个层面，最后叠加成我们最后看到的页面。<br>布局树跟图层树的关系如下<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png\">https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png</a> =700x)<br>一般情况下，不是每个节点都会包含一个图层，某个节点如果没有自己的图层那么它就会丛书父节点的图层，像上图中的span。想要<strong>生成新图层</strong>的话需要满足以下任意一个条件。</li>\n<li>拥有图层上下文属性（z-index，position，opacity等）</li>\n<li>需要裁剪的地方也会生成新图层</li>\n</ul>\n<p><em>关于什么是裁剪，比如我们写了一个dom，给了固定宽高，里面的内容超出了它的大小，这时候它的内容就会被渲染引擎裁剪一部分显示在dom中</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>111111111111111111<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">div</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">overflow</span>: auto;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png\">https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png</a> =500x)</p>\n<h2 id=\"5-绘制\"><a href=\"#5-绘制\" class=\"headerlink\" title=\"5.绘制\"></a>5.绘制</h2><p>图层树构建完成后，渲染引擎会对每个图层进行绘制。渲染引擎会先把一个图层的绘制内容分成多个部分，将其组成一个绘制列表。我们可以通过控制台的Layers，选择对应的图层查看其绘制列表和过程<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png\">https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png</a> =700x)</p>\n<h2 id=\"6-分块\"><a href=\"#6-分块\" class=\"headerlink\" title=\"6.分块\"></a>6.分块</h2><p>绘制列表只是用于记录绘制顺序和指令，实际上做绘制的是渲染引擎中的合成线程操作的。主线程中绘制列表准备好后会将其提交给合成线程。<br>合成线程首先会将图层进行<strong>分块</strong>，因为<strong>一个页面往往一个屏幕的可见区域是装不下的，浏览器没必要一次性将整个图层绘制出来，这时候就会先将其分块</strong>。合成线程再优先对可见区域附近的图块进行绘制生成位图（<em>是由像素的单个点组成的图像</em>）。</p>\n<h2 id=\"7-光栅化\"><a href=\"#7-光栅化\" class=\"headerlink\" title=\"7.光栅化\"></a>7.光栅化</h2><p><strong>实际生成位图的操作是由栅格化来执行的</strong>。所谓栅格化，是指将图块转换为位图。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。<br>栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。<br>GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png\">https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png</a> =500x)</p>\n<h2 id=\"8-合成\"><a href=\"#8-合成\" class=\"headerlink\" title=\"8.合成\"></a>8.合成</h2><p>一旦所有图块都栅格化完成，合成线程（渲染进程）就会生成一个DrawQuad命令告知浏览器进程，浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。至此渲染流程完毕。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>整个渲染流程可以概括如下<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png\">https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png</a> =500x)</p>\n<ul>\n<li>1.渲染进程将HTML转换为DOM树。</li>\n<li>2.渲染引擎将CSS转化为styleSheets，计算出DOM节点的样式。</li>\n<li>3.创建布局树，并计算元素的布局信息。</li>\n<li>4.对布局树进行分层，并生成分层树。</li>\n<li>5.为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>7.合成线程发送绘制图块命令DrawQuad给浏览器进程。</li>\n<li>8.浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h4 id=\"回流重绘\"><a href=\"#回流重绘\" class=\"headerlink\" title=\"回流重绘\"></a>回流重绘</h4><p>回到我们老生常谈的<strong>回流，重绘</strong>。在了解了页面的渲染流程之后相信会对回流重绘会有更好的理解。<br>当我们修改了dom的宽高导致回流，需要更新完整的渲染流水线，所以开销也是最大的。从整个流程上来看，它<strong>不需要进行构建dom树，而是从构建styleSheets这一步修改其更改的样式后继续走完整个渲染流程</strong>，而重绘呢。<br>当我们修改了dom的颜色导致重绘，渲染流程也不需要重新构建dom树，但还是会修改styleSheets，但是由于没有<strong>改变dom的几何属性会跳过布局阶段，再走完成功渲染流程，所以其消耗比回流小</strong>。</p>\n<h4 id=\"合成\"><a href=\"#合成\" class=\"headerlink\" title=\"合成\"></a>合成</h4><p>除了回流重绘，还有一种操作叫做合成。它不需要绘制与合成，所以渲染引擎将跳过布局跟绘制，执行最后的合成操作即可。当我们在css中使用了transform便可以达到这种效果，直接在非主线程上执行合成动画操作。<strong>所以相对于重绘和重排，合成能大大提升绘制效率</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器通过网络进程，如果最后解析到的数据格式是<strong>text/html</strong>，那么浏览器则会继续进行渲染流程。<br>每一个页面回对应一个渲染进程，每打开一个页面浏览器就会配套一个新的渲染进程。当渲染进程拿到浏览器进程传过来的数据后就可以开始进行渲染了。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png\">https://img-blog.csdnimg.cn/47fdf7818bdb422abcde8703491de812.png</a> =500x)<br>这里我们把渲染进程依据时间顺序分成以下几个步骤。<strong>构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成</strong>。</p>\n<h2 id=\"1-构建dom树\"><a href=\"#1-构建dom树\" class=\"headerlink\" title=\"1.构建dom树\"></a>1.构建dom树</h2><p>浏览器无法直接理解html，所以需要将html转换成浏览器能够理解的结构，即dom树。</p>\n<h2 id=\"2-计算样式\"><a href=\"#2-计算样式\" class=\"headerlink\" title=\"2.计算样式\"></a>2.计算样式</h2><p>计算样式的目的是得到dom节点中每个元素的样式，需要以下几步。</p>\n<ul>\n<li>将css转换成浏览器能理解的结构，styleSheets。</li>\n<li>转换样式表中的属性值，使其标准化。</li>\n<li>计算出dom节点中每个元素的样式。</li>\n</ul>\n<p>关于如何计算出dom节点中每个元素的样式，这涉及到<strong>CSS的继承规则和层叠规则</strong>了。<br>首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式，就像下图中的content_views，除了本身的样式，还继承了父节点的样式。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png\">https://img-blog.csdnimg.cn/0600a760dd4046e899c0f572ff107fad.png</a> =500x)<br>至于层叠，层叠是CSS的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。<br>我们可以在浏览器控制台element的Computed中看到对应dom最后计算得到的样式。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png\">https://img-blog.csdnimg.cn/23bbcd8579cd432dbd42ec72efe53f2d.png</a> =500x)</p>\n<h2 id=\"3-布局阶段\"><a href=\"#3-布局阶段\" class=\"headerlink\" title=\"3.布局阶段\"></a>3.布局阶段</h2><p>有了dom树跟对应的样式，接下来需要计算出dom树中可见元素的位置，这个动作就是布局。</p>\n<h4 id=\"创建布局树\"><a href=\"#创建布局树\" class=\"headerlink\" title=\"创建布局树\"></a>创建布局树</h4><p>在页面中，不是所有dom节点都能看见的，像head，script，meta以及display:none的节点等。所以在显示之前，我们还要额外地构建一棵只<strong>包含可见元素布局树</strong>。<br>为了构建布局树，浏览器大体上完成了下面这些工作：</p>\n<ul>\n<li>遍历DOM树中的所有可见节点，并把这些节点加到布局中；</li>\n<li>而不可见的节点会被布局树忽略掉；<h4 id=\"计算布局\"><a href=\"#计算布局\" class=\"headerlink\" title=\"计算布局\"></a>计算布局</h4>在执行布局操作的时候，会把布局运算的结果重新写回布局树中。每个元素的具体位置信息。<h2 id=\"4-分层\"><a href=\"#4-分层\" class=\"headerlink\" title=\"4.分层\"></a>4.分层</h2>页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，z-index等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树。</strong><br>通过控制台的Layers，可以清晰地看到页面带分层。<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png\">https://img-blog.csdnimg.cn/1107ab5034e345d78f92493977c29539.png</a> =500x)<br>可见浏览器的页面实际上被分成了多个层面，最后叠加成我们最后看到的页面。<br>布局树跟图层树的关系如下<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png\">https://img-blog.csdnimg.cn/f68688e9538e4dd9bf664005bef5aef9.png</a> =700x)<br>一般情况下，不是每个节点都会包含一个图层，某个节点如果没有自己的图层那么它就会丛书父节点的图层，像上图中的span。想要<strong>生成新图层</strong>的话需要满足以下任意一个条件。</li>\n<li>拥有图层上下文属性（z-index，position，opacity等）</li>\n<li>需要裁剪的地方也会生成新图层</li>\n</ul>\n<p><em>关于什么是裁剪，比如我们写了一个dom，给了固定宽高，里面的内容超出了它的大小，这时候它的内容就会被渲染引擎裁剪一部分显示在dom中</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>111111111111111111<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-tag\">div</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"attribute\">overflow</span>: auto;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png\">https://img-blog.csdnimg.cn/0cf2d55a962a4defbeb848257a36716f.png</a> =500x)</p>\n<h2 id=\"5-绘制\"><a href=\"#5-绘制\" class=\"headerlink\" title=\"5.绘制\"></a>5.绘制</h2><p>图层树构建完成后，渲染引擎会对每个图层进行绘制。渲染引擎会先把一个图层的绘制内容分成多个部分，将其组成一个绘制列表。我们可以通过控制台的Layers，选择对应的图层查看其绘制列表和过程<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png\">https://img-blog.csdnimg.cn/0655d515a2814a70abf6e412ce6ae366.png</a> =700x)</p>\n<h2 id=\"6-分块\"><a href=\"#6-分块\" class=\"headerlink\" title=\"6.分块\"></a>6.分块</h2><p>绘制列表只是用于记录绘制顺序和指令，实际上做绘制的是渲染引擎中的合成线程操作的。主线程中绘制列表准备好后会将其提交给合成线程。<br>合成线程首先会将图层进行<strong>分块</strong>，因为<strong>一个页面往往一个屏幕的可见区域是装不下的，浏览器没必要一次性将整个图层绘制出来，这时候就会先将其分块</strong>。合成线程再优先对可见区域附近的图块进行绘制生成位图（<em>是由像素的单个点组成的图像</em>）。</p>\n<h2 id=\"7-光栅化\"><a href=\"#7-光栅化\" class=\"headerlink\" title=\"7.光栅化\"></a>7.光栅化</h2><p><strong>实际生成位图的操作是由栅格化来执行的</strong>。所谓栅格化，是指将图块转换为位图。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。<br>栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。<br>GPU操作是运行在GPU进程中，如果栅格化操作使用了GPU，那么最终生成位图的操作是在GPU中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png\">https://img-blog.csdnimg.cn/be3acee75f584d1a8c86452dc0ce2036.png</a> =500x)</p>\n<h2 id=\"8-合成\"><a href=\"#8-合成\" class=\"headerlink\" title=\"8.合成\"></a>8.合成</h2><p>一旦所有图块都栅格化完成，合成线程（渲染进程）就会生成一个DrawQuad命令告知浏览器进程，浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。至此渲染流程完毕。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>整个渲染流程可以概括如下<br>![在这里插入图片描述](<a href=\"https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png\">https://img-blog.csdnimg.cn/7b725ff5019c437fa4fc37a246c3fb2a.png</a> =500x)</p>\n<ul>\n<li>1.渲染进程将HTML转换为DOM树。</li>\n<li>2.渲染引擎将CSS转化为styleSheets，计算出DOM节点的样式。</li>\n<li>3.创建布局树，并计算元素的布局信息。</li>\n<li>4.对布局树进行分层，并生成分层树。</li>\n<li>5.为每个图层生成绘制列表，并将其提交到合成线程。</li>\n<li>6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li>\n<li>7.合成线程发送绘制图块命令DrawQuad给浏览器进程。</li>\n<li>8.浏览器进程根据DrawQuad消息生成页面，并显示到显示器上。</li>\n</ul>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><h4 id=\"回流重绘\"><a href=\"#回流重绘\" class=\"headerlink\" title=\"回流重绘\"></a>回流重绘</h4><p>回到我们老生常谈的<strong>回流，重绘</strong>。在了解了页面的渲染流程之后相信会对回流重绘会有更好的理解。<br>当我们修改了dom的宽高导致回流，需要更新完整的渲染流水线，所以开销也是最大的。从整个流程上来看，它<strong>不需要进行构建dom树，而是从构建styleSheets这一步修改其更改的样式后继续走完整个渲染流程</strong>，而重绘呢。<br>当我们修改了dom的颜色导致重绘，渲染流程也不需要重新构建dom树，但还是会修改styleSheets，但是由于没有<strong>改变dom的几何属性会跳过布局阶段，再走完成功渲染流程，所以其消耗比回流小</strong>。</p>\n<h4 id=\"合成\"><a href=\"#合成\" class=\"headerlink\" title=\"合成\"></a>合成</h4><p>除了回流重绘，还有一种操作叫做合成。它不需要绘制与合成，所以渲染引擎将跳过布局跟绘制，执行最后的合成操作即可。当我们在css中使用了transform便可以达到这种效果，直接在非主线程上执行合成动画操作。<strong>所以相对于重绘和重排，合成能大大提升绘制效率</strong>。</p>\n"},{"title":"几个常见的时间复杂度","date":"2023-02-01T03:33:02.000Z","description":"介绍几个常见的事件复杂度","_content":"# 1.时间复杂度定义\n算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n简单来说就是**执行算法所需要的计算工作量**\n\n# 2.计算时间复杂度\n## O(1)\n```javascript\nfunction fn1(){\n\tconsole.log(1)\n\tconsole.log(2)\n}\n```\n函数fn1运行的时候执行了两次console，所以它的时间复杂度是2，用O表示为O(2)，但对于**常数**项往往可以忽略不计，所以我们一般将**常数项计算为1，就算是O(100)我们时间复杂度也用O(1)表示**。\n## O(n)\n\n```javascript\nfunction fn2(n){\n\tfor(let i =0;i<n;i++){\n\t\tconsole.log(n)\n\t}\n}\n```\n函数fn2执行的时候，首先for中的``let i  = 0 ``执行了一次，接着执行``i < 0``，然后执行console，再执行``i++``，以此类推到最后，``i<0``将执行**n+1次**，``console``将执行**n次**，``i++``执行**n次**，加上一开始的``let i = 0``，一共是**1+n+1+n+n = 3n+2次**，即**O(n)=常数*n+常数**，当n达到一定数量后，第二部分的常数可以忽略不计，即**O(n)=常数*n**，将剩下的常数当作该系数的常数作为1，**得到最终时间复杂度O(n)**\n## O($n^2$)\n```javascript\nfunction fn3(n){\n\tfor(let i = 0; i < n;i ++){\n\t\tfor(let i = 0; i < n; i++){\n\t\t\tconsole.log(n)\n\t\t}\n\t}\n}\n```\n根据上面的方法，我们可以推断出fn3的执行时间为$1+n+1+n+n\\times(1+n+1+n+1) =2n^2+5n+2$，根据刚提到的省略常量，以及将系数作为1处理则得到$n^2  +n$，当n达到一定值时，**相对于$n^2$，n可忽略所以最终得到时间复杂度为O($n^2$)，当执行次数出现多个幂时，则取最高的，如$n^3+n^4+n^5+5$，则取$n^5$即可**\n## O(log$2^n$)\n```javascript\nfunction fn4(n){\n\tfor(let i =1; i < n; i*=2){\n\t\tconsole.log(n)\n\t}\n}\n```\nfn4当传入参数n为8时，首先i = 1，小于8成立，执行循环体内代码1次，i * 2 = 2，小于8继续成立，循环体内代码执行次数加一，i *2 = 4，小于8成立继续，循环体内执行第3次，接着i *2 = 8，小于8不成立循环结束，一共执行了3次。得到**O(8) =3**\n**$2^3 = 8$，$3 = log2^8$**，由此可得到$O(8) = log2^8$","source":"_posts/几个常见的事件复杂度.md","raw":"---\ntitle: 几个常见的时间复杂度\ndate: 2023-02-01 11:33:02\ntags: 算法\ndescription: 介绍几个常见的事件复杂度\n---\n# 1.时间复杂度定义\n算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。\n简单来说就是**执行算法所需要的计算工作量**\n\n# 2.计算时间复杂度\n## O(1)\n```javascript\nfunction fn1(){\n\tconsole.log(1)\n\tconsole.log(2)\n}\n```\n函数fn1运行的时候执行了两次console，所以它的时间复杂度是2，用O表示为O(2)，但对于**常数**项往往可以忽略不计，所以我们一般将**常数项计算为1，就算是O(100)我们时间复杂度也用O(1)表示**。\n## O(n)\n\n```javascript\nfunction fn2(n){\n\tfor(let i =0;i<n;i++){\n\t\tconsole.log(n)\n\t}\n}\n```\n函数fn2执行的时候，首先for中的``let i  = 0 ``执行了一次，接着执行``i < 0``，然后执行console，再执行``i++``，以此类推到最后，``i<0``将执行**n+1次**，``console``将执行**n次**，``i++``执行**n次**，加上一开始的``let i = 0``，一共是**1+n+1+n+n = 3n+2次**，即**O(n)=常数*n+常数**，当n达到一定数量后，第二部分的常数可以忽略不计，即**O(n)=常数*n**，将剩下的常数当作该系数的常数作为1，**得到最终时间复杂度O(n)**\n## O($n^2$)\n```javascript\nfunction fn3(n){\n\tfor(let i = 0; i < n;i ++){\n\t\tfor(let i = 0; i < n; i++){\n\t\t\tconsole.log(n)\n\t\t}\n\t}\n}\n```\n根据上面的方法，我们可以推断出fn3的执行时间为$1+n+1+n+n\\times(1+n+1+n+1) =2n^2+5n+2$，根据刚提到的省略常量，以及将系数作为1处理则得到$n^2  +n$，当n达到一定值时，**相对于$n^2$，n可忽略所以最终得到时间复杂度为O($n^2$)，当执行次数出现多个幂时，则取最高的，如$n^3+n^4+n^5+5$，则取$n^5$即可**\n## O(log$2^n$)\n```javascript\nfunction fn4(n){\n\tfor(let i =1; i < n; i*=2){\n\t\tconsole.log(n)\n\t}\n}\n```\nfn4当传入参数n为8时，首先i = 1，小于8成立，执行循环体内代码1次，i * 2 = 2，小于8继续成立，循环体内代码执行次数加一，i *2 = 4，小于8成立继续，循环体内执行第3次，接着i *2 = 8，小于8不成立循环结束，一共执行了3次。得到**O(8) =3**\n**$2^3 = 8$，$3 = log2^8$**，由此可得到$O(8) = log2^8$","slug":"几个常见的事件复杂度","published":1,"updated":"2023-02-01T03:40:02.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh6000aywnke5wr939o","content":"<h1 id=\"1-时间复杂度定义\"><a href=\"#1-时间复杂度定义\" class=\"headerlink\" title=\"1.时间复杂度定义\"></a>1.时间复杂度定义</h1><p>算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。<br>简单来说就是<strong>执行算法所需要的计算工作量</strong></p>\n<h1 id=\"2-计算时间复杂度\"><a href=\"#2-计算时间复杂度\" class=\"headerlink\" title=\"2.计算时间复杂度\"></a>2.计算时间复杂度</h1><h2 id=\"O-1\"><a href=\"#O-1\" class=\"headerlink\" title=\"O(1)\"></a>O(1)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数fn1运行的时候执行了两次console，所以它的时间复杂度是2，用O表示为O(2)，但对于<strong>常数</strong>项往往可以忽略不计，所以我们一般将<strong>常数项计算为1，就算是O(100)我们时间复杂度也用O(1)表示</strong>。</p>\n<h2 id=\"O-n\"><a href=\"#O-n\" class=\"headerlink\" title=\"O(n)\"></a>O(n)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn2</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数fn2执行的时候，首先for中的<code>let i  = 0 </code>执行了一次，接着执行<code>i &lt; 0</code>，然后执行console，再执行<code>i++</code>，以此类推到最后，<code>i&lt;0</code>将执行<strong>n+1次</strong>，<code>console</code>将执行<strong>n次</strong>，<code>i++</code>执行<strong>n次</strong>，加上一开始的<code>let i = 0</code>，一共是<strong>1+n+1+n+n = 3n+2次</strong>，即<strong>O(n)=常数*n+常数</strong>，当n达到一定数量后，第二部分的常数可以忽略不计，即<strong>O(n)=常数*n</strong>，将剩下的常数当作该系数的常数作为1，<strong>得到最终时间复杂度O(n)</strong></p>\n<h2 id=\"O-n-2\"><a href=\"#O-n-2\" class=\"headerlink\" title=\"O($n^2$)\"></a>O($n^2$)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn3</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n;i ++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的方法，我们可以推断出fn3的执行时间为$1+n+1+n+n\\times(1+n+1+n+1) =2n^2+5n+2$，根据刚提到的省略常量，以及将系数作为1处理则得到$n^2  +n$，当n达到一定值时，<strong>相对于$n^2$，n可忽略所以最终得到时间复杂度为O($n^2$)，当执行次数出现多个幂时，则取最高的，如$n^3+n^4+n^5+5$，则取$n^5$即可</strong></p>\n<h2 id=\"O-log-2-n\"><a href=\"#O-log-2-n\" class=\"headerlink\" title=\"O(log$2^n$)\"></a>O(log$2^n$)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn4</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">1</span>; i &lt; n; i*=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fn4当传入参数n为8时，首先i = 1，小于8成立，执行循环体内代码1次，i * 2 = 2，小于8继续成立，循环体内代码执行次数加一，i <em>2 = 4，小于8成立继续，循环体内执行第3次，接着i <em>2 = 8，小于8不成立循环结束，一共执行了3次。得到**O(8) =3</em></em><br>**$2^3 = 8$，$3 = log2^8$**，由此可得到$O(8) = log2^8$</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-时间复杂度定义\"><a href=\"#1-时间复杂度定义\" class=\"headerlink\" title=\"1.时间复杂度定义\"></a>1.时间复杂度定义</h1><p>算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。<br>简单来说就是<strong>执行算法所需要的计算工作量</strong></p>\n<h1 id=\"2-计算时间复杂度\"><a href=\"#2-计算时间复杂度\" class=\"headerlink\" title=\"2.计算时间复杂度\"></a>2.计算时间复杂度</h1><h2 id=\"O-1\"><a href=\"#O-1\" class=\"headerlink\" title=\"O(1)\"></a>O(1)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数fn1运行的时候执行了两次console，所以它的时间复杂度是2，用O表示为O(2)，但对于<strong>常数</strong>项往往可以忽略不计，所以我们一般将<strong>常数项计算为1，就算是O(100)我们时间复杂度也用O(1)表示</strong>。</p>\n<h2 id=\"O-n\"><a href=\"#O-n\" class=\"headerlink\" title=\"O(n)\"></a>O(n)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn2</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数fn2执行的时候，首先for中的<code>let i  = 0 </code>执行了一次，接着执行<code>i &lt; 0</code>，然后执行console，再执行<code>i++</code>，以此类推到最后，<code>i&lt;0</code>将执行<strong>n+1次</strong>，<code>console</code>将执行<strong>n次</strong>，<code>i++</code>执行<strong>n次</strong>，加上一开始的<code>let i = 0</code>，一共是<strong>1+n+1+n+n = 3n+2次</strong>，即<strong>O(n)=常数*n+常数</strong>，当n达到一定数量后，第二部分的常数可以忽略不计，即<strong>O(n)=常数*n</strong>，将剩下的常数当作该系数的常数作为1，<strong>得到最终时间复杂度O(n)</strong></p>\n<h2 id=\"O-n-2\"><a href=\"#O-n-2\" class=\"headerlink\" title=\"O($n^2$)\"></a>O($n^2$)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn3</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n;i ++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的方法，我们可以推断出fn3的执行时间为$1+n+1+n+n\\times(1+n+1+n+1) =2n^2+5n+2$，根据刚提到的省略常量，以及将系数作为1处理则得到$n^2  +n$，当n达到一定值时，<strong>相对于$n^2$，n可忽略所以最终得到时间复杂度为O($n^2$)，当执行次数出现多个幂时，则取最高的，如$n^3+n^4+n^5+5$，则取$n^5$即可</strong></p>\n<h2 id=\"O-log-2-n\"><a href=\"#O-log-2-n\" class=\"headerlink\" title=\"O(log$2^n$)\"></a>O(log$2^n$)</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn4</span>(<span class=\"params\">n</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i =<span class=\"number\">1</span>; i &lt; n; i*=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>fn4当传入参数n为8时，首先i = 1，小于8成立，执行循环体内代码1次，i * 2 = 2，小于8继续成立，循环体内代码执行次数加一，i <em>2 = 4，小于8成立继续，循环体内执行第3次，接着i <em>2 = 8，小于8不成立循环结束，一共执行了3次。得到**O(8) =3</em></em><br>**$2^3 = 8$，$3 = log2^8$**，由此可得到$O(8) = log2^8$</p>\n"},{"title":"用Webpack搭建一个React项目","date":"2023-01-31T08:14:12.000Z","description":"手把手展示如何用webpack搭建一个react项目......","_content":"# 先搭建一个简单的项目\n## 初始化\n\ncmd输入npm init，设置相关信息初始化项目。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621210211102.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621210251849.png)\n\n<!--more-->\n## 安装所需的依赖\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621211133316.png)\n## 新建文件webpack.config.js配置出入口以及module\n```javascript\nconst path = require('path')\nmodule.exports = {\n    entry: '/src/index.js',\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [{\n            test: /\\.(js|jsx)$/,\n            exclude: /node_modules/,\n            use: ['babel-loader'],\n            include: path.resolve(__dirname, 'src')\n        }]\n    }\n}\n```\n在对应的目录下新建一个index.js作为入口文件并编辑以下代码作为示范\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062121184932.png)\n```javascript\n//index.js代码\ndocument.getElementById('main').innerText = 'my react'\n```\n## 打包并引入\n在终端执行webpack命令，或在package.json配置命令并执行进行打包\n打包成功后对应目录下会生成打包后的文件，在html文件内引入打包生成的bundle.js进行验证\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062121240835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0MDc0NA==,size_16,color_FFFFFF,t_70)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"main\"></div>\n</body>\n<script src=\"../dist/bundle.js\"></script>\n</html>\n```\n运行发现引入成功了，这时候一个由webpack搭建的简单项目已经成功了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621212743254.png)\n\n## 开始引入react\n安装react，react-dom\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621213659995.png)\n编写react\n```javascript\nimport React from 'react'\nimport ReactDom from 'react-dom'\nReactDom.render(\n    <div>Hi React</div>,document.getElementById('main')\n)\n```\n执行webpack打包，编译报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621213940965.png)\n这里无法识别react代码，还需要配置babel，分别安装@babel/preset-react，babel-plugin-transform-react-remove-prop-types并新建一个.babelrc进行配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214258746.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214409518.png)\n\n```javascript\n{\n    \"presets\": [\n        \"@babel/preset-react\"\n    ],\n    \"plugins\": [\n        \"transform-react-remove-prop-types\"\n    ]\n}\n```\n再执行webpack打包，打包成功后打开引入js的html，发现成功了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214624998.png)\n\n","source":"_posts/用Webpack搭建一个React项目.md","raw":"---\ntitle: 用Webpack搭建一个React项目\ndate: 2023-01-31 16:14:12\ntag: 工程化\ndescription: 手把手展示如何用webpack搭建一个react项目......\n---\n# 先搭建一个简单的项目\n## 初始化\n\ncmd输入npm init，设置相关信息初始化项目。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621210211102.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621210251849.png)\n\n<!--more-->\n## 安装所需的依赖\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621211133316.png)\n## 新建文件webpack.config.js配置出入口以及module\n```javascript\nconst path = require('path')\nmodule.exports = {\n    entry: '/src/index.js',\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js'\n    },\n    module: {\n        rules: [{\n            test: /\\.(js|jsx)$/,\n            exclude: /node_modules/,\n            use: ['babel-loader'],\n            include: path.resolve(__dirname, 'src')\n        }]\n    }\n}\n```\n在对应的目录下新建一个index.js作为入口文件并编辑以下代码作为示范\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062121184932.png)\n```javascript\n//index.js代码\ndocument.getElementById('main').innerText = 'my react'\n```\n## 打包并引入\n在终端执行webpack命令，或在package.json配置命令并执行进行打包\n打包成功后对应目录下会生成打包后的文件，在html文件内引入打包生成的bundle.js进行验证\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062121240835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0MDc0NA==,size_16,color_FFFFFF,t_70)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"main\"></div>\n</body>\n<script src=\"../dist/bundle.js\"></script>\n</html>\n```\n运行发现引入成功了，这时候一个由webpack搭建的简单项目已经成功了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621212743254.png)\n\n## 开始引入react\n安装react，react-dom\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621213659995.png)\n编写react\n```javascript\nimport React from 'react'\nimport ReactDom from 'react-dom'\nReactDom.render(\n    <div>Hi React</div>,document.getElementById('main')\n)\n```\n执行webpack打包，编译报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621213940965.png)\n这里无法识别react代码，还需要配置babel，分别安装@babel/preset-react，babel-plugin-transform-react-remove-prop-types并新建一个.babelrc进行配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214258746.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214409518.png)\n\n```javascript\n{\n    \"presets\": [\n        \"@babel/preset-react\"\n    ],\n    \"plugins\": [\n        \"transform-react-remove-prop-types\"\n    ]\n}\n```\n再执行webpack打包，打包成功后打开引入js的html，发现成功了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621214624998.png)\n\n","slug":"用Webpack搭建一个React项目","published":1,"updated":"2023-02-01T03:27:52.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh8000dywnkdnjy300p","content":"<h1 id=\"先搭建一个简单的项目\"><a href=\"#先搭建一个简单的项目\" class=\"headerlink\" title=\"先搭建一个简单的项目\"></a>先搭建一个简单的项目</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>cmd输入npm init，设置相关信息初始化项目。<br><img src=\"https://img-blog.csdnimg.cn/20210621210211102.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210621210251849.png\" alt=\"在这里插入图片描述\"></p>\n<span id=\"more\"></span>\n<h2 id=\"安装所需的依赖\"><a href=\"#安装所需的依赖\" class=\"headerlink\" title=\"安装所需的依赖\"></a>安装所需的依赖</h2><p><img src=\"https://img-blog.csdnimg.cn/20210621211133316.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"新建文件webpack-config-js配置出入口以及module\"><a href=\"#新建文件webpack-config-js配置出入口以及module\" class=\"headerlink\" title=\"新建文件webpack.config.js配置出入口以及module\"></a>新建文件webpack.config.js配置出入口以及module</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;/src/index.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;bundle.js&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [&#123;</span><br><span class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(js|jsx)$/</span>,</span><br><span class=\"line\">            <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;babel-loader&#x27;</span>],</span><br><span class=\"line\">            <span class=\"attr\">include</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在对应的目录下新建一个index.js作为入口文件并编辑以下代码作为示范<br><img src=\"https://img-blog.csdnimg.cn/2021062121184932.png\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js代码</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;main&#x27;</span>).<span class=\"property\">innerText</span> = <span class=\"string\">&#x27;my react&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"打包并引入\"><a href=\"#打包并引入\" class=\"headerlink\" title=\"打包并引入\"></a>打包并引入</h2><p>在终端执行webpack命令，或在package.json配置命令并执行进行打包<br>打包成功后对应目录下会生成打包后的文件，在html文件内引入打包生成的bundle.js进行验证<br><img src=\"https://img-blog.csdnimg.cn/2021062121240835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0MDc0NA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;main&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行发现引入成功了，这时候一个由webpack搭建的简单项目已经成功了<br><img src=\"https://img-blog.csdnimg.cn/20210621212743254.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"开始引入react\"><a href=\"#开始引入react\" class=\"headerlink\" title=\"开始引入react\"></a>开始引入react</h2><p>安装react，react-dom<br><img src=\"https://img-blog.csdnimg.cn/20210621213659995.png\" alt=\"在这里插入图片描述\"><br>编写react</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ReactDom</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">ReactDom</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi React<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>,<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>执行webpack打包，编译报错<br><img src=\"https://img-blog.csdnimg.cn/20210621213940965.png\" alt=\"在这里插入图片描述\"><br>这里无法识别react代码，还需要配置babel，分别安装@babel/preset-react，babel-plugin-transform-react-remove-prop-types并新建一个.babelrc进行配置<br><img src=\"https://img-blog.csdnimg.cn/20210621214258746.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210621214409518.png\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;@babel/preset-react&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;transform-react-remove-prop-types&quot;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再执行webpack打包，打包成功后打开引入js的html，发现成功了<br><img src=\"https://img-blog.csdnimg.cn/20210621214624998.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"先搭建一个简单的项目\"><a href=\"#先搭建一个简单的项目\" class=\"headerlink\" title=\"先搭建一个简单的项目\"></a>先搭建一个简单的项目</h1><h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p>cmd输入npm init，设置相关信息初始化项目。<br><img src=\"https://img-blog.csdnimg.cn/20210621210211102.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210621210251849.png\" alt=\"在这里插入图片描述\"></p>","more":"<h2 id=\"安装所需的依赖\"><a href=\"#安装所需的依赖\" class=\"headerlink\" title=\"安装所需的依赖\"></a>安装所需的依赖</h2><p><img src=\"https://img-blog.csdnimg.cn/20210621211133316.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"新建文件webpack-config-js配置出入口以及module\"><a href=\"#新建文件webpack-config-js配置出入口以及module\" class=\"headerlink\" title=\"新建文件webpack.config.js配置出入口以及module\"></a>新建文件webpack.config.js配置出入口以及module</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;/src/index.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">path</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>),</span><br><span class=\"line\">        <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;bundle.js&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">module</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">rules</span>: [&#123;</span><br><span class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(js|jsx)$/</span>,</span><br><span class=\"line\">            <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">            <span class=\"attr\">use</span>: [<span class=\"string\">&#x27;babel-loader&#x27;</span>],</span><br><span class=\"line\">            <span class=\"attr\">include</span>: path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;src&#x27;</span>)</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在对应的目录下新建一个index.js作为入口文件并编辑以下代码作为示范<br><img src=\"https://img-blog.csdnimg.cn/2021062121184932.png\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//index.js代码</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;main&#x27;</span>).<span class=\"property\">innerText</span> = <span class=\"string\">&#x27;my react&#x27;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"打包并引入\"><a href=\"#打包并引入\" class=\"headerlink\" title=\"打包并引入\"></a>打包并引入</h2><p>在终端执行webpack命令，或在package.json配置命令并执行进行打包<br>打包成功后对应目录下会生成打包后的文件，在html文件内引入打包生成的bundle.js进行验证<br><img src=\"https://img-blog.csdnimg.cn/2021062121240835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI0MDc0NA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;main&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../dist/bundle.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>运行发现引入成功了，这时候一个由webpack搭建的简单项目已经成功了<br><img src=\"https://img-blog.csdnimg.cn/20210621212743254.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"开始引入react\"><a href=\"#开始引入react\" class=\"headerlink\" title=\"开始引入react\"></a>开始引入react</h2><p>安装react，react-dom<br><img src=\"https://img-blog.csdnimg.cn/20210621213659995.png\" alt=\"在这里插入图片描述\"><br>编写react</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">ReactDom</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-dom&#x27;</span></span><br><span class=\"line\"><span class=\"title class_\">ReactDom</span>.<span class=\"title function_\">render</span>(</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi React<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>,<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;main&#x27;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>执行webpack打包，编译报错<br><img src=\"https://img-blog.csdnimg.cn/20210621213940965.png\" alt=\"在这里插入图片描述\"><br>这里无法识别react代码，还需要配置babel，分别安装@babel/preset-react，babel-plugin-transform-react-remove-prop-types并新建一个.babelrc进行配置<br><img src=\"https://img-blog.csdnimg.cn/20210621214258746.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20210621214409518.png\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;@babel/preset-react&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">&quot;plugins&quot;</span>: [</span><br><span class=\"line\">        <span class=\"string\">&quot;transform-react-remove-prop-types&quot;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再执行webpack打包，打包成功后打开引入js的html，发现成功了<br><img src=\"https://img-blog.csdnimg.cn/20210621214624998.png\" alt=\"在这里插入图片描述\"></p>"},{"title":"用node实现cors跨域","date":"2023-02-01T03:35:59.000Z","description":"用node去实现cors解决跨域......","_content":"# 1. 关于跨域\n浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。\n**当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域**\nhttps://(协议)www.baidu.com(主机)8080(端口号)\n早起开发者们为了解决这一问题使用了JSONP的方法进行处理（具体可看[JSONP的原理，以及如何使用node实现](https://blog.csdn.net/weixin_43240744/article/details/124183510?spm=1001.2014.3001.5501)）。但毕竟还是存在很多局限，于是有了cors。\n# 2.CORS\n当浏览器进行跨域请求的时候，会在**请求里添加头部origin，表明自己协议，主机，端口。当服务器收到这个客户端发送的请求之后，如果需要允许能够访问，就需要添加头部信息Access-Control-Arrow-Origin到响应里面。浏览器收到传回来的这个头部信息就知道能不能进行跨域请求了。**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"></script>\n<script>\n  $.ajax({ type: \"get\", url: \"http://127.0.0.1:8888/get\" }).then(\n    (data) => {\n      console.log(data);\n    }\n  );\n</script>\n```\n```javascript\nlet http = require('http')\nlet server = http.createServer()\nserver.listen(8888)\nserver.on('request', (req, res) => {\n    var result = {\n          code: 0,\n          msg: \"请求成功\"\n      }\n      res.end(JSON.stringify(result))\n})\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7f023ab315dc4493a1aa85638f21d1fd.png)\n我们在8080端口中运行一个html并且对8888端口的服务器发起请求，由于两者不在同一个端口所以发生了跨域。这段报错的意思是没有发现Access-Control-Arrow-Origin这个请求头，我们在Network里面也确实没发现这个头部。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/af6fb1d47f1c44debaec5d5c5333703e.png)\n针对这种情况，我们可以通过设置请求头Access-Control-Allow-Origin，允许跨域。\n```javascript\nlet server = http.createServer((req, res) => {\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin':'http://127.0.0.1:8080'//可以是*，也可以是跨域的地址\n    })\n})\n```\n这时我们再去发起请求，可以看到响应头中的Access-Control-Allow-Origin属性，指向我们的客户端地址，这里我们也可以设置*即允许所有地址。并且我们这里也不再发生跨域的错误了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7e59f6b1d5b74dc08041a8a6923adb3d.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/96cdde35da8d447581ec35c0dac56e19.png)\n### 其他请求方式\n如果我们将请求方式换成**put**请求会发现，它又发生跨域了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7310fa657eec48438ce926ce62ab0b87.png)\n这是因为浏览器为了**防护用户恶意修改浏览器数据，使用了例如put，delete等方法，我们可以通过设置请求头字段Access-Control-Allow-Methods**，使得浏览器允许这些方法跨域\n```javascript\nlet server = http.createServer((req, res) => {\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': 'http://127.0.0.1:8080',//可以是*，也可以是跨域的地址\n        'Access-Control-Allow-Methods': ['GET', 'POST', 'PUT']\n    })\n})\n```\n这时候再去发起请求就可以正常拿到响应内容了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1ce4db89e5da441f818d46517150be91.png)\n","source":"_posts/用node实现cors跨域.md","raw":"---\ntitle: 用node实现cors跨域\ndate: 2023-02-01 11:35:59\ntags: node\ndescription: 用node去实现cors解决跨域......\n---\n# 1. 关于跨域\n浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。\n**当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域**\nhttps://(协议)www.baidu.com(主机)8080(端口号)\n早起开发者们为了解决这一问题使用了JSONP的方法进行处理（具体可看[JSONP的原理，以及如何使用node实现](https://blog.csdn.net/weixin_43240744/article/details/124183510?spm=1001.2014.3001.5501)）。但毕竟还是存在很多局限，于是有了cors。\n# 2.CORS\n当浏览器进行跨域请求的时候，会在**请求里添加头部origin，表明自己协议，主机，端口。当服务器收到这个客户端发送的请求之后，如果需要允许能够访问，就需要添加头部信息Access-Control-Arrow-Origin到响应里面。浏览器收到传回来的这个头部信息就知道能不能进行跨域请求了。**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"></script>\n<script>\n  $.ajax({ type: \"get\", url: \"http://127.0.0.1:8888/get\" }).then(\n    (data) => {\n      console.log(data);\n    }\n  );\n</script>\n```\n```javascript\nlet http = require('http')\nlet server = http.createServer()\nserver.listen(8888)\nserver.on('request', (req, res) => {\n    var result = {\n          code: 0,\n          msg: \"请求成功\"\n      }\n      res.end(JSON.stringify(result))\n})\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7f023ab315dc4493a1aa85638f21d1fd.png)\n我们在8080端口中运行一个html并且对8888端口的服务器发起请求，由于两者不在同一个端口所以发生了跨域。这段报错的意思是没有发现Access-Control-Arrow-Origin这个请求头，我们在Network里面也确实没发现这个头部。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/af6fb1d47f1c44debaec5d5c5333703e.png)\n针对这种情况，我们可以通过设置请求头Access-Control-Allow-Origin，允许跨域。\n```javascript\nlet server = http.createServer((req, res) => {\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin':'http://127.0.0.1:8080'//可以是*，也可以是跨域的地址\n    })\n})\n```\n这时我们再去发起请求，可以看到响应头中的Access-Control-Allow-Origin属性，指向我们的客户端地址，这里我们也可以设置*即允许所有地址。并且我们这里也不再发生跨域的错误了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7e59f6b1d5b74dc08041a8a6923adb3d.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/96cdde35da8d447581ec35c0dac56e19.png)\n### 其他请求方式\n如果我们将请求方式换成**put**请求会发现，它又发生跨域了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7310fa657eec48438ce926ce62ab0b87.png)\n这是因为浏览器为了**防护用户恶意修改浏览器数据，使用了例如put，delete等方法，我们可以通过设置请求头字段Access-Control-Allow-Methods**，使得浏览器允许这些方法跨域\n```javascript\nlet server = http.createServer((req, res) => {\n    res.writeHead(200, {\n        'Access-Control-Allow-Origin': 'http://127.0.0.1:8080',//可以是*，也可以是跨域的地址\n        'Access-Control-Allow-Methods': ['GET', 'POST', 'PUT']\n    })\n})\n```\n这时候再去发起请求就可以正常拿到响应内容了\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1ce4db89e5da441f818d46517150be91.png)\n","slug":"用node实现cors跨域","published":1,"updated":"2023-02-01T03:47:01.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekh9000eywnkb78hdkjq","content":"<h1 id=\"1-关于跨域\"><a href=\"#1-关于跨域\" class=\"headerlink\" title=\"1. 关于跨域\"></a>1. 关于跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。<br><strong>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</strong><br>https://(协议)<a href=\"http://www.baidu.com(主机)8080(端口号)/\">www.baidu.com(主机)8080(端口号)</a><br>早起开发者们为了解决这一问题使用了JSONP的方法进行处理（具体可看<a href=\"https://blog.csdn.net/weixin_43240744/article/details/124183510?spm=1001.2014.3001.5501\">JSONP的原理，以及如何使用node实现</a>）。但毕竟还是存在很多局限，于是有了cors。</p>\n<h1 id=\"2-CORS\"><a href=\"#2-CORS\" class=\"headerlink\" title=\"2.CORS\"></a>2.CORS</h1><p>当浏览器进行跨域请求的时候，会在<strong>请求里添加头部origin，表明自己协议，主机，端口。当服务器收到这个客户端发送的请求之后，如果需要允许能够访问，就需要添加头部信息Access-Control-Arrow-Origin到响应里面。浏览器收到传回来的这个头部信息就知道能不能进行跨域请求了。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  $.<span class=\"title function_\">ajax</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;get&quot;</span>, <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://127.0.0.1:8888/get&quot;</span> &#125;).<span class=\"title function_\">then</span>(</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  );</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>()</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br><span class=\"line\">server.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;request&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = &#123;</span><br><span class=\"line\">          <span class=\"attr\">code</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">          <span class=\"attr\">msg</span>: <span class=\"string\">&quot;请求成功&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      res.<span class=\"title function_\">end</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(result))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/7f023ab315dc4493a1aa85638f21d1fd.png\" alt=\"在这里插入图片描述\"><br>我们在8080端口中运行一个html并且对8888端口的服务器发起请求，由于两者不在同一个端口所以发生了跨域。这段报错的意思是没有发现Access-Control-Arrow-Origin这个请求头，我们在Network里面也确实没发现这个头部。<br><img src=\"https://img-blog.csdnimg.cn/af6fb1d47f1c44debaec5d5c5333703e.png\" alt=\"在这里插入图片描述\"><br>针对这种情况，我们可以通过设置请求头Access-Control-Allow-Origin，允许跨域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>:<span class=\"string\">&#x27;http://127.0.0.1:8080&#x27;</span><span class=\"comment\">//可以是*，也可以是跨域的地址</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时我们再去发起请求，可以看到响应头中的Access-Control-Allow-Origin属性，指向我们的客户端地址，这里我们也可以设置*即允许所有地址。并且我们这里也不再发生跨域的错误了。<br><img src=\"https://img-blog.csdnimg.cn/7e59f6b1d5b74dc08041a8a6923adb3d.png\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/96cdde35da8d447581ec35c0dac56e19.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"其他请求方式\"><a href=\"#其他请求方式\" class=\"headerlink\" title=\"其他请求方式\"></a>其他请求方式</h3><p>如果我们将请求方式换成<strong>put</strong>请求会发现，它又发生跨域了<br><img src=\"https://img-blog.csdnimg.cn/7310fa657eec48438ce926ce62ab0b87.png\" alt=\"在这里插入图片描述\"><br>这是因为浏览器为了<strong>防护用户恶意修改浏览器数据，使用了例如put，delete等方法，我们可以通过设置请求头字段Access-Control-Allow-Methods</strong>，使得浏览器允许这些方法跨域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class=\"string\">&#x27;http://127.0.0.1:8080&#x27;</span>,<span class=\"comment\">//可以是*，也可以是跨域的地址</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Methods&#x27;</span>: [<span class=\"string\">&#x27;GET&#x27;</span>, <span class=\"string\">&#x27;POST&#x27;</span>, <span class=\"string\">&#x27;PUT&#x27;</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候再去发起请求就可以正常拿到响应内容了<br><img src=\"https://img-blog.csdnimg.cn/1ce4db89e5da441f818d46517150be91.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-关于跨域\"><a href=\"#1-关于跨域\" class=\"headerlink\" title=\"1. 关于跨域\"></a>1. 关于跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。<br><strong>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</strong><br>https://(协议)<a href=\"http://www.baidu.com(主机)8080(端口号)/\">www.baidu.com(主机)8080(端口号)</a><br>早起开发者们为了解决这一问题使用了JSONP的方法进行处理（具体可看<a href=\"https://blog.csdn.net/weixin_43240744/article/details/124183510?spm=1001.2014.3001.5501\">JSONP的原理，以及如何使用node实现</a>）。但毕竟还是存在很多局限，于是有了cors。</p>\n<h1 id=\"2-CORS\"><a href=\"#2-CORS\" class=\"headerlink\" title=\"2.CORS\"></a>2.CORS</h1><p>当浏览器进行跨域请求的时候，会在<strong>请求里添加头部origin，表明自己协议，主机，端口。当服务器收到这个客户端发送的请求之后，如果需要允许能够访问，就需要添加头部信息Access-Control-Arrow-Origin到响应里面。浏览器收到传回来的这个头部信息就知道能不能进行跨域请求了。</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  $.<span class=\"title function_\">ajax</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;get&quot;</span>, <span class=\"attr\">url</span>: <span class=\"string\">&quot;http://127.0.0.1:8888/get&quot;</span> &#125;).<span class=\"title function_\">then</span>(</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span></span><br><span class=\"line\"><span class=\"language-javascript\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">  );</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>()</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br><span class=\"line\">server.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;request&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = &#123;</span><br><span class=\"line\">          <span class=\"attr\">code</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">          <span class=\"attr\">msg</span>: <span class=\"string\">&quot;请求成功&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      res.<span class=\"title function_\">end</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(result))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/7f023ab315dc4493a1aa85638f21d1fd.png\" alt=\"在这里插入图片描述\"><br>我们在8080端口中运行一个html并且对8888端口的服务器发起请求，由于两者不在同一个端口所以发生了跨域。这段报错的意思是没有发现Access-Control-Arrow-Origin这个请求头，我们在Network里面也确实没发现这个头部。<br><img src=\"https://img-blog.csdnimg.cn/af6fb1d47f1c44debaec5d5c5333703e.png\" alt=\"在这里插入图片描述\"><br>针对这种情况，我们可以通过设置请求头Access-Control-Allow-Origin，允许跨域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>:<span class=\"string\">&#x27;http://127.0.0.1:8080&#x27;</span><span class=\"comment\">//可以是*，也可以是跨域的地址</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时我们再去发起请求，可以看到响应头中的Access-Control-Allow-Origin属性，指向我们的客户端地址，这里我们也可以设置*即允许所有地址。并且我们这里也不再发生跨域的错误了。<br><img src=\"https://img-blog.csdnimg.cn/7e59f6b1d5b74dc08041a8a6923adb3d.png\" alt=\"在这里插入图片描述\"><img src=\"https://img-blog.csdnimg.cn/96cdde35da8d447581ec35c0dac56e19.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"其他请求方式\"><a href=\"#其他请求方式\" class=\"headerlink\" title=\"其他请求方式\"></a>其他请求方式</h3><p>如果我们将请求方式换成<strong>put</strong>请求会发现，它又发生跨域了<br><img src=\"https://img-blog.csdnimg.cn/7310fa657eec48438ce926ce62ab0b87.png\" alt=\"在这里插入图片描述\"><br>这是因为浏览器为了<strong>防护用户恶意修改浏览器数据，使用了例如put，delete等方法，我们可以通过设置请求头字段Access-Control-Allow-Methods</strong>，使得浏览器允许这些方法跨域</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.<span class=\"title function_\">writeHead</span>(<span class=\"number\">200</span>, &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class=\"string\">&#x27;http://127.0.0.1:8080&#x27;</span>,<span class=\"comment\">//可以是*，也可以是跨域的地址</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;Access-Control-Allow-Methods&#x27;</span>: [<span class=\"string\">&#x27;GET&#x27;</span>, <span class=\"string\">&#x27;POST&#x27;</span>, <span class=\"string\">&#x27;PUT&#x27;</span>]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>这时候再去发起请求就可以正常拿到响应内容了<br><img src=\"https://img-blog.csdnimg.cn/1ce4db89e5da441f818d46517150be91.png\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"禁止from disk cache","date":"2023-02-01T03:53:27.000Z","description":"浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法......","_content":"\n# 浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\n今天遇到了一个bug，从页面A跳转到页面B的时候提交了一份表单信息使得用户信息发生了变化，但是从页面B返回到页面A的时候，获取到的用户信息还是提交之前的状态。\n后来发现是因为页面发起请求获取信息的时候，直接从浏览器拿了缓存。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a9578e8302e641de91e30b1372e8c14e.png)\n# 什么是from disk cache\nfrom disk cache意思是从磁盘中获取缓存，这是因为请求的时间在缓存的时间长度内（max-age），导致会先从缓存中拿数据，缓存中没有才会向服务器发起请求。它跟304的区别是，304会再跟服务器确认一次数据，确保数据没有变化，而**from disk cache没有跟服务器确认，就直接使用浏览器的缓存。**\n# 解决方法\n1. http关闭缓存\n```javascript\najax.get('/url',{headers:{'Cache-Control':'no-cache'}})\n```\n2. 动态改变请求路径\n```javascript\najax.get(`/url?time=${new Date().getTime()}`)\n```\n使得每次请求的路径都不同，则不会去获取缓存。\t\n","source":"_posts/禁止from disk cache.md","raw":"---\ntitle: 禁止from disk cache\ndate: 2023-02-01 11:53:27\ntags: 其他\ndescription: 浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法......\n---\n\n# 浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\n今天遇到了一个bug，从页面A跳转到页面B的时候提交了一份表单信息使得用户信息发生了变化，但是从页面B返回到页面A的时候，获取到的用户信息还是提交之前的状态。\n后来发现是因为页面发起请求获取信息的时候，直接从浏览器拿了缓存。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a9578e8302e641de91e30b1372e8c14e.png)\n# 什么是from disk cache\nfrom disk cache意思是从磁盘中获取缓存，这是因为请求的时间在缓存的时间长度内（max-age），导致会先从缓存中拿数据，缓存中没有才会向服务器发起请求。它跟304的区别是，304会再跟服务器确认一次数据，确保数据没有变化，而**from disk cache没有跟服务器确认，就直接使用浏览器的缓存。**\n# 解决方法\n1. http关闭缓存\n```javascript\najax.get('/url',{headers:{'Cache-Control':'no-cache'}})\n```\n2. 动态改变请求路径\n```javascript\najax.get(`/url?time=${new Date().getTime()}`)\n```\n使得每次请求的路径都不同，则不会去获取缓存。\t\n","slug":"禁止from disk cache","published":1,"updated":"2023-02-01T06:13:03.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekhb000hywnk7jrp1k07","content":"<h1 id=\"浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\"><a href=\"#浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\" class=\"headerlink\" title=\"浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\"></a>浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？</h1><p>今天遇到了一个bug，从页面A跳转到页面B的时候提交了一份表单信息使得用户信息发生了变化，但是从页面B返回到页面A的时候，获取到的用户信息还是提交之前的状态。<br>后来发现是因为页面发起请求获取信息的时候，直接从浏览器拿了缓存。<br><img src=\"https://img-blog.csdnimg.cn/a9578e8302e641de91e30b1372e8c14e.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"什么是from-disk-cache\"><a href=\"#什么是from-disk-cache\" class=\"headerlink\" title=\"什么是from disk cache\"></a>什么是from disk cache</h1><p>from disk cache意思是从磁盘中获取缓存，这是因为请求的时间在缓存的时间长度内（max-age），导致会先从缓存中拿数据，缓存中没有才会向服务器发起请求。它跟304的区别是，304会再跟服务器确认一次数据，确保数据没有变化，而<strong>from disk cache没有跟服务器确认，就直接使用浏览器的缓存。</strong></p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li>http关闭缓存<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/url&#x27;</span>,&#123;<span class=\"attr\">headers</span>:&#123;<span class=\"string\">&#x27;Cache-Control&#x27;</span>:<span class=\"string\">&#x27;no-cache&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>动态改变请求路径<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax.<span class=\"title function_\">get</span>(<span class=\"string\">`/url?time=<span class=\"subst\">$&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>\n使得每次请求的路径都不同，则不会去获取缓存。    </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\"><a href=\"#浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\" class=\"headerlink\" title=\"浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？\"></a>浏览器回退到当前页面时，需要从接口调取数据而非缓存的解决办法？</h1><p>今天遇到了一个bug，从页面A跳转到页面B的时候提交了一份表单信息使得用户信息发生了变化，但是从页面B返回到页面A的时候，获取到的用户信息还是提交之前的状态。<br>后来发现是因为页面发起请求获取信息的时候，直接从浏览器拿了缓存。<br><img src=\"https://img-blog.csdnimg.cn/a9578e8302e641de91e30b1372e8c14e.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"什么是from-disk-cache\"><a href=\"#什么是from-disk-cache\" class=\"headerlink\" title=\"什么是from disk cache\"></a>什么是from disk cache</h1><p>from disk cache意思是从磁盘中获取缓存，这是因为请求的时间在缓存的时间长度内（max-age），导致会先从缓存中拿数据，缓存中没有才会向服务器发起请求。它跟304的区别是，304会再跟服务器确认一次数据，确保数据没有变化，而<strong>from disk cache没有跟服务器确认，就直接使用浏览器的缓存。</strong></p>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><ol>\n<li>http关闭缓存<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/url&#x27;</span>,&#123;<span class=\"attr\">headers</span>:&#123;<span class=\"string\">&#x27;Cache-Control&#x27;</span>:<span class=\"string\">&#x27;no-cache&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li>\n<li>动态改变请求路径<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax.<span class=\"title function_\">get</span>(<span class=\"string\">`/url?time=<span class=\"subst\">$&#123;<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>\n使得每次请求的路径都不同，则不会去获取缓存。    </li>\n</ol>\n"},{"title":"简单介绍下什么是nginx？它能用来做什么？","date":"2023-02-01T03:31:55.000Z","description":"Nginx是一个轻量的Http服务器......","_content":"# Nginx入门\n\nNginx是一个轻量的Http服务器，可以高效处理反向代理，负载均衡等功能。\n\n## Nginx能做什么\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 处理跨域\n- ......\n\n## 安装\n\n### Mac环境\n\nbrew install nginx  //安装\n\nnginx -v  //查看版本\n\nnginx  //启动nginx\n\n可通过nginx.conf查看默认端口号，一般初始默认为8080，找不到配置文件目录可执行nginx -t 查看\n![请添加图片描述](https://img-blog.csdnimg.cn/bebfff95ce554448b9d7a65359e4a594.png)\n\n浏览器中访问[http://localhost:8080]，出现该页面则初始化成功\n![请添加图片描述](https://img-blog.csdnimg.cn/2c1b69bf86004bffa5fa30a5845893a6.png)\n\n### Window环境\n\nwindow环境可通过官网安装即可\n\n## 反向代理\n\n代理是服务器与客户端之间的一层服务器，客户端向代理服务器发起请求，代理服务器再将请求发送给真正要请求的服务器，再响应给客户端。如我们平时使用的VPN就是一种，这种是正向代理，它是为客户端服务的。\n\n反向代理则是客户端发起请求之后，由代理服务器来接受请求，再将请求发送到内部服务器上，再将结果响应给客户端，它是为服务端服务的。\n\n有些同学听起来可能两者有些类似分不清，举个例子。\n\n- 正向代理就是我们平时如果要访问外网，我们需要使用VPN，我们向VPN发起请求，它将我们的请求代理到外网。\n- 反向代理就是我们去访问某个公司的网站，这时我们去访问他们的某一个服务器，这个服务器会将收到的请求发送给他们内部的其他多个服务器，我们作为客户是没有感知的。\n\n## 负载均衡\n\n当一台服务器的访问量越来也大时，它承受的压力也越来越大，直至挂掉，为了避免这种情况我们就需要有更多的服务器来分摊压力，这时就可以用到反向代理将客户端端请求分散到多个内部服务器上来缓解压力。而负载均衡就是将收到的请求合理地分配到合适的服务器上，从而保证整个服务器的性能最优情况。\n\n### 常用策略\n\n#### 1.轮询（默认情况）\n\nnginx将把收到的请求轮流按顺序分配给不同的服务器，若某台服务器挂掉则自动剔除\n\n````json\nupstream myserver{\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n#### 2.权重\n\n通过使用weight（默认为1），给服务器设置权重，权重越高分配到的也更多。\n\n````json\nupstream myserver{\n  server 127.0.0.1:80 weight =1;\n  server 127.0.0.1:81 weight =2;\n}\n````\n\n#### 3.固定ip\n\n上面两种情况都会有一个弊端，假如用户在不多次访问都不在同一台服务器上的话，此时多个服务器的**session**是不共享的，通过ip_hash可以让请求按ip分配，固定ip访问固定的服务器。\n\n````json\nupstream myserver{\n  ip_hash;\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n#### 4.最小连接数策略\n\n将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。\n\n````json\nupstream myserver{\n  least_conn;\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n\n\n## 处理跨域\n\n例如\n\n- 客户端的域名为a.com\n\n- 服务端域名为b.com\n  现在我们客户端向服务端发起请求的话会因为域名不同导致跨域，这时候我们只需要通过nginx将server_name设置为a.com，将其代理到b.com。\n\n  ````json\n  server{\n    listen 80;\n    server_name a.com\n    location /{\n    \tproxy_pass b.com\n  \t}\n  }\n  ````\n\n","source":"_posts/简单介绍下什么是nginx？它能用来做什么？.md","raw":"---\ntitle: 简单介绍下什么是nginx？它能用来做什么？\ndate: 2023-02-01 11:31:55\ntags: 工程化\ndescription: Nginx是一个轻量的Http服务器......\n---\n# Nginx入门\n\nNginx是一个轻量的Http服务器，可以高效处理反向代理，负载均衡等功能。\n\n## Nginx能做什么\n\n- 反向代理\n- 负载均衡\n- 动静分离\n- 处理跨域\n- ......\n\n## 安装\n\n### Mac环境\n\nbrew install nginx  //安装\n\nnginx -v  //查看版本\n\nnginx  //启动nginx\n\n可通过nginx.conf查看默认端口号，一般初始默认为8080，找不到配置文件目录可执行nginx -t 查看\n![请添加图片描述](https://img-blog.csdnimg.cn/bebfff95ce554448b9d7a65359e4a594.png)\n\n浏览器中访问[http://localhost:8080]，出现该页面则初始化成功\n![请添加图片描述](https://img-blog.csdnimg.cn/2c1b69bf86004bffa5fa30a5845893a6.png)\n\n### Window环境\n\nwindow环境可通过官网安装即可\n\n## 反向代理\n\n代理是服务器与客户端之间的一层服务器，客户端向代理服务器发起请求，代理服务器再将请求发送给真正要请求的服务器，再响应给客户端。如我们平时使用的VPN就是一种，这种是正向代理，它是为客户端服务的。\n\n反向代理则是客户端发起请求之后，由代理服务器来接受请求，再将请求发送到内部服务器上，再将结果响应给客户端，它是为服务端服务的。\n\n有些同学听起来可能两者有些类似分不清，举个例子。\n\n- 正向代理就是我们平时如果要访问外网，我们需要使用VPN，我们向VPN发起请求，它将我们的请求代理到外网。\n- 反向代理就是我们去访问某个公司的网站，这时我们去访问他们的某一个服务器，这个服务器会将收到的请求发送给他们内部的其他多个服务器，我们作为客户是没有感知的。\n\n## 负载均衡\n\n当一台服务器的访问量越来也大时，它承受的压力也越来越大，直至挂掉，为了避免这种情况我们就需要有更多的服务器来分摊压力，这时就可以用到反向代理将客户端端请求分散到多个内部服务器上来缓解压力。而负载均衡就是将收到的请求合理地分配到合适的服务器上，从而保证整个服务器的性能最优情况。\n\n### 常用策略\n\n#### 1.轮询（默认情况）\n\nnginx将把收到的请求轮流按顺序分配给不同的服务器，若某台服务器挂掉则自动剔除\n\n````json\nupstream myserver{\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n#### 2.权重\n\n通过使用weight（默认为1），给服务器设置权重，权重越高分配到的也更多。\n\n````json\nupstream myserver{\n  server 127.0.0.1:80 weight =1;\n  server 127.0.0.1:81 weight =2;\n}\n````\n\n#### 3.固定ip\n\n上面两种情况都会有一个弊端，假如用户在不多次访问都不在同一台服务器上的话，此时多个服务器的**session**是不共享的，通过ip_hash可以让请求按ip分配，固定ip访问固定的服务器。\n\n````json\nupstream myserver{\n  ip_hash;\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n#### 4.最小连接数策略\n\n将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。\n\n````json\nupstream myserver{\n  least_conn;\n  server 127.0.0.1:80;\n  server 127.0.0.1:81;\n}\n````\n\n\n\n## 处理跨域\n\n例如\n\n- 客户端的域名为a.com\n\n- 服务端域名为b.com\n  现在我们客户端向服务端发起请求的话会因为域名不同导致跨域，这时候我们只需要通过nginx将server_name设置为a.com，将其代理到b.com。\n\n  ````json\n  server{\n    listen 80;\n    server_name a.com\n    location /{\n    \tproxy_pass b.com\n  \t}\n  }\n  ````\n\n","slug":"简单介绍下什么是nginx？它能用来做什么？","published":1,"updated":"2023-02-01T03:40:28.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekhc000iywnk6n1i3dd4","content":"<h1 id=\"Nginx入门\"><a href=\"#Nginx入门\" class=\"headerlink\" title=\"Nginx入门\"></a>Nginx入门</h1><p>Nginx是一个轻量的Http服务器，可以高效处理反向代理，负载均衡等功能。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>处理跨域</li>\n<li>……</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"Mac环境\"><a href=\"#Mac环境\" class=\"headerlink\" title=\"Mac环境\"></a>Mac环境</h3><p>brew install nginx  //安装</p>\n<p>nginx -v  //查看版本</p>\n<p>nginx  //启动nginx</p>\n<p>可通过nginx.conf查看默认端口号，一般初始默认为8080，找不到配置文件目录可执行nginx -t 查看<br><img src=\"https://img-blog.csdnimg.cn/bebfff95ce554448b9d7a65359e4a594.png\" alt=\"请添加图片描述\"></p>\n<p>浏览器中访问[<a href=\"http://localhost:8080]，出现该页面则初始化成功\">http://localhost:8080]，出现该页面则初始化成功</a><br><img src=\"https://img-blog.csdnimg.cn/2c1b69bf86004bffa5fa30a5845893a6.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"Window环境\"><a href=\"#Window环境\" class=\"headerlink\" title=\"Window环境\"></a>Window环境</h3><p>window环境可通过官网安装即可</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>代理是服务器与客户端之间的一层服务器，客户端向代理服务器发起请求，代理服务器再将请求发送给真正要请求的服务器，再响应给客户端。如我们平时使用的VPN就是一种，这种是正向代理，它是为客户端服务的。</p>\n<p>反向代理则是客户端发起请求之后，由代理服务器来接受请求，再将请求发送到内部服务器上，再将结果响应给客户端，它是为服务端服务的。</p>\n<p>有些同学听起来可能两者有些类似分不清，举个例子。</p>\n<ul>\n<li>正向代理就是我们平时如果要访问外网，我们需要使用VPN，我们向VPN发起请求，它将我们的请求代理到外网。</li>\n<li>反向代理就是我们去访问某个公司的网站，这时我们去访问他们的某一个服务器，这个服务器会将收到的请求发送给他们内部的其他多个服务器，我们作为客户是没有感知的。</li>\n</ul>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>当一台服务器的访问量越来也大时，它承受的压力也越来越大，直至挂掉，为了避免这种情况我们就需要有更多的服务器来分摊压力，这时就可以用到反向代理将客户端端请求分散到多个内部服务器上来缓解压力。而负载均衡就是将收到的请求合理地分配到合适的服务器上，从而保证整个服务器的性能最优情况。</p>\n<h3 id=\"常用策略\"><a href=\"#常用策略\" class=\"headerlink\" title=\"常用策略\"></a>常用策略</h3><h4 id=\"1-轮询（默认情况）\"><a href=\"#1-轮询（默认情况）\" class=\"headerlink\" title=\"1.轮询（默认情况）\"></a>1.轮询（默认情况）</h4><p>nginx将把收到的请求轮流按顺序分配给不同的服务器，若某台服务器挂掉则自动剔除</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h4><p>通过使用weight（默认为1），给服务器设置权重，权重越高分配到的也更多。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span> weight =<span class=\"number\">1</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span> weight =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-固定ip\"><a href=\"#3-固定ip\" class=\"headerlink\" title=\"3.固定ip\"></a>3.固定ip</h4><p>上面两种情况都会有一个弊端，假如用户在不多次访问都不在同一台服务器上的话，此时多个服务器的<strong>session</strong>是不共享的，通过ip_hash可以让请求按ip分配，固定ip访问固定的服务器。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-最小连接数策略\"><a href=\"#4-最小连接数策略\" class=\"headerlink\" title=\"4.最小连接数策略\"></a>4.最小连接数策略</h4><p>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  least_conn;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"处理跨域\"><a href=\"#处理跨域\" class=\"headerlink\" title=\"处理跨域\"></a>处理跨域</h2><p>例如</p>\n<ul>\n<li><p>客户端的域名为a.com</p>\n</li>\n<li><p>服务端域名为b.com<br>现在我们客户端向服务端发起请求的话会因为域名不同导致跨域，这时候我们只需要通过nginx将server_name设置为a.com，将其代理到b.com。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  listen <span class=\"number\">80</span>;</span><br><span class=\"line\">  server_name a.com</span><br><span class=\"line\">  location /<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  \tproxy_pass b.com</span><br><span class=\"line\">\t<span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nginx入门\"><a href=\"#Nginx入门\" class=\"headerlink\" title=\"Nginx入门\"></a>Nginx入门</h1><p>Nginx是一个轻量的Http服务器，可以高效处理反向代理，负载均衡等功能。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><ul>\n<li>反向代理</li>\n<li>负载均衡</li>\n<li>动静分离</li>\n<li>处理跨域</li>\n<li>……</li>\n</ul>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"Mac环境\"><a href=\"#Mac环境\" class=\"headerlink\" title=\"Mac环境\"></a>Mac环境</h3><p>brew install nginx  //安装</p>\n<p>nginx -v  //查看版本</p>\n<p>nginx  //启动nginx</p>\n<p>可通过nginx.conf查看默认端口号，一般初始默认为8080，找不到配置文件目录可执行nginx -t 查看<br><img src=\"https://img-blog.csdnimg.cn/bebfff95ce554448b9d7a65359e4a594.png\" alt=\"请添加图片描述\"></p>\n<p>浏览器中访问[<a href=\"http://localhost:8080]，出现该页面则初始化成功\">http://localhost:8080]，出现该页面则初始化成功</a><br><img src=\"https://img-blog.csdnimg.cn/2c1b69bf86004bffa5fa30a5845893a6.png\" alt=\"请添加图片描述\"></p>\n<h3 id=\"Window环境\"><a href=\"#Window环境\" class=\"headerlink\" title=\"Window环境\"></a>Window环境</h3><p>window环境可通过官网安装即可</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>代理是服务器与客户端之间的一层服务器，客户端向代理服务器发起请求，代理服务器再将请求发送给真正要请求的服务器，再响应给客户端。如我们平时使用的VPN就是一种，这种是正向代理，它是为客户端服务的。</p>\n<p>反向代理则是客户端发起请求之后，由代理服务器来接受请求，再将请求发送到内部服务器上，再将结果响应给客户端，它是为服务端服务的。</p>\n<p>有些同学听起来可能两者有些类似分不清，举个例子。</p>\n<ul>\n<li>正向代理就是我们平时如果要访问外网，我们需要使用VPN，我们向VPN发起请求，它将我们的请求代理到外网。</li>\n<li>反向代理就是我们去访问某个公司的网站，这时我们去访问他们的某一个服务器，这个服务器会将收到的请求发送给他们内部的其他多个服务器，我们作为客户是没有感知的。</li>\n</ul>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>当一台服务器的访问量越来也大时，它承受的压力也越来越大，直至挂掉，为了避免这种情况我们就需要有更多的服务器来分摊压力，这时就可以用到反向代理将客户端端请求分散到多个内部服务器上来缓解压力。而负载均衡就是将收到的请求合理地分配到合适的服务器上，从而保证整个服务器的性能最优情况。</p>\n<h3 id=\"常用策略\"><a href=\"#常用策略\" class=\"headerlink\" title=\"常用策略\"></a>常用策略</h3><h4 id=\"1-轮询（默认情况）\"><a href=\"#1-轮询（默认情况）\" class=\"headerlink\" title=\"1.轮询（默认情况）\"></a>1.轮询（默认情况）</h4><p>nginx将把收到的请求轮流按顺序分配给不同的服务器，若某台服务器挂掉则自动剔除</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h4><p>通过使用weight（默认为1），给服务器设置权重，权重越高分配到的也更多。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span> weight =<span class=\"number\">1</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span> weight =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-固定ip\"><a href=\"#3-固定ip\" class=\"headerlink\" title=\"3.固定ip\"></a>3.固定ip</h4><p>上面两种情况都会有一个弊端，假如用户在不多次访问都不在同一台服务器上的话，此时多个服务器的<strong>session</strong>是不共享的，通过ip_hash可以让请求按ip分配，固定ip访问固定的服务器。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-最小连接数策略\"><a href=\"#4-最小连接数策略\" class=\"headerlink\" title=\"4.最小连接数策略\"></a>4.最小连接数策略</h4><p>将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream myserver<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  least_conn;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">80</span>;</span><br><span class=\"line\">  server <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span><span class=\"punctuation\">:</span><span class=\"number\">81</span>;</span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"处理跨域\"><a href=\"#处理跨域\" class=\"headerlink\" title=\"处理跨域\"></a>处理跨域</h2><p>例如</p>\n<ul>\n<li><p>客户端的域名为a.com</p>\n</li>\n<li><p>服务端域名为b.com<br>现在我们客户端向服务端发起请求的话会因为域名不同导致跨域，这时候我们只需要通过nginx将server_name设置为a.com，将其代理到b.com。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  listen <span class=\"number\">80</span>;</span><br><span class=\"line\">  server_name a.com</span><br><span class=\"line\">  location /<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  \tproxy_pass b.com</span><br><span class=\"line\">\t<span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"通过javascript与node代码实现JSONP解决跨域","date":"2023-02-01T03:34:29.000Z","description":"用node去实现JSONP解决跨域......","_content":"# 一.什么是跨域\n浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。\n**当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域**\nhttps://(协议)www.baidu.com(域名)8080(端口号)\n# 二.什么是JSONP\n平时在一些官方文档中，如vue,jquery都会通过script标签引入cdn加载框架，不用去安装就可以使用。那为什么这样就不会引起跨域呢？这是因为当初**设计script的时候就允许它在其他源请求别的脚本**，所以早起开发者们就可以通过这个方法进行跨域，这种**通过script引入脚本的方法就是JSONP**。\n# 三.通过js与node实现JSONP\n我们通过代码去展示一下具体过程。\n### 客户端代码：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"></script>\n<script>\n  $.ajax({url:\"http://127.0.0.1:8888/?callback=a\",type:\"get\"}).then((data)=>{\n      console.log(data)\n  })\n</script>\n\n```\n### 服务端代码\n```javascript\nconst http = require('http')\nconst url = require('url')\nlet server = http.createServer((req, res) => {\n    let urlObj = url.parse(req.url, true)\n    let data = urlObj.query\n    console.log(data)\n    res.end(`console.log(${JSON.stringify(data)})`)\n})\nserver.listen(8888)\n```\n服务端启动了一个8888端口的服务，响应了一段js代码。客户端通过ajax对8888端口发起请求结果我们在浏览器中看到了如下情况![在这里插入图片描述](https://img-blog.csdnimg.cn/47c8421e5f474e5da4f1396a101d241c.png)果不其然地跨域了，接下来我们用jsonp的方法来请求这段资源。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"http://127.0.0.1:8888/?a=2\"></script>\n\n```\n我们通过script标签引入8888端口的资源**由于script标签的type默认是text/javascript，因此会将引入的代码作为javascript语句执行。**这里执行了node响应的代码console.log(JSON.stringify(data))\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a6ce99fb272a4981bc1abbedeebada61.png)\n所以得出我们是可以通过这种方法拿到服务端的数据的，并且服务端也能通过引入的地址上的参数，拿到客户端传过来的参数。如果我们想拿到服务端的数据并用到我们的代码逻辑中，我们可以通过服务端让客户端调用方法的方式拿到服务端的数据。如下。\n### 客户端\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script>\n  const a = (data) => {\n    console.log(`this is ${data}`);\n  };\n</script>\n<script src=\"http://127.0.0.1:8888/?callback=a\"></script>\n\n```\n### 服务端\n```javascript\nconst http = require('http')\nconst url = require('url')\nlet server = http.createServer((req, res) => {\n    let urlObj = url.parse(req.url, true)\n    let fn = urlObj.query.callback\n    res.end(`${fn}('响应数据')`)\n})\nserver.listen(8888)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/616a1fbf83fc48a8aa47a73c6997e710.png)\n我们在客户端中写了一个a方法，引入服务端资源的时候传了一个callback的参数a，告诉服务端调用a方法。服务端拿到a，之后做出响应代码**a('响应数据')**，所以客户端代码中的a方法的参数被传入了‘响应数据’。这时候客户端就顺利拿到了服务端传出的数据了。\n# 四.总结\n通过这也可以看出这种方法的弊端，它只适用于get请求，因为我们向服务端传送的数据只能通过请求地址的链接参数发送给服务端。此外它还有以下缺点\n1. 只适用于get请求\n2. 请求失败的时候无法捕获错误，获取不到状态码\n3. 缺乏安全性，怕服务端存在漏洞，受到xss攻击，返回的script代码受他人控制\n4. 只支持跨域HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 Javascript 调用的问题","source":"_posts/通过javascript与node代码实现JSONP解决跨域.md","raw":"---\ntitle: 通过javascript与node代码实现JSONP解决跨域\ndate: 2023-02-01 11:34:29\ntags: node\ndescription: 用node去实现JSONP解决跨域......\n---\n# 一.什么是跨域\n浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。\n**当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域**\nhttps://(协议)www.baidu.com(域名)8080(端口号)\n# 二.什么是JSONP\n平时在一些官方文档中，如vue,jquery都会通过script标签引入cdn加载框架，不用去安装就可以使用。那为什么这样就不会引起跨域呢？这是因为当初**设计script的时候就允许它在其他源请求别的脚本**，所以早起开发者们就可以通过这个方法进行跨域，这种**通过script引入脚本的方法就是JSONP**。\n# 三.通过js与node实现JSONP\n我们通过代码去展示一下具体过程。\n### 客户端代码：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"https://code.jquery.com/jquery-3.0.0.min.js\"></script>\n<script>\n  $.ajax({url:\"http://127.0.0.1:8888/?callback=a\",type:\"get\"}).then((data)=>{\n      console.log(data)\n  })\n</script>\n\n```\n### 服务端代码\n```javascript\nconst http = require('http')\nconst url = require('url')\nlet server = http.createServer((req, res) => {\n    let urlObj = url.parse(req.url, true)\n    let data = urlObj.query\n    console.log(data)\n    res.end(`console.log(${JSON.stringify(data)})`)\n})\nserver.listen(8888)\n```\n服务端启动了一个8888端口的服务，响应了一段js代码。客户端通过ajax对8888端口发起请求结果我们在浏览器中看到了如下情况![在这里插入图片描述](https://img-blog.csdnimg.cn/47c8421e5f474e5da4f1396a101d241c.png)果不其然地跨域了，接下来我们用jsonp的方法来请求这段资源。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script src=\"http://127.0.0.1:8888/?a=2\"></script>\n\n```\n我们通过script标签引入8888端口的资源**由于script标签的type默认是text/javascript，因此会将引入的代码作为javascript语句执行。**这里执行了node响应的代码console.log(JSON.stringify(data))\n![在这里插入图片描述](https://img-blog.csdnimg.cn/a6ce99fb272a4981bc1abbedeebada61.png)\n所以得出我们是可以通过这种方法拿到服务端的数据的，并且服务端也能通过引入的地址上的参数，拿到客户端传过来的参数。如果我们想拿到服务端的数据并用到我们的代码逻辑中，我们可以通过服务端让客户端调用方法的方式拿到服务端的数据。如下。\n### 客户端\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n<script>\n  const a = (data) => {\n    console.log(`this is ${data}`);\n  };\n</script>\n<script src=\"http://127.0.0.1:8888/?callback=a\"></script>\n\n```\n### 服务端\n```javascript\nconst http = require('http')\nconst url = require('url')\nlet server = http.createServer((req, res) => {\n    let urlObj = url.parse(req.url, true)\n    let fn = urlObj.query.callback\n    res.end(`${fn}('响应数据')`)\n})\nserver.listen(8888)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/616a1fbf83fc48a8aa47a73c6997e710.png)\n我们在客户端中写了一个a方法，引入服务端资源的时候传了一个callback的参数a，告诉服务端调用a方法。服务端拿到a，之后做出响应代码**a('响应数据')**，所以客户端代码中的a方法的参数被传入了‘响应数据’。这时候客户端就顺利拿到了服务端传出的数据了。\n# 四.总结\n通过这也可以看出这种方法的弊端，它只适用于get请求，因为我们向服务端传送的数据只能通过请求地址的链接参数发送给服务端。此外它还有以下缺点\n1. 只适用于get请求\n2. 请求失败的时候无法捕获错误，获取不到状态码\n3. 缺乏安全性，怕服务端存在漏洞，受到xss攻击，返回的script代码受他人控制\n4. 只支持跨域HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 Javascript 调用的问题","slug":"通过javascript与node代码实现JSONP解决跨域","published":1,"updated":"2023-02-01T03:47:36.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekhd000kywnkg42fb15a","content":"<h1 id=\"一-什么是跨域\"><a href=\"#一-什么是跨域\" class=\"headerlink\" title=\"一.什么是跨域\"></a>一.什么是跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。<br><strong>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</strong><br>https://(协议)<a href=\"http://www.baidu.com(域名)8080(端口号)/\">www.baidu.com(域名)8080(端口号)</a></p>\n<h1 id=\"二-什么是JSONP\"><a href=\"#二-什么是JSONP\" class=\"headerlink\" title=\"二.什么是JSONP\"></a>二.什么是JSONP</h1><p>平时在一些官方文档中，如vue,jquery都会通过script标签引入cdn加载框架，不用去安装就可以使用。那为什么这样就不会引起跨域呢？这是因为当初<strong>设计script的时候就允许它在其他源请求别的脚本</strong>，所以早起开发者们就可以通过这个方法进行跨域，这种<strong>通过script引入脚本的方法就是JSONP</strong>。</p>\n<h1 id=\"三-通过js与node实现JSONP\"><a href=\"#三-通过js与node实现JSONP\" class=\"headerlink\" title=\"三.通过js与node实现JSONP\"></a>三.通过js与node实现JSONP</h1><p>我们通过代码去展示一下具体过程。</p>\n<h3 id=\"客户端代码：\"><a href=\"#客户端代码：\" class=\"headerlink\" title=\"客户端代码：\"></a>客户端代码：</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  $.<span class=\"title function_\">ajax</span>(&#123;<span class=\"attr\">url</span>:<span class=\"string\">&quot;http://127.0.0.1:8888/?callback=a&quot;</span>,<span class=\"attr\">type</span>:<span class=\"string\">&quot;get&quot;</span>&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;url&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> urlObj = url.<span class=\"title function_\">parse</span>(req.<span class=\"property\">url</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = urlObj.<span class=\"property\">query</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">    res.<span class=\"title function_\">end</span>(<span class=\"string\">`console.log(<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(data)&#125;</span>)`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br></pre></td></tr></table></figure>\n<p>服务端启动了一个8888端口的服务，响应了一段js代码。客户端通过ajax对8888端口发起请求结果我们在浏览器中看到了如下情况<img src=\"https://img-blog.csdnimg.cn/47c8421e5f474e5da4f1396a101d241c.png\" alt=\"在这里插入图片描述\">果不其然地跨域了，接下来我们用jsonp的方法来请求这段资源。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://127.0.0.1:8888/?a=2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们通过script标签引入8888端口的资源<strong>由于script标签的type默认是text/javascript，因此会将引入的代码作为javascript语句执行。</strong>这里执行了node响应的代码console.log(JSON.stringify(data))<br><img src=\"https://img-blog.csdnimg.cn/a6ce99fb272a4981bc1abbedeebada61.png\" alt=\"在这里插入图片描述\"><br>所以得出我们是可以通过这种方法拿到服务端的数据的，并且服务端也能通过引入的地址上的参数，拿到客户端传过来的参数。如果我们想拿到服务端的数据并用到我们的代码逻辑中，我们可以通过服务端让客户端调用方法的方式拿到服务端的数据。如下。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = (<span class=\"params\">data</span>) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`this is <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://127.0.0.1:8888/?callback=a&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;url&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> urlObj = url.<span class=\"title function_\">parse</span>(req.<span class=\"property\">url</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = urlObj.<span class=\"property\">query</span>.<span class=\"property\">callback</span></span><br><span class=\"line\">    res.<span class=\"title function_\">end</span>(<span class=\"string\">`<span class=\"subst\">$&#123;fn&#125;</span>(&#x27;响应数据&#x27;)`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/616a1fbf83fc48a8aa47a73c6997e710.png\" alt=\"在这里插入图片描述\"><br>我们在客户端中写了一个a方法，引入服务端资源的时候传了一个callback的参数a，告诉服务端调用a方法。服务端拿到a，之后做出响应代码**a(‘响应数据’)**，所以客户端代码中的a方法的参数被传入了‘响应数据’。这时候客户端就顺利拿到了服务端传出的数据了。</p>\n<h1 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四.总结\"></a>四.总结</h1><p>通过这也可以看出这种方法的弊端，它只适用于get请求，因为我们向服务端传送的数据只能通过请求地址的链接参数发送给服务端。此外它还有以下缺点</p>\n<ol>\n<li>只适用于get请求</li>\n<li>请求失败的时候无法捕获错误，获取不到状态码</li>\n<li>缺乏安全性，怕服务端存在漏洞，受到xss攻击，返回的script代码受他人控制</li>\n<li>只支持跨域HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 Javascript 调用的问题</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一-什么是跨域\"><a href=\"#一-什么是跨域\" class=\"headerlink\" title=\"一.什么是跨域\"></a>一.什么是跨域</h1><p>浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，会导致跨域拿不到响应内容。<br><strong>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</strong><br>https://(协议)<a href=\"http://www.baidu.com(域名)8080(端口号)/\">www.baidu.com(域名)8080(端口号)</a></p>\n<h1 id=\"二-什么是JSONP\"><a href=\"#二-什么是JSONP\" class=\"headerlink\" title=\"二.什么是JSONP\"></a>二.什么是JSONP</h1><p>平时在一些官方文档中，如vue,jquery都会通过script标签引入cdn加载框架，不用去安装就可以使用。那为什么这样就不会引起跨域呢？这是因为当初<strong>设计script的时候就允许它在其他源请求别的脚本</strong>，所以早起开发者们就可以通过这个方法进行跨域，这种<strong>通过script引入脚本的方法就是JSONP</strong>。</p>\n<h1 id=\"三-通过js与node实现JSONP\"><a href=\"#三-通过js与node实现JSONP\" class=\"headerlink\" title=\"三.通过js与node实现JSONP\"></a>三.通过js与node实现JSONP</h1><p>我们通过代码去展示一下具体过程。</p>\n<h3 id=\"客户端代码：\"><a href=\"#客户端代码：\" class=\"headerlink\" title=\"客户端代码：\"></a>客户端代码：</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://code.jquery.com/jquery-3.0.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  $.<span class=\"title function_\">ajax</span>(&#123;<span class=\"attr\">url</span>:<span class=\"string\">&quot;http://127.0.0.1:8888/?callback=a&quot;</span>,<span class=\"attr\">type</span>:<span class=\"string\">&quot;get&quot;</span>&#125;).<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端代码\"><a href=\"#服务端代码\" class=\"headerlink\" title=\"服务端代码\"></a>服务端代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;url&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> urlObj = url.<span class=\"title function_\">parse</span>(req.<span class=\"property\">url</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = urlObj.<span class=\"property\">query</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\">    res.<span class=\"title function_\">end</span>(<span class=\"string\">`console.log(<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(data)&#125;</span>)`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br></pre></td></tr></table></figure>\n<p>服务端启动了一个8888端口的服务，响应了一段js代码。客户端通过ajax对8888端口发起请求结果我们在浏览器中看到了如下情况<img src=\"https://img-blog.csdnimg.cn/47c8421e5f474e5da4f1396a101d241c.png\" alt=\"在这里插入图片描述\">果不其然地跨域了，接下来我们用jsonp的方法来请求这段资源。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://127.0.0.1:8888/?a=2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们通过script标签引入8888端口的资源<strong>由于script标签的type默认是text/javascript，因此会将引入的代码作为javascript语句执行。</strong>这里执行了node响应的代码console.log(JSON.stringify(data))<br><img src=\"https://img-blog.csdnimg.cn/a6ce99fb272a4981bc1abbedeebada61.png\" alt=\"在这里插入图片描述\"><br>所以得出我们是可以通过这种方法拿到服务端的数据的，并且服务端也能通过引入的地址上的参数，拿到客户端传过来的参数。如果我们想拿到服务端的数据并用到我们的代码逻辑中，我们可以通过服务端让客户端调用方法的方式拿到服务端的数据。如下。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;X-UA-Compatible&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Document<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = (<span class=\"params\">data</span>) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`this is <span class=\"subst\">$&#123;data&#125;</span>`</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">  &#125;;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;http://127.0.0.1:8888/?callback=a&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;url&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> server = http.<span class=\"title function_\">createServer</span>(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> urlObj = url.<span class=\"title function_\">parse</span>(req.<span class=\"property\">url</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fn = urlObj.<span class=\"property\">query</span>.<span class=\"property\">callback</span></span><br><span class=\"line\">    res.<span class=\"title function_\">end</span>(<span class=\"string\">`<span class=\"subst\">$&#123;fn&#125;</span>(&#x27;响应数据&#x27;)`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">server.<span class=\"title function_\">listen</span>(<span class=\"number\">8888</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/616a1fbf83fc48a8aa47a73c6997e710.png\" alt=\"在这里插入图片描述\"><br>我们在客户端中写了一个a方法，引入服务端资源的时候传了一个callback的参数a，告诉服务端调用a方法。服务端拿到a，之后做出响应代码**a(‘响应数据’)**，所以客户端代码中的a方法的参数被传入了‘响应数据’。这时候客户端就顺利拿到了服务端传出的数据了。</p>\n<h1 id=\"四-总结\"><a href=\"#四-总结\" class=\"headerlink\" title=\"四.总结\"></a>四.总结</h1><p>通过这也可以看出这种方法的弊端，它只适用于get请求，因为我们向服务端传送的数据只能通过请求地址的链接参数发送给服务端。此外它还有以下缺点</p>\n<ol>\n<li>只适用于get请求</li>\n<li>请求失败的时候无法捕获错误，获取不到状态码</li>\n<li>缺乏安全性，怕服务端存在漏洞，受到xss攻击，返回的script代码受他人控制</li>\n<li>只支持跨域HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 Javascript 调用的问题</li>\n</ol>\n"},{"title":"谷歌浏览器插件开发","date":"2023-02-01T03:30:13.000Z","description":"谷歌浏览器插件开发入门小尝试","_content":"## manifest\n\n新建一个文件夹作为项目，创建一个manifest.json文件作为基础配置。\n\n```json\n{\n    \"manifest_version\": 2,\n    \"name\": \"这是一个插件\",\n    \"version\": \"1.0\",\n    \"description\": \"描述\",\n    \"icons\": \n\t{\n\t\t\"16\": \"/images/sun.png\",\n\t\t\"48\": \"/images/sun.png\",\n\t\t\"128\": \"/images/sun.png\"\n    }\n}\n```\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xEc9W567-1625758987309)(C:\\Users\\7000\\AppData\\Roaming\\Typora\\typora-user-images\\1625751640893.png)\\]](https://img-blog.csdnimg.cn/20210708234401133.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708234420367.png)\n\n这时一个初始状态的插件就创建完成了。但这个时候它是没什么功能的。\n\n##### content_scripts\n\ncontent_scripts是配置需要直接注入页面的js或css，我们在引入的js中console点东西，并且在引入的css中对页面样式做下修改，样式由于是全局的加的时候要留意下与原本的样式的优先级关系。增加该配置后重新加载插件\n\n```json\n  \"content_scripts\": [\n        {\n            \"matches\": [\n                \"<all_urls>\"\n            ],\n            \"js\": [\n                \"./src/js/index.js\"\n            ],\n            \"css\": [\n                \"./src/css/index.css\"\n            ],\n            // 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n            \"run_at\": \"document_start\"\n        }\n    ]\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708234526348.png)\n\n如果我们将run_at改为document_end，会发现插件输出的位置变了，这是因为代码注入的时间变成DOM构建结束之再注入，而先前的document_start是在DOM构建之前注入，默认不添加这个配置的话其值是document_idle，表示页面空闲时间注入\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070823461532.png)\n\n这时候我们就可以通过对content_scripts配置的js，css做一些修改实现自己的一些效果了","source":"_posts/谷歌浏览器插件开发.md","raw":"---\ntitle: 谷歌浏览器插件开发\ndate: 2023-02-01 11:30:13\ntags: 其他\ndescription: 谷歌浏览器插件开发入门小尝试\n---\n## manifest\n\n新建一个文件夹作为项目，创建一个manifest.json文件作为基础配置。\n\n```json\n{\n    \"manifest_version\": 2,\n    \"name\": \"这是一个插件\",\n    \"version\": \"1.0\",\n    \"description\": \"描述\",\n    \"icons\": \n\t{\n\t\t\"16\": \"/images/sun.png\",\n\t\t\"48\": \"/images/sun.png\",\n\t\t\"128\": \"/images/sun.png\"\n    }\n}\n```\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xEc9W567-1625758987309)(C:\\Users\\7000\\AppData\\Roaming\\Typora\\typora-user-images\\1625751640893.png)\\]](https://img-blog.csdnimg.cn/20210708234401133.png)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708234420367.png)\n\n这时一个初始状态的插件就创建完成了。但这个时候它是没什么功能的。\n\n##### content_scripts\n\ncontent_scripts是配置需要直接注入页面的js或css，我们在引入的js中console点东西，并且在引入的css中对页面样式做下修改，样式由于是全局的加的时候要留意下与原本的样式的优先级关系。增加该配置后重新加载插件\n\n```json\n  \"content_scripts\": [\n        {\n            \"matches\": [\n                \"<all_urls>\"\n            ],\n            \"js\": [\n                \"./src/js/index.js\"\n            ],\n            \"css\": [\n                \"./src/css/index.css\"\n            ],\n            // 代码注入的时间，可选值： \"document_start\", \"document_end\", or \"document_idle\"，最后一个表示页面空闲时，默认document_idle\n            \"run_at\": \"document_start\"\n        }\n    ]\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210708234526348.png)\n\n如果我们将run_at改为document_end，会发现插件输出的位置变了，这是因为代码注入的时间变成DOM构建结束之再注入，而先前的document_start是在DOM构建之前注入，默认不添加这个配置的话其值是document_idle，表示页面空闲时间注入\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021070823461532.png)\n\n这时候我们就可以通过对content_scripts配置的js，css做一些修改实现自己的一些效果了","slug":"谷歌浏览器插件开发","published":1,"updated":"2023-02-01T03:39:50.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekhe000mywnk3idw9mik","content":"<h2 id=\"manifest\"><a href=\"#manifest\" class=\"headerlink\" title=\"manifest\"></a>manifest</h2><p>新建一个文件夹作为项目，创建一个manifest.json文件作为基础配置。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;manifest_version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;这是一个插件&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;描述&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;icons&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">\t<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;16&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;48&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;128&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234401133.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xEc9W567-1625758987309)(C:\\Users\\7000\\AppData\\Roaming\\Typora\\typora-user-images\\1625751640893.png)]\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234420367.png\" alt=\"在这里插入图片描述\"></p>\n<p>这时一个初始状态的插件就创建完成了。但这个时候它是没什么功能的。</p>\n<h5 id=\"content-scripts\"><a href=\"#content-scripts\" class=\"headerlink\" title=\"content_scripts\"></a>content_scripts</h5><p>content_scripts是配置需要直接注入页面的js或css，我们在引入的js中console点东西，并且在引入的css中对页面样式做下修改，样式由于是全局的加的时候要留意下与原本的样式的优先级关系。增加该配置后重新加载插件</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;content_scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;matches&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;&lt;all_urls&gt;&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;js&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;./src/js/index.js&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;css&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;./src/css/index.css&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"comment\">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;run_at&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;document_start&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234526348.png\" alt=\"在这里插入图片描述\"></p>\n<p>如果我们将run_at改为document_end，会发现插件输出的位置变了，这是因为代码注入的时间变成DOM构建结束之再注入，而先前的document_start是在DOM构建之前注入，默认不添加这个配置的话其值是document_idle，表示页面空闲时间注入<br><img src=\"https://img-blog.csdnimg.cn/2021070823461532.png\" alt=\"在这里插入图片描述\"></p>\n<p>这时候我们就可以通过对content_scripts配置的js，css做一些修改实现自己的一些效果了</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"manifest\"><a href=\"#manifest\" class=\"headerlink\" title=\"manifest\"></a>manifest</h2><p>新建一个文件夹作为项目，创建一个manifest.json文件作为基础配置。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;manifest_version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;这是一个插件&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;description&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;描述&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;icons&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">\t<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;16&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;48&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;128&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/images/sun.png&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234401133.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xEc9W567-1625758987309)(C:\\Users\\7000\\AppData\\Roaming\\Typora\\typora-user-images\\1625751640893.png)]\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234420367.png\" alt=\"在这里插入图片描述\"></p>\n<p>这时一个初始状态的插件就创建完成了。但这个时候它是没什么功能的。</p>\n<h5 id=\"content-scripts\"><a href=\"#content-scripts\" class=\"headerlink\" title=\"content_scripts\"></a>content_scripts</h5><p>content_scripts是配置需要直接注入页面的js或css，我们在引入的js中console点东西，并且在引入的css中对页面样式做下修改，样式由于是全局的加的时候要留意下与原本的样式的优先级关系。增加该配置后重新加载插件</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;content_scripts&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;matches&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;&lt;all_urls&gt;&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;js&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;./src/js/index.js&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;css&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">              <span class=\"string\">&quot;./src/css/index.css&quot;</span></span><br><span class=\"line\">          <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"comment\">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;run_at&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;document_start&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/20210708234526348.png\" alt=\"在这里插入图片描述\"></p>\n<p>如果我们将run_at改为document_end，会发现插件输出的位置变了，这是因为代码注入的时间变成DOM构建结束之再注入，而先前的document_start是在DOM构建之前注入，默认不添加这个配置的话其值是document_idle，表示页面空闲时间注入<br><img src=\"https://img-blog.csdnimg.cn/2021070823461532.png\" alt=\"在这里插入图片描述\"></p>\n<p>这时候我们就可以通过对content_scripts配置的js，css做一些修改实现自己的一些效果了</p>\n"},{"title":"javascript中new做了什么","date":"2023-02-01T03:55:00.000Z","description":"在JavaScript中，new的时候，它都做了什么","_content":"# 1.new是什么\n在JavaScript中，new操作符用于创建一个给定构造函数的实例对象\n````javascript\nfunction Person(name){\n\tthis.name = name\n}\n\nPerson.prototype.getName = function () {\n    console.log(this.name)\n}\nconst person1 = new Person('A')\nconsole.log(person1)  // Person {name: \"A\"}\nperson1.getName() // 'A'\n````\n从以上代码可以推测到，new一个实例对象的时候，它实现了这些功能\n1. new出来的实例对象能访问到构造函数中的属性\n2. new出来的实例对象能访问到构造函数原型链中的属性\n\n我们对构造函数做一些改造，让它返回一些东西\n````javascript\nfunction Person(name){\n\tthis.name = name\n\treturn 1\n}\nconst person1 = new Person('A')\nconsole.log(person1) //Person {name:\"A\"}\n````\n由此可发现，虽然构造函数返回了一个1，但是new出来的实例并没受此影响，返回值无生效\n\n假如将构造函数的返回值换成一个对象\n````javascript\nfunction Person(name){\n\tthis.name = name\n\treturn {age:1}\n}\nconst person1 = new Person('A')\nconsole.log(person1) //Person {age:1}\n````\n这里可以发现，构造函数返回了一个对象，那么new出来的实例会使用的是这个对象，而不是构造函数的this。\n# 2.new做了什么\n在new一个实例对象的时候，其实它做了以下操作\n1. 创建一个空对象\n2. 将空对象的原型链指向构造函数的原型链\n3. 执行构造函数，将this绑定到空对象上\n4. 根据构造函数的返回值做判断，若是原始数据则忽略，若是对象的话则正常返回处理\n# 3.手撕new\n```javascript\nfunction myNew(fn,...args){\n\t//创建一个空对象\n\tlet obj = {}\n\t//将obj的原型指向构造函数的原型\n\tobj.__proto__ = fn.prototype;\n\t//将构造函数的this指向obj，并且拿到构造函数返回值\n\tlet res = Fn.apply(obj,args)\n\t//判断构造函数返回值类型，决定new构造出来的实例对象的值\n\treturn res instanceof Object ? res:obj\n}\n```\n\n","source":"_posts/javascript中new做了什么.md","raw":"---\ntitle: javascript中new做了什么\ndate: 2023-02-01 11:55:00\ntags: JavaScript\ndescription: 在JavaScript中，new的时候，它都做了什么\n---\n# 1.new是什么\n在JavaScript中，new操作符用于创建一个给定构造函数的实例对象\n````javascript\nfunction Person(name){\n\tthis.name = name\n}\n\nPerson.prototype.getName = function () {\n    console.log(this.name)\n}\nconst person1 = new Person('A')\nconsole.log(person1)  // Person {name: \"A\"}\nperson1.getName() // 'A'\n````\n从以上代码可以推测到，new一个实例对象的时候，它实现了这些功能\n1. new出来的实例对象能访问到构造函数中的属性\n2. new出来的实例对象能访问到构造函数原型链中的属性\n\n我们对构造函数做一些改造，让它返回一些东西\n````javascript\nfunction Person(name){\n\tthis.name = name\n\treturn 1\n}\nconst person1 = new Person('A')\nconsole.log(person1) //Person {name:\"A\"}\n````\n由此可发现，虽然构造函数返回了一个1，但是new出来的实例并没受此影响，返回值无生效\n\n假如将构造函数的返回值换成一个对象\n````javascript\nfunction Person(name){\n\tthis.name = name\n\treturn {age:1}\n}\nconst person1 = new Person('A')\nconsole.log(person1) //Person {age:1}\n````\n这里可以发现，构造函数返回了一个对象，那么new出来的实例会使用的是这个对象，而不是构造函数的this。\n# 2.new做了什么\n在new一个实例对象的时候，其实它做了以下操作\n1. 创建一个空对象\n2. 将空对象的原型链指向构造函数的原型链\n3. 执行构造函数，将this绑定到空对象上\n4. 根据构造函数的返回值做判断，若是原始数据则忽略，若是对象的话则正常返回处理\n# 3.手撕new\n```javascript\nfunction myNew(fn,...args){\n\t//创建一个空对象\n\tlet obj = {}\n\t//将obj的原型指向构造函数的原型\n\tobj.__proto__ = fn.prototype;\n\t//将构造函数的this指向obj，并且拿到构造函数返回值\n\tlet res = Fn.apply(obj,args)\n\t//判断构造函数返回值类型，决定new构造出来的实例对象的值\n\treturn res instanceof Object ? res:obj\n}\n```\n\n","slug":"javascript中new做了什么","published":1,"updated":"2023-02-01T03:55:39.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cldlcekhg000oywnkcqx1d0er","content":"<h1 id=\"1-new是什么\"><a href=\"#1-new是什么\" class=\"headerlink\" title=\"1.new是什么\"></a>1.new是什么</h1><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1)  <span class=\"comment\">// Person &#123;name: &quot;A&quot;&#125;</span></span><br><span class=\"line\">person1.<span class=\"title function_\">getName</span>() <span class=\"comment\">// &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>从以上代码可以推测到，new一个实例对象的时候，它实现了这些功能</p>\n<ol>\n<li>new出来的实例对象能访问到构造函数中的属性</li>\n<li>new出来的实例对象能访问到构造函数原型链中的属性</li>\n</ol>\n<p>我们对构造函数做一些改造，让它返回一些东西</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1) <span class=\"comment\">//Person &#123;name:&quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>由此可发现，虽然构造函数返回了一个1，但是new出来的实例并没受此影响，返回值无生效</p>\n<p>假如将构造函数的返回值换成一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;<span class=\"attr\">age</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1) <span class=\"comment\">//Person &#123;age:1&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里可以发现，构造函数返回了一个对象，那么new出来的实例会使用的是这个对象，而不是构造函数的this。</p>\n<h1 id=\"2-new做了什么\"><a href=\"#2-new做了什么\" class=\"headerlink\" title=\"2.new做了什么\"></a>2.new做了什么</h1><p>在new一个实例对象的时候，其实它做了以下操作</p>\n<ol>\n<li>创建一个空对象</li>\n<li>将空对象的原型链指向构造函数的原型链</li>\n<li>执行构造函数，将this绑定到空对象上</li>\n<li>根据构造函数的返回值做判断，若是原始数据则忽略，若是对象的话则正常返回处理<h1 id=\"3-手撕new\"><a href=\"#3-手撕new\" class=\"headerlink\" title=\"3.手撕new\"></a>3.手撕new</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">fn,...args</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//创建一个空对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//将obj的原型指向构造函数的原型</span></span><br><span class=\"line\">\tobj.<span class=\"property\">__proto__</span> = fn.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将构造函数的this指向obj，并且拿到构造函数返回值</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> res = <span class=\"title class_\">Fn</span>.<span class=\"title function_\">apply</span>(obj,args)</span><br><span class=\"line\">\t<span class=\"comment\">//判断构造函数返回值类型，决定new构造出来的实例对象的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span> ? <span class=\"attr\">res</span>:obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-new是什么\"><a href=\"#1-new是什么\" class=\"headerlink\" title=\"1.new是什么\"></a>1.new是什么</h1><p>在JavaScript中，new操作符用于创建一个给定构造函数的实例对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1)  <span class=\"comment\">// Person &#123;name: &quot;A&quot;&#125;</span></span><br><span class=\"line\">person1.<span class=\"title function_\">getName</span>() <span class=\"comment\">// &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>从以上代码可以推测到，new一个实例对象的时候，它实现了这些功能</p>\n<ol>\n<li>new出来的实例对象能访问到构造函数中的属性</li>\n<li>new出来的实例对象能访问到构造函数原型链中的属性</li>\n</ol>\n<p>我们对构造函数做一些改造，让它返回一些东西</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1) <span class=\"comment\">//Person &#123;name:&quot;A&quot;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>由此可发现，虽然构造函数返回了一个1，但是new出来的实例并没受此影响，返回值无生效</p>\n<p>假如将构造函数的返回值换成一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>)&#123;</span><br><span class=\"line\">\t<span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;<span class=\"attr\">age</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;A&#x27;</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1) <span class=\"comment\">//Person &#123;age:1&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这里可以发现，构造函数返回了一个对象，那么new出来的实例会使用的是这个对象，而不是构造函数的this。</p>\n<h1 id=\"2-new做了什么\"><a href=\"#2-new做了什么\" class=\"headerlink\" title=\"2.new做了什么\"></a>2.new做了什么</h1><p>在new一个实例对象的时候，其实它做了以下操作</p>\n<ol>\n<li>创建一个空对象</li>\n<li>将空对象的原型链指向构造函数的原型链</li>\n<li>执行构造函数，将this绑定到空对象上</li>\n<li>根据构造函数的返回值做判断，若是原始数据则忽略，若是对象的话则正常返回处理<h1 id=\"3-手撕new\"><a href=\"#3-手撕new\" class=\"headerlink\" title=\"3.手撕new\"></a>3.手撕new</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myNew</span>(<span class=\"params\">fn,...args</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//创建一个空对象</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//将obj的原型指向构造函数的原型</span></span><br><span class=\"line\">\tobj.<span class=\"property\">__proto__</span> = fn.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将构造函数的this指向obj，并且拿到构造函数返回值</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> res = <span class=\"title class_\">Fn</span>.<span class=\"title function_\">apply</span>(obj,args)</span><br><span class=\"line\">\t<span class=\"comment\">//判断构造函数返回值类型，决定new构造出来的实例对象的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span> ? <span class=\"attr\">res</span>:obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cldlcekgr0000ywnkfbn18myk","tag_id":"cldlcekgz0002ywnkfbcx4auz","_id":"cldlcekh50007ywnk6cyiatjr"},{"post_id":"cldlcekh30005ywnkg0hgf2zf","tag_id":"cldlcekgz0002ywnkfbcx4auz","_id":"cldlcekh60009ywnk8m3i5eta"},{"post_id":"cldlcekgx0001ywnkhy93c591","tag_id":"cldlcekgz0002ywnkfbcx4auz","_id":"cldlcekh8000cywnkamkp3q1v"},{"post_id":"cldlcekh10003ywnkald350vy","tag_id":"cldlcekgz0002ywnkfbcx4auz","_id":"cldlcekhb000gywnkbdaa4jds"},{"post_id":"cldlcekh20004ywnkffnj7j6u","tag_id":"cldlcekha000fywnk2iwy22bc","_id":"cldlcekhe000lywnk6fpl8kve"},{"post_id":"cldlcekh50008ywnk7pwy18xm","tag_id":"cldlcekhd000jywnkejnc3aol","_id":"cldlcekhg000pywnk7vokbip9"},{"post_id":"cldlcekhe000mywnk3idw9mik","tag_id":"cldlcekhd000jywnkejnc3aol","_id":"cldlcekhh000qywnk0xvq2e0u"},{"post_id":"cldlcekhg000oywnkcqx1d0er","tag_id":"cldlcekgz0002ywnkfbcx4auz","_id":"cldlcekhh000sywnkc4elfzda"},{"post_id":"cldlcekh6000aywnke5wr939o","tag_id":"cldlcekhf000nywnkdm5p7g8g","_id":"cldlcekhh000tywnk2to978zg"},{"post_id":"cldlcekh8000dywnkdnjy300p","tag_id":"cldlcekhh000rywnkgw123jfc","_id":"cldlcekhi000vywnk0f7k4yt1"},{"post_id":"cldlcekh9000eywnkb78hdkjq","tag_id":"cldlcekhi000uywnk8u1u8z1i","_id":"cldlcekhj000xywnkgzypfjzg"},{"post_id":"cldlcekhb000hywnk7jrp1k07","tag_id":"cldlcekhd000jywnkejnc3aol","_id":"cldlcekhj000zywnkchnkdc52"},{"post_id":"cldlcekhc000iywnk6n1i3dd4","tag_id":"cldlcekhh000rywnkgw123jfc","_id":"cldlcekhk0011ywnkgqwyas1z"},{"post_id":"cldlcekhd000kywnkg42fb15a","tag_id":"cldlcekhi000uywnk8u1u8z1i","_id":"cldlcekhk0012ywnk65bhborl"}],"Tag":[{"name":"JavaScript","_id":"cldlcekgz0002ywnkfbcx4auz"},{"name":"计算机网络","_id":"cldlcekha000fywnk2iwy22bc"},{"name":"其他","_id":"cldlcekhd000jywnkejnc3aol"},{"name":"算法","_id":"cldlcekhf000nywnkdm5p7g8g"},{"name":"工程化","_id":"cldlcekhh000rywnkgw123jfc"},{"name":"node","_id":"cldlcekhi000uywnk8u1u8z1i"}]}}