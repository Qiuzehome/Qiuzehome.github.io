---
title: 几个常见的时间复杂度
date: 2023-02-01 11:33:02
tags: 算法
description: 介绍几个常见的事件复杂度
---
# 1.时间复杂度定义
算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。
简单来说就是**执行算法所需要的计算工作量**

# 2.计算时间复杂度
## O(1)
```javascript
function fn1(){
	console.log(1)
	console.log(2)
}
```
函数fn1运行的时候执行了两次console，所以它的时间复杂度是2，用O表示为O(2)，但对于**常数**项往往可以忽略不计，所以我们一般将**常数项计算为1，就算是O(100)我们时间复杂度也用O(1)表示**。
## O(n)

```javascript
function fn2(n){
	for(let i =0;i<n;i++){
		console.log(n)
	}
}
```
函数fn2执行的时候，首先for中的``let i  = 0 ``执行了一次，接着执行``i < 0``，然后执行console，再执行``i++``，以此类推到最后，``i<0``将执行**n+1次**，``console``将执行**n次**，``i++``执行**n次**，加上一开始的``let i = 0``，一共是**1+n+1+n+n = 3n+2次**，即**O(n)=常数*n+常数**，当n达到一定数量后，第二部分的常数可以忽略不计，即**O(n)=常数*n**，将剩下的常数当作该系数的常数作为1，**得到最终时间复杂度O(n)**
## O($n^2$)
```javascript
function fn3(n){
	for(let i = 0; i < n;i ++){
		for(let i = 0; i < n; i++){
			console.log(n)
		}
	}
}
```
根据上面的方法，我们可以推断出fn3的执行时间为$1+n+1+n+n\times(1+n+1+n+1) =2n^2+5n+2$，根据刚提到的省略常量，以及将系数作为1处理则得到$n^2  +n$，当n达到一定值时，**相对于$n^2$，n可忽略所以最终得到时间复杂度为O($n^2$)，当执行次数出现多个幂时，则取最高的，如$n^3+n^4+n^5+5$，则取$n^5$即可**
## O(log$2^n$)
```javascript
function fn4(n){
	for(let i =1; i < n; i*=2){
		console.log(n)
	}
}
```
fn4当传入参数n为8时，首先i = 1，小于8成立，执行循环体内代码1次，i * 2 = 2，小于8继续成立，循环体内代码执行次数加一，i *2 = 4，小于8成立继续，循环体内执行第3次，接着i *2 = 8，小于8不成立循环结束，一共执行了3次。得到**O(8) =3**
**$2^3 = 8$，$3 = log2^8$**，由此可得到$O(8) = log2^8$